<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title>pylit.py: Literate programming with reStructuredText</title>
<meta name="date" content="2007-05-18" />
<meta name="copyright" content="2005, 2007 Guenter Milde. Released under the terms of the GNU General Public License (v. 2 or later)" />
<link rel="stylesheet" href="/usr/lib/python2.4/site-packages/docutils/writers/html4css1/html4css1.css" type="text/css" />
</head>
<body>
<div class="document" id="pylit-py-literate-programming-with-restructuredtext">
<h1 class="title">pylit.py: Literate programming with reStructuredText</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Date:</th>
<td>2007-05-18</td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>SVN-Revision 45</td></tr>
<tr class="field"><th class="docinfo-name">URL:</th><td class="field-body">svn+ssh://svn.berlios.de/svnroot/repos/pylit/trunk/src/pylit.py</td>
</tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>2005, 2007 Guenter Milde.
Released under the terms of the GNU General Public License
(v. 2 or later)</td></tr>
</tbody>
</table>
<!-- #!/usr/bin/env python
# -*- coding: iso-8859-1 -*- -->
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#frontmatter" id="id11" name="id11">1&nbsp;&nbsp;&nbsp;Frontmatter</a><ul class="auto-toc">
<li><a class="reference" href="#changelog" id="id12" name="id12">1.1&nbsp;&nbsp;&nbsp;Changelog</a></li>
<li><a class="reference" href="#introduction" id="id13" name="id13">1.2&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#requirements" id="id14" name="id14">1.3&nbsp;&nbsp;&nbsp;Requirements</a></li>
</ul>
</li>
<li><a class="reference" href="#customisation" id="id15" name="id15">2&nbsp;&nbsp;&nbsp;Customisation</a><ul class="auto-toc">
<li><a class="reference" href="#defaults" id="id16" name="id16">2.1&nbsp;&nbsp;&nbsp;defaults</a></li>
</ul>
</li>
<li><a class="reference" href="#converter-classes" id="id17" name="id17">3&nbsp;&nbsp;&nbsp;Converter Classes</a><ul class="auto-toc">
<li><a class="reference" href="#converter" id="id18" name="id18">3.1&nbsp;&nbsp;&nbsp;Converter</a><ul class="auto-toc">
<li><a class="reference" href="#data-attributes" id="id19" name="id19">3.1.1&nbsp;&nbsp;&nbsp;Data attributes</a></li>
<li><a class="reference" href="#converter-init" id="id20" name="id20">3.1.2&nbsp;&nbsp;&nbsp;Converter.__init__</a></li>
<li><a class="reference" href="#converter-iter" id="id21" name="id21">3.1.3&nbsp;&nbsp;&nbsp;Converter.__iter__</a></li>
<li><a class="reference" href="#converter-call" id="id22" name="id22">3.1.4&nbsp;&nbsp;&nbsp;Converter.__call__</a></li>
<li><a class="reference" href="#converter-str" id="id23" name="id23">3.1.5&nbsp;&nbsp;&nbsp;Converter.__str__</a></li>
<li><a class="reference" href="#converter-get-indent" id="id24" name="id24">3.1.6&nbsp;&nbsp;&nbsp;Converter.get_indent</a></li>
<li><a class="reference" href="#converter-ensure-trailing-blank-line" id="id25" name="id25">3.1.7&nbsp;&nbsp;&nbsp;Converter.ensure_trailing_blank_line</a></li>
<li><a class="reference" href="#converter-collect-blocks" id="id26" name="id26">3.1.8&nbsp;&nbsp;&nbsp;Converter.collect_blocks</a></li>
<li><a class="reference" href="#converter-split-blocks" id="id27" name="id27">3.1.9&nbsp;&nbsp;&nbsp;Converter.split_blocks</a></li>
</ul>
</li>
<li><a class="reference" href="#text2code" id="id28" name="id28">3.2&nbsp;&nbsp;&nbsp;Text2Code</a><ul class="auto-toc">
<li><a class="reference" href="#text2code-convert-blocks" id="id29" name="id29">3.2.1&nbsp;&nbsp;&nbsp;Text2Code.convert_blocks</a></li>
<li><a class="reference" href="#text2code-set-state" id="id30" name="id30">3.2.2&nbsp;&nbsp;&nbsp;Text2Code.set_state</a></li>
<li><a class="reference" href="#text2code-documentation-handler" id="id31" name="id31">3.2.3&nbsp;&nbsp;&nbsp;Text2Code.documentation_handler</a></li>
<li><a class="reference" href="#text2code-code-block-handler" id="id32" name="id32">3.2.4&nbsp;&nbsp;&nbsp;Text2Code.code_block_handler</a></li>
</ul>
</li>
<li><a class="reference" href="#code2text" id="id33" name="id33">3.3&nbsp;&nbsp;&nbsp;Code2Text</a><ul class="auto-toc">
<li><a class="reference" href="#code2text-convert-blocks" id="id34" name="id34">3.3.1&nbsp;&nbsp;&nbsp;Code2Text.convert_blocks</a></li>
<li><a class="reference" href="#code2text-set-state" id="id35" name="id35">3.3.2&nbsp;&nbsp;&nbsp;Code2Text.set_state</a></li>
<li><a class="reference" href="#code2text-header-handler" id="id36" name="id36">3.3.3&nbsp;&nbsp;&nbsp;Code2Text.header_handler</a></li>
<li><a class="reference" href="#code2text-documentation-handler" id="id37" name="id37">3.3.4&nbsp;&nbsp;&nbsp;Code2Text.documentation_handler</a></li>
<li><a class="reference" href="#code2text-code-block-handler" id="id38" name="id38">3.3.5&nbsp;&nbsp;&nbsp;Code2Text.code_block_handler</a></li>
<li><a class="reference" href="#code2text-strip-literal-marker" id="id39" name="id39">3.3.6&nbsp;&nbsp;&nbsp;Code2Text.strip_literal_marker</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#filters" id="id40" name="id40">4&nbsp;&nbsp;&nbsp;Filters</a></li>
<li><a class="reference" href="#command-line-use" id="id41" name="id41">5&nbsp;&nbsp;&nbsp;Command line use</a><ul class="auto-toc">
<li><a class="reference" href="#dual-source-handling" id="id42" name="id42">5.1&nbsp;&nbsp;&nbsp;Dual source handling</a><ul class="auto-toc">
<li><a class="reference" href="#how-to-determine-which-source-is-up-to-date" id="id43" name="id43">5.1.1&nbsp;&nbsp;&nbsp;How to determine which source is up-to-date?</a></li>
<li><a class="reference" href="#recognised-filename-extensions" id="id44" name="id44">5.1.2&nbsp;&nbsp;&nbsp;Recognised Filename Extensions</a></li>
</ul>
</li>
<li><a class="reference" href="#optionvalues" id="id45" name="id45">5.2&nbsp;&nbsp;&nbsp;OptionValues</a><ul class="auto-toc">
<li><a class="reference" href="#optionvalues-as-dict" id="id46" name="id46">5.2.1&nbsp;&nbsp;&nbsp;OptionValues.as_dict</a></li>
<li><a class="reference" href="#optionvalues-complete" id="id47" name="id47">5.2.2&nbsp;&nbsp;&nbsp;OptionValues.complete</a></li>
<li><a class="reference" href="#optionvalues-getattr" id="id48" name="id48">5.2.3&nbsp;&nbsp;&nbsp;OptionValues.__getattr__</a></li>
</ul>
</li>
<li><a class="reference" href="#pylitoptions" id="id49" name="id49">5.3&nbsp;&nbsp;&nbsp;PylitOptions</a><ul class="auto-toc">
<li><a class="reference" href="#instantiation" id="id50" name="id50">5.3.1&nbsp;&nbsp;&nbsp;Instantiation</a></li>
<li><a class="reference" href="#pylitoptions-parse-args" id="id51" name="id51">5.3.2&nbsp;&nbsp;&nbsp;PylitOptions.parse_args</a></li>
<li><a class="reference" href="#pylitoptions-complete-values" id="id52" name="id52">5.3.3&nbsp;&nbsp;&nbsp;PylitOptions.complete_values</a></li>
<li><a class="reference" href="#pylitoptions-get-outfile-name" id="id53" name="id53">5.3.4&nbsp;&nbsp;&nbsp;PylitOptions._get_outfile_name</a></li>
<li><a class="reference" href="#pylitoptions-call" id="id54" name="id54">5.3.5&nbsp;&nbsp;&nbsp;PylitOptions.__call__</a></li>
</ul>
</li>
<li><a class="reference" href="#helper-functions" id="id55" name="id55">5.4&nbsp;&nbsp;&nbsp;Helper functions</a><ul class="auto-toc">
<li><a class="reference" href="#open-streams" id="id56" name="id56">5.4.1&nbsp;&nbsp;&nbsp;open_streams</a></li>
<li><a class="reference" href="#is-newer" id="id57" name="id57">5.4.2&nbsp;&nbsp;&nbsp;is_newer</a></li>
<li><a class="reference" href="#get-converter" id="id58" name="id58">5.4.3&nbsp;&nbsp;&nbsp;get_converter</a></li>
</ul>
</li>
<li><a class="reference" href="#use-cases" id="id59" name="id59">5.5&nbsp;&nbsp;&nbsp;Use cases</a><ul class="auto-toc">
<li><a class="reference" href="#run-doctest" id="id60" name="id60">5.5.1&nbsp;&nbsp;&nbsp;run_doctest</a></li>
<li><a class="reference" href="#diff" id="id61" name="id61">5.5.2&nbsp;&nbsp;&nbsp;diff</a></li>
<li><a class="reference" href="#execute" id="id62" name="id62">5.5.3&nbsp;&nbsp;&nbsp;execute</a></li>
</ul>
</li>
<li><a class="reference" href="#main" id="id63" name="id63">5.6&nbsp;&nbsp;&nbsp;main</a></li>
</ul>
</li>
<li><a class="reference" href="#open-questions" id="id64" name="id64">6&nbsp;&nbsp;&nbsp;Open questions</a><ul class="auto-toc">
<li><a class="reference" href="#clean-code" id="id65" name="id65">6.1&nbsp;&nbsp;&nbsp;Clean code</a></li>
<li><a class="reference" href="#options" id="id66" name="id66">6.2&nbsp;&nbsp;&nbsp;Options</a></li>
<li><a class="reference" href="#parsing-problems" id="id67" name="id67">6.3&nbsp;&nbsp;&nbsp;Parsing Problems</a></li>
<li><a class="reference" href="#code-block-directive" id="id68" name="id68">6.4&nbsp;&nbsp;&nbsp;code-block directive</a></li>
<li><a class="reference" href="#doctstrings-in-code-blocks" id="id69" name="id69">6.5&nbsp;&nbsp;&nbsp;doctstrings in code blocks</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id11" id="frontmatter" name="frontmatter">1&nbsp;&nbsp;&nbsp;Frontmatter</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id12" id="changelog" name="changelog">1.1&nbsp;&nbsp;&nbsp;Changelog</a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">2005-06-29:</th><td class="field-body">Initial version</td>
</tr>
<tr class="field"><th class="field-name">2005-06-30:</th><td class="field-body">first literate version of the script</td>
</tr>
<tr class="field"><th class="field-name">2005-07-01:</th><td class="field-body">object orientated script using generators</td>
</tr>
<tr class="field"><th class="field-name">2005-07-10:</th><td class="field-body">Two state machine (later added 'header' state)</td>
</tr>
<tr class="field"><th class="field-name">2006-12-04:</th><td class="field-body">Start of work on version 0.2 (code restructuring)</td>
</tr>
<tr class="field"><th class="field-name">2007-01-23:</th><td class="field-body">0.2   published at <a class="reference" href="http://pylit.berlios.de">http://pylit.berlios.de</a></td>
</tr>
<tr class="field"><th class="field-name">2007-01-25:</th><td class="field-body">0.2.1 Outsourced non-core documentation to the PyLit pages.</td>
</tr>
<tr class="field"><th class="field-name">2007-01-26:</th><td class="field-body">0.2.2 new behaviour of <cite>diff</cite> function</td>
</tr>
<tr class="field"><th class="field-name">2007-01-29:</th><td class="field-body">0.2.3 new <cite>header</cite> methods after suggestion by Riccardo Murri</td>
</tr>
<tr class="field"><th class="field-name">2007-01-31:</th><td class="field-body">0.2.4 raise Error if code indent is too small</td>
</tr>
<tr class="field"><th class="field-name">2007-02-05:</th><td class="field-body">0.2.5 new command line option --comment-string</td>
</tr>
<tr class="field"><th class="field-name">2007-02-09:</th><td class="field-body">0.2.6 add section with open questions,
Code2Text: let only blank lines (no comment str)
separate text and code,
fix <cite>Code2Text.header</cite></td>
</tr>
<tr class="field"><th class="field-name">2007-02-19:</th><td class="field-body">0.2.7 simplify <cite>Code2Text.header,</cite>
new <cite>iter_strip</cite> method replacing a lot of <tt class="docutils literal"><span class="pre">if</span></tt>-s</td>
</tr>
<tr class="field"><th class="field-name">2007-02-22:</th><td class="field-body">0.2.8 set <cite>mtime</cite> of outfile to the one of infile</td>
</tr>
<tr class="field"><th class="field-name">2007-02-27:</th><td class="field-body">0.3   new <cite>Code2Text</cite> converter after an idea by Riccardo Murri
explicite <cite>option_defaults</cite> dict for easier customization</td>
</tr>
<tr class="field"><th class="field-name">2007-03-02:</th><td class="field-body">0.3.1 expand hard-tabs to prevent errors in indentation,
<cite>Text2Code</cite> now also works on blocks,
removed dependency on SimpleStates module</td>
</tr>
<tr class="field"><th class="field-name">2007-03-06:</th><td class="field-body">0.3.2 bugfix: do not set <cite>language</cite> in <cite>option_defaults</cite>
renamed <cite>code_languages</cite> to <cite>languages</cite></td>
</tr>
<tr class="field"><th class="field-name">2007-03-16:</th><td class="field-body">0.3.3 new language css
option_defaults -&gt; defaults = optparse.Values()
simpler PylitOptions: don't store parsed values,
don't parse at initialization.
OptionValues: return <cite>None</cite> for non-existing attributes
removed -infile and -outfile, use positional arguments</td>
</tr>
<tr class="field"><th class="field-name">2007-03-19:</th><td class="field-body">0.3.4 documentation update
separate <cite>execute</cite> function</td>
</tr>
<tr class="field"><th class="field-name">2007-03-21:</th><td class="field-body">code cleanup in <cite>Text2Code.__iter__</cite></td>
</tr>
<tr class="field"><th class="field-name">2007-03-23:</th><td class="field-body">0.3.5 removed &quot;css&quot; from languages after learning that
there is no C++ style &quot;// &quot; comment in css2</td>
</tr>
<tr class="field"><th class="field-name">2007-04-24:</th><td class="field-body">0.3.6 documentation update</td>
</tr>
<tr class="field"><th class="field-name">2007-05-18:</th><td class="field-body">0.4   Implement Converter.__iter__ as stack of iterator
generators. Iterating over a converter instance now
yields lines instead of blocks.
Provide &quot;hooks&quot; for pre- and postprocessing filters
Rename states to avoid confusion with formats:
&quot;text&quot; -&gt; &quot;documentation&quot;, &quot;code&quot; -&gt; &quot;code_block&quot;</td>
</tr>
</tbody>
</table>
<pre class="literal-block">
&quot;&quot;&quot;pylit: bidirectional converter between a *text source* with embedded
computer code and a *code source* with embedded documentation.
&quot;&quot;&quot;

__docformat__ = 'restructuredtext'

_version = &quot;0.3&quot;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id13" id="introduction" name="introduction">1.2&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>PyLit is a bidirectional converter between two formats of a computer
program source:</p>
<ul class="simple">
<li>a (reStructured) text document with program code embedded in
code blocks, and</li>
<li>a code source with documentation embedded in comment blocks</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id14" id="requirements" name="requirements">1.3&nbsp;&nbsp;&nbsp;Requirements</a></h2>
<pre class="literal-block">
import re
import os
import sys
import optparse
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id15" id="customisation" name="customisation">2&nbsp;&nbsp;&nbsp;Customisation</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id16" id="defaults" name="defaults">2.1&nbsp;&nbsp;&nbsp;defaults</a></h2>
<p>The <cite>defaults</cite> object provides a central repository for default values
and their customisation.</p>
<ul>
<li><p class="first">used for the initialization of data arguments in <a class="reference" href="#converter">Converter</a> and
<a class="reference" href="#pylitoptions">PylitOptions</a></p>
</li>
<li><p class="first">used for completion of command line options in
<a class="reference" href="#pylitoptions-complete-values">PylitOptions.complete_values</a>. This way, using <cite>pylit.py</cite> as
module one can customise the defaults and then call <a class="reference" href="#main">main</a> e.g.:</p>
<pre class="doctest-block">
&gt;&gt;&gt; import pylit
&gt;&gt;&gt; defaults.comment_string = &quot;## &quot;
&gt;&gt;&gt; defaults.codeindent = 4
&gt;&gt;&gt; main()
</pre>
</li>
</ul>
<pre class="literal-block">
defaults = optparse.Values()
</pre>
<p>By default, the language is set by <a class="reference" href="#optionvalues-complete">OptionValues.complete</a> from the code
file extension. The <tt class="docutils literal"><span class="pre">--language`</span> <span class="pre">command</span> <span class="pre">line</span> <span class="pre">option</span> <span class="pre">or</span> <span class="pre">setting</span>
<span class="pre">``defaults.language</span></tt> in programmatic use will override this auto-setting
feature:</p>
<pre class="literal-block">
defaults.languages  = {&quot;.py&quot;: &quot;python&quot;,
                       &quot;.sl&quot;: &quot;slang&quot;,
                       &quot;.c&quot;: &quot;c++&quot;}
</pre>
<p>If there is no matching extension, e.g. if pylit is used as filter, fall
back to the <cite>fallback_language</cite>:</p>
<pre class="literal-block">
defaults.fallback_language = &quot;python&quot;
</pre>
<p>Pre- and|or post-process the data by language-specific <a class="reference" href="#filters">filters</a>:</p>
<pre class="literal-block">
defaults.preprocessors = {}
defaults.postprocessors = {}
</pre>
<p>The <cite>code extensions</cite> are used in <a class="reference" href="#optionvalues-complete">OptionValues.complete</a> to auto-determine
the conversion direction from the input and output file names:</p>
<pre class="literal-block">
defaults.code_extensions = defaults.languages.keys()
</pre>
<p>The <cite>text_extensions</cite> are used by <cite>OptionValues._get_outfile</cite> to
auto-determine the output filename:</p>
<pre class="literal-block">
defaults.text_extensions = [&quot;.txt&quot;]
</pre>
<p><cite>Comment strings</cite> for the various known languages include a trailing space.
Used in <a class="reference" href="#code2text">Code2Text</a> to recognise text blocks and in <a class="reference" href="#text2code">Text2Code</a> to format text
blocks as comments:</p>
<pre class="literal-block">
defaults.comment_strings = {&quot;python&quot;: '# ',
                            &quot;slang&quot;:  '% ',
                            &quot;c++&quot;:    '// '}
</pre>
<p>Marker string for a header code block in the text source. (Should be a valid
rst directive that accepts code on the same line, e.g. <tt class="docutils literal"><span class="pre">'..</span>
<span class="pre">admonition::'</span></tt>.) No trailing whitespace needed as indented code follows.
Default is a comment marker:</p>
<pre class="literal-block">
defaults.header_string = '..'
</pre>
<p>Export to the output format stripping documentation or code blocks:</p>
<pre class="literal-block">
defaults.strip = False
</pre>
<p>Number of spaces to indent code blocks in <a class="reference" href="#code2text-code-block-handler">Code2Text.code_block_handler</a>.
<a class="footnote-reference" href="#id2" id="id1" name="id1">[2]</a></p>
<pre class="literal-block">
defaults.codeindent =  2
</pre>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id2">[2]</a></td><td>In <a class="reference" href="#text2code-code-block-handler">Text2Code.code_block_handler</a>, the codeindent is determined by the
first recognized code line (leading comment or first indented literal
block of the text source).</td></tr>
</tbody>
</table>
<p>What to do if the outfile already exists? (ignored if <cite>outfile</cite> == '-'):</p>
<pre class="literal-block">
defaults.overwrite = 'update'
</pre>
<p>Recognized values:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">'yes':</th><td class="field-body">overwrite eventually existing <cite>outfile</cite>,</td>
</tr>
<tr class="field"><th class="field-name">'update':</th><td class="field-body">fail if the <cite>outfile</cite> is newer than <cite>infile</cite>,</td>
</tr>
<tr class="field"><th class="field-name">'no':</th><td class="field-body">fail if <cite>outfile</cite> exists.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id17" id="converter-classes" name="converter-classes">3&nbsp;&nbsp;&nbsp;Converter Classes</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id18" id="converter" name="converter">3.1&nbsp;&nbsp;&nbsp;Converter</a></h2>
<p>The converters are implemented as classes derived from a <cite>Converter</cite>
parent class: <a class="reference" href="#text2code">Text2Code</a> converts a text source to executable code, while
<a class="reference" href="#code2text">Code2Text</a> does the opposite: converting commented code to a text source.</p>
<pre class="literal-block">
class PyLitConverter(object):
    &quot;&quot;&quot;parent class for `Text2Code` and `Code2Text`, the state machines
    converting between text source and code source of a literal program.
    &quot;&quot;&quot;
</pre>
<p>The converter classes implement a simple state machine to separate and
transform documentation and code blocks. For this task, only a very limited
parsing is needed. PyLit's parser assumes:</p>
<ul class="simple">
<li>indented literal blocks in a text source are code blocks.</li>
<li>comment lines that start with a matching comment string in a code source
are documentation blocks.</li>
</ul>
<div class="section">
<h3><a class="toc-backref" href="#id19" id="data-attributes" name="data-attributes">3.1.1&nbsp;&nbsp;&nbsp;Data attributes</a></h3>
<p>Class default values are fetched from the <a class="reference" href="#defaults">defaults</a> object and can be
overridden by matching keyword arguments during class instantiation. This
also works with keyword arguments to <a class="reference" href="#get-converter">get_converter</a> and <a class="reference" href="#main">main</a>, as these
functions pass on unused keyword args to the instantiation of a converter
class.</p>
<pre class="literal-block">
language = defaults.fallback_language
comment_strings = defaults.comment_strings
comment_string = &quot;&quot; # set in __init__
codeindent =  defaults.codeindent
header_string = defaults.header_string
strip = defaults.strip
</pre>
<p>Initial state (do not overwrite):</p>
<pre class="literal-block">
state = 'header'
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id20" id="converter-init" name="converter-init">3.1.2&nbsp;&nbsp;&nbsp;Converter.__init__</a></h3>
<p>Initializing sets up the <cite>data</cite> attribute, an iterable object yielding lines
of the source to convert. <a class="footnote-reference" href="#id4" id="id3" name="id3">[1]</a> Additional keyword arguments are stored as
data attributes, overwriting the class defaults. If not given as keyword
argument, <cite>comment_string</cite> is set to the language's default comment
string:</p>
<pre class="literal-block">
def __init__(self, data, **keyw):
    &quot;&quot;&quot;data   --  iterable data object
                  (list, file, generator, string, ...)
       **keyw --  remaining keyword arguments are
                  stored as data-attributes
    &quot;&quot;&quot;
    self.data = data
    self.__dict__.update(keyw)
    if not self.comment_string:
        self.comment_string = self.comment_strings[self.language]
</pre>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="id4">[1]</a></td><td><p class="first">The most common choice of data is a <cite>file</cite> object with the text
or code source.</p>
<p class="last">To convert a string into a suitable object, use its splitlines method
with the optional <cite>keepends</cite> argument set to True.</p>
</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id21" id="converter-iter" name="converter-iter">3.1.3&nbsp;&nbsp;&nbsp;Converter.__iter__</a></h3>
<p>Return an iterator for <cite>self</cite>. Iteration yields lines of converted data.</p>
<p>The iterator is a chain of iterators acting on <cite>self.data</cite> that:</p>
<ul class="simple">
<li>preprocess</li>
<li>collected lines into &quot;blocks&quot; separated by blank lines
<a class="reference" href="#converter-collect-blocks">Converter.collect_blocks</a></li>
<li>convert the block of lines (text&lt;-&gt;code format conversion)
Determine the state of the block (&quot;header&quot;, &quot;documentation&quot; or
&quot;code_block&quot;) and yield the block converted by the matching <em>handler</em>
method.</li>
<li>split the block into lines again</li>
<li>postprocess</li>
</ul>
<pre class="literal-block">
def __iter__(self):
    &quot;&quot;&quot;Iterate over input data source and yield converted lines
    &quot;&quot;&quot;
    # set pre- and post-processing filters
    preprocessor = self.get_preprocessor()
    postprocessor = self.get_postprocessor()
    return postprocessor(self.split_blocks(self.convert_blocks(
           self.collect_blocks(preprocessor(self.data)))))
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id22" id="converter-call" name="converter-call">3.1.4&nbsp;&nbsp;&nbsp;Converter.__call__</a></h3>
<p>The special <cite>__call__</cite> method allows the use of class instances as callable
objects. It returns the converted data as list:</p>
<pre class="literal-block">
def __call__(self):
    &quot;&quot;&quot;Iterate over state-machine and return results as list of lines&quot;&quot;&quot;
    return [line for line in self]
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id23" id="converter-str" name="converter-str">3.1.5&nbsp;&nbsp;&nbsp;Converter.__str__</a></h3>
<p>Return converted data as string:</p>
<pre class="literal-block">
def __str__(self):
    return &quot;&quot;.join(self())
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id24" id="converter-get-indent" name="converter-get-indent">3.1.6&nbsp;&nbsp;&nbsp;Converter.get_indent</a></h3>
<p>Return the number of leading spaces in <cite>line</cite> after expanding tabs</p>
<pre class="literal-block">
def get_indent(self, line):
    &quot;&quot;&quot;Return the indentation of `string`.
    &quot;&quot;&quot;
    # line = line.expandtabs() # now done in `collect_blocks`
    return len(line) - len(line.lstrip())
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id25" id="converter-ensure-trailing-blank-line" name="converter-ensure-trailing-blank-line">3.1.7&nbsp;&nbsp;&nbsp;Converter.ensure_trailing_blank_line</a></h3>
<p>Ensure there is a blank line as last element of the list <cite>lines</cite>.
(currently not used):</p>
<pre class="literal-block">
def ensure_trailing_blank_line(self, lines, next_line):
    if not lines:
        return
    if lines[-1].lstrip():
        sys.stderr.write(&quot;\nWarning: inserted blank line between\n %s %s&quot;
                         %(lines[-1], next_line))
        lines.append(&quot;\n&quot;)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id26" id="converter-collect-blocks" name="converter-collect-blocks">3.1.8&nbsp;&nbsp;&nbsp;Converter.collect_blocks</a></h3>
<p>A generator function to aggregate &quot;paragraphs&quot; (blocks separated by blank
lines):</p>
<pre class="literal-block">
def collect_blocks(self, data):
    &quot;&quot;&quot;collect lines in a list

    yield list for each paragraph, i.e. block of lines seperated by a
    blank line (whitespace only).

    Also expand hard-tabs as these will lead to errors in indentation
    (see `str.expandtabs`).
    &quot;&quot;&quot;
    block = []
    for line in self.data:
        block.append(line.expandtabs())
        if not line.rstrip():
            yield block
            block = []
    yield block
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id27" id="converter-split-blocks" name="converter-split-blocks">3.1.9&nbsp;&nbsp;&nbsp;Converter.split_blocks</a></h3>
<p>A generator function to yield blocks (lists of lines) line-wise, i.e.
split data items (lists of lines) into separate lines:</p>
<pre class="literal-block">
def split_blocks(self, data):
    &quot;&quot;&quot;yield lines from a list
    &quot;&quot;&quot;
    for block in data:
        for line in block:
            yield line
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id28" id="text2code" name="text2code">3.2&nbsp;&nbsp;&nbsp;Text2Code</a></h2>
<p>The <cite>Text2Code</cite> class separates code blocks (indented literal blocks) from
documentation. Code blocks are unindented, documentation is commented
(or filtered, if the <tt class="docutils literal"><span class="pre">strip</span></tt> option is True.</p>
<p>Only <cite>indented literal blocks</cite> are extracted. <cite>quoted literal blocks</cite> and
<cite>pydoc blocks</cite> are treated as text. This allows the easy inclusion of
examples: <a class="footnote-reference" href="#id6" id="id5" name="id5">[3]</a></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; 23 + 3
26
</pre>
</blockquote>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5" name="id6">[3]</a></td><td>Mark that there is no double colon before the doctest block in
the text source.</td></tr>
</tbody>
</table>
<p>Using the full blown <a class="reference" href="http://docutils.sourceforge.net/">docutils</a> rst parser would introduce a large overhead
and slow down the conversion.</p>
<pre class="literal-block">
class Text2Code(PyLitConverter):
    &quot;&quot;&quot;Convert a (reStructured) text source to code source
    &quot;&quot;&quot;
</pre>
<p>Filter the  data by wrapping it in a language-specific pre- or
post-processing iterator. The iterator must yield the processed input data
linewise:</p>
<pre class="literal-block">
def get_preprocessor(self):
    &quot;&quot;&quot;Return language specific preprocessor&quot;&quot;&quot;
    try:
        return defaults.preprocessors[&quot;text2&quot;+self.language]
    except KeyError:
        return identity_filter

def get_postprocessor(self):
    &quot;&quot;&quot;Return language specific postprocessor&quot;&quot;&quot;
    try:
        return defaults.postprocessors[&quot;text2&quot;+self.language]
    except KeyError:
        return identity_filter
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id29" id="text2code-convert-blocks" name="text2code-convert-blocks">3.2.1&nbsp;&nbsp;&nbsp;Text2Code.convert_blocks</a></h3>
<p>This is the core state machine of the converter class:</p>
<pre class="literal-block">
def convert_blocks(self, blocks):
    &quot;&quot;&quot;Iterate over lists of text lines and convert them to code format
    &quot;&quot;&quot;
</pre>
<p>Initialize data arguments</p>
<p>Done here, so that every new iteration re-initializes them.</p>
<dl class="docutils">
<dt><cite>state</cite> is one of</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">&quot;header&quot;:</th><td class="field-body">first block -&gt; check for leading <cite>header_string</cite></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">&quot;documentation&quot;:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">documentation part: comment out</td>
</tr>
<tr class="field"><th class="field-name">&quot;code_block&quot;:</th><td class="field-body">literal blocks containing source code: unindent</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<pre class="literal-block">
self.state = &quot;header&quot;
</pre>
<dl class="docutils">
<dt><cite>codeindent</cite></dt>
<dd><ul class="first last simple">
<li>stripped from all 'code_block' lines.</li>
<li>set in <a class="reference" href="#text2code-code-block-handler">Text2Code.code_block_handler</a> to the indent of first non-blank
code_block line</li>
</ul>
</dd>
</dl>
<pre class="literal-block">
self._codeindent = None
</pre>
<dl class="docutils">
<dt><cite>_textindent</cite></dt>
<dd><ul class="first last simple">
<li>set by <a class="reference" href="#text2code-documentation-handler">Text2Code.documentation_handler</a> to the minimal indent of a
documentation block</li>
<li>used in <a class="reference" href="#text2code-set-state">Text2Code.set_state</a> to find the end of a code block</li>
</ul>
</dd>
</dl>
<pre class="literal-block">
self._textindent = 0
</pre>
<p>Determine the state of the block and convert with the matching &quot;handler&quot;:</p>
<pre class="literal-block">
for block in blocks:
    self.set_state(block)
    block = getattr(self, self.state+&quot;_handler&quot;)(block)
    yield block
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id30" id="text2code-set-state" name="text2code-set-state">3.2.2&nbsp;&nbsp;&nbsp;Text2Code.set_state</a></h3>
<pre class="literal-block">
def set_state(self, block):
    &quot;&quot;&quot;Determine and set state of `block`.
    &quot;&quot;&quot;
</pre>
<p>The new state depends on the active state (from the last block) and
features of the current block. It is either &quot;header&quot;, &quot;documentation&quot;, or
&quot;code_block&quot;.</p>
<p>If the current state is &quot;header&quot; (first block), check for
the  <cite>header_string</cite>. Strip if present.</p>
<pre class="literal-block">
if self.state == &quot;header&quot;:
    if block[0].startswith(self.header_string):
        block[0] = block[0].replace(self.header_string, &quot;&quot;, 1)
        self.state = &quot;code_block&quot;
    else:
        self.state = &quot;documentation&quot;
</pre>
<p>If the current state is &quot;documentation&quot;, the next block is also
documentation. (the end of a documentation part is detected in the
<cite>Text2Code.documentation_handler</cite>):</p>
<pre class="literal-block">
# elif self.state == &quot;documentation&quot;:
#    self.state = &quot;documentation&quot;
</pre>
<p>A &quot;code_block&quot; ends with the first less indented, nonblank line.
<cite>_textindent</cite> is set by the documentation handler to the indent of the
preceding documentation block:</p>
<pre class="literal-block">
elif self.state == &quot;code_block&quot;:
    indents = [self.get_indent(line) for line in block]
    if indents and min(indents) &lt;= self._textindent:
        self.state = 'documentation'
    else:
        self.state = 'code_block'
</pre>
<p>TODO?: insert blank line before the first line with too-small codeindent
using self.ensure_trailing_blank_line(lines, line) (would need split and
push-back of the documentation part)?</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id31" id="text2code-documentation-handler" name="text2code-documentation-handler">3.2.3&nbsp;&nbsp;&nbsp;Text2Code.documentation_handler</a></h3>
<p>The 'documentation' handler processes everything that is not an indented
literal comment. Documentation is quoted with <cite>self.comment_string</cite> or
filtered (with <cite>--strip=True</cite>).</p>
<pre class="literal-block">
def documentation_handler(self, lines):
    &quot;&quot;&quot;Convert documentation blocks from text to code format
    &quot;&quot;&quot;

    lines = [self.comment_string + line for line in lines]
</pre>
<p>Test for the end of the documentation block: does the second last line end with
<cite>::</cite> but is neither a comment nor a directive?
If end-of-documentation marker is detected,</p>
<ul class="simple">
<li>set state to 'code_block'</li>
<li>set <cite>self._textindent</cite> (needed by <a class="reference" href="#text2code-set-state">Text2Code.set_state</a> to find the
next &quot;documentation&quot; block)</li>
<li>remove the comment from the last line again (it's a separator between documentation
and code blocks).</li>
</ul>
<p>TODO: allow different code marking directives (for syntax color etc)</p>
<pre class="literal-block">
try:
    line = lines[-2]
except IndexError:  # len(lines &lt; 2), e.g. last line of document
    pass
else:
    if (line.rstrip().endswith(&quot;::&quot;)
        and not line.lstrip().startswith(&quot;..&quot;)):
        self.state = &quot;code_block&quot;
        self._textindent = self.get_indent(line)
        lines[-1] = lines[-1].replace(self.comment_string, &quot;&quot;, 1)

if self.strip:
    return []
return lines
</pre>
<p>TODO: Ensure a trailing blank line? Would need to test all
documentation lines for end-of-documentation marker and add a line by calling the
<cite>ensure_trailing_blank_line</cite> method (which also issues a warning)</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id32" id="text2code-code-block-handler" name="text2code-code-block-handler">3.2.4&nbsp;&nbsp;&nbsp;Text2Code.code_block_handler</a></h3>
<p>The &quot;code_block&quot; handler is called with an indented literal block. It
removes leading whitespace up to the indentation of the first code line in
the file (this deviation from docutils behaviour allows indented blocks of
Python code).</p>
<pre class="literal-block">
def code_block_handler(self, block):
    &quot;&quot;&quot;Convert indented literal blocks to source code format
    &quot;&quot;&quot;
</pre>
<p>If still unset, determine the indentation of code blocks from first non-blank
code line:</p>
<pre class="literal-block">
if self._codeindent is None:
    self._codeindent = self.get_indent(block[0])
</pre>
<p>Check if we can safely unindent the code block. There must not be lines less
indented then <cite>_codeindent</cite> otherwise something got wrong.</p>
<pre class="literal-block">
for line in block:
    if line.lstrip() and self.get_indent(line) &lt; self._codeindent:
        raise ValueError, &quot;code block contains line less indented &quot; \
                        &quot;than %d spaces \n%r&quot;%(self._codeindent, block)
</pre>
<p>return unindented block:</p>
<pre class="literal-block">
return [line.replace(&quot; &quot;*self._codeindent, &quot;&quot;, 1) for line in block]
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id33" id="code2text" name="code2text">3.3&nbsp;&nbsp;&nbsp;Code2Text</a></h2>
<p>The <cite>Code2Text</cite> class does the opposite of <a class="reference" href="#text2code">Text2Code</a> -- it processes
valid source code, extracts documentation from comment blocks, and puts
program code in literal blocks.</p>
<p>The class is derived from the PyLitConverter state machine and adds  an
<cite>__iter__</cite> method as well as handlers for &quot;documentation&quot;, and &quot;code_block&quot;
states.</p>
<pre class="literal-block">
class Code2Text(PyLitConverter):
    &quot;&quot;&quot;Convert code source to text source
    &quot;&quot;&quot;

    def get_preprocessor(self):
        &quot;&quot;&quot;Return language specific preprocessor&quot;&quot;&quot;
        try:
            return defaults.preprocessors[self.language+&quot;2text&quot;]
        except KeyError:
            return identity_filter

    def get_postprocessor(self):
        &quot;&quot;&quot;Return language specific postprocessor&quot;&quot;&quot;
        try:
            return defaults.postprocessors[self.language+&quot;2text&quot;]
        except KeyError:
            return identity_filter
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id34" id="code2text-convert-blocks" name="code2text-convert-blocks">3.3.1&nbsp;&nbsp;&nbsp;Code2Text.convert_blocks</a></h3>
<pre class="literal-block">
def convert_blocks(self, blocks):

    self.state = &quot;header&quot;
</pre>
<p>If the last paragraph of a documentation block doesnot end with a
<cite>code_block_marker</cite> (by default, the literal-block marker <tt class="docutils literal"><span class="pre">::</span></tt>), it
should be added by the conversion, so that the back-conversion knows how to
proceed. The <cite>documentation_handler</cite> method will set <cite>code_block_marker</cite> if
there is none at the end of a paragraph. If the next paragaph belongs to a
code block, the <cite>code_block_marker</cite> is yielded.</p>
<pre class="literal-block">
self.code_block_marker = []
</pre>
<p>Determine the state of the block return it processed with the matching
handler:</p>
<pre class="literal-block">
for block in blocks:
    self.set_state(block)
    if self.state == &quot;first_code_block&quot;:
        # eventually insert transition marker
        if self.code_block_marker:
            self.state = &quot;documentation&quot;
            yield self.code_block_marker
        self.state = &quot;code_block&quot;
    yield getattr(self, self.state+&quot;_handler&quot;)(block)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id35" id="code2text-set-state" name="code2text-set-state">3.3.2&nbsp;&nbsp;&nbsp;Code2Text.set_state</a></h3>
<p>Check if block is &quot;header&quot;, &quot;documentation&quot;, or &quot;code_block&quot;:</p>
<p>A paragraph is &quot;documentation&quot;, if every non-blank line starts with a matching
comment string (including whitespace except for commented blank lines)</p>
<pre class="literal-block">
def set_state(self, block):
    &quot;&quot;&quot;Determine state of `block`.&quot;&quot;&quot;
    for line in block:
        if line.startswith(self.comment_string):
            continue
        if not line.rstrip():  # blank line
            continue
        if line.rstrip() == self.comment_string.rstrip(): # blank comment
            continue
        # if we get to this point, it's &quot;header&quot; or &quot;code_block&quot;
        if self.state == &quot;documentation&quot;:
            self.state = &quot;first_code_block&quot;
        elif self.state != &quot;header&quot;:
            self.state = &quot;code_block&quot;
        break
    else:
        self.state = &quot;documentation&quot;
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id36" id="code2text-header-handler" name="code2text-header-handler">3.3.3&nbsp;&nbsp;&nbsp;Code2Text.header_handler</a></h3>
<p>Sometimes code needs to remain on the first line(s) of the document to be
valid. The most common example is the &quot;shebang&quot; line that tells a POSIX
shell how to process an executable file:</p>
<pre class="literal-block">
#!/usr/bin/env python
</pre>
<p>In Python, the <tt class="docutils literal"><span class="pre">#</span> <span class="pre">-*-</span> <span class="pre">coding:</span> <span class="pre">iso-8859-1</span> <span class="pre">-*-</span></tt> line must occure before any
other comment or code.</p>
<p>If we want to keep the line numbers in sync for text and code source, the
reStructured Text markup for these header lines must start at the same line
as the first header line. Therfore, header lines could not be marked as
literal block (this would require the <tt class="docutils literal"><span class="pre">::</span></tt> and an empty line above the code_block).</p>
<p>OTOH, a comment may start at the same line as the comment marker and it
includes subsequent indented lines. Comments are visible in the reStructured
Text source but hidden in the pretty-printed output.</p>
<p>With a header converted to comment in the text source, everything before the
first documentation block (i.e. before the first paragraph using the matching comment
string) will be hidden away (in HTML or PDF output).</p>
<p>This seems a good compromise, the advantages</p>
<ul class="simple">
<li>line numbers are kept</li>
<li>the &quot;normal&quot; code_block conversion rules (indent/unindent by <cite>codeindent</cite> apply</li>
<li>greater flexibility: you can hide a repeating header in a project
consisting of many source files.</li>
</ul>
<p>set off the disadvantages</p>
<ul class="simple">
<li>it may come as surprise if a part of the file is not &quot;printed&quot;,</li>
<li>one more syntax element to learn for rst newbees to start with pylit,
(however, starting from the code source, this will be auto-generated)</li>
</ul>
<p>In the case that there is no matching comment at all, the complete code
source will become a comment -- however, in this case it is not very likely
the source is a literate document anyway.</p>
<p>If needed for the documentation, it is possible to quote the header in (or
after) the first documentation block, e.g. as <cite>parsed literal</cite>.</p>
<pre class="literal-block">
def header_handler(self, lines):
    &quot;&quot;&quot;Set block as header&quot;&quot;&quot;
    # indent block (or strip with self.strip == True)
    codelines = self.code_block_handler(lines)
    if codelines:
        codelines[0] = self.header_string + codelines[0]
    self.state = &quot;code_block&quot;
    return codelines
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id37" id="code2text-documentation-handler" name="code2text-documentation-handler">3.3.4&nbsp;&nbsp;&nbsp;Code2Text.documentation_handler</a></h3>
<p>The <em>documentation state</em> handler converts a comment to a documentation block by
stripping the leading <cite>comment string</cite> from every line:</p>
<pre class="literal-block">
def documentation_handler(self, lines):
    &quot;&quot;&quot;Uncomment documentation blocks in source code
    &quot;&quot;&quot;

    lines = [line.replace(self.comment_string, &quot;&quot;, 1) for line in lines]

    lines = [re.sub(&quot;^&quot;+self.comment_string.rstrip(), &quot;&quot;, line)
             for line in lines]
</pre>
<p>If the code block is stripped, the literal marker would lead to an error
when the text is converted with docutils. Replace it with
<a class="reference" href="#code2text-strip-literal-marker">Code2Text.strip_literal_marker</a>:</p>
<pre class="literal-block">
if self.strip:
    self.strip_literal_marker(lines)
</pre>
<p>Check for code block marker (double colon) at the end of the documentation
block Update the <cite>code_block_marker</cite> argument. (The <cite>code_block marker</cite> is
yielded by <a class="reference" href="#code2text-convert-blocks">Code2Text.convert_blocks</a> at a text -&gt; code transition if it is
not empty):</p>
<pre class="literal-block">
elif len(lines)&gt;1:
    if lines[-2].rstrip().endswith(&quot;::&quot;):
        self.code_block_marker = []
    else:
        self.code_block_marker = [&quot;::\n&quot;, &quot;\n&quot;]
</pre>
<p>Return the documentation block to the calling function:</p>
<pre class="literal-block">
return lines
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id38" id="code2text-code-block-handler" name="code2text-code-block-handler">3.3.5&nbsp;&nbsp;&nbsp;Code2Text.code_block_handler</a></h3>
<p>The <cite>code_block</cite> handler returns the code block as indented literal
block (or filters it, if <tt class="docutils literal"><span class="pre">self.strip</span> <span class="pre">==</span> <span class="pre">True</span></tt>). The amount of the code
indentation is controled by <cite>self.codeindent</cite> (default 2).</p>
<pre class="literal-block">
def code_block_handler(self, lines):
    &quot;&quot;&quot;Covert code blocks to text format (indent or strip)
    &quot;&quot;&quot;
    if self.strip == True:
        return []

    return [&quot; &quot;*self.codeindent + line for line in lines]
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id39" id="code2text-strip-literal-marker" name="code2text-strip-literal-marker">3.3.6&nbsp;&nbsp;&nbsp;Code2Text.strip_literal_marker</a></h3>
<p>Replace the literal marker with the equivalent of docutils replace rules</p>
<ul class="simple">
<li>strip <cite>::</cite>-line (and preceding blank line) if on a line on its own</li>
<li>strip <cite>::</cite> if it is preceded by whitespace.</li>
<li>convert <cite>::</cite> to a single colon if preceded by text</li>
</ul>
<p><cite>lines</cite> should be list of documentation lines (with a trailing blank line).
It is modified in-place:</p>
<pre class="literal-block">
def strip_literal_marker(self, lines):
    try:
        line = lines[-2]
    except IndexError:  # len(lines &lt; 2)
        return

    # split at rightmost '::'
    try:
        (head, tail) = line.rsplit('::', 1)
    except ValueError:  # only one part (no '::')
        return

    # '::' on an extra line
    if not head.strip():
        del(lines[-2])
        # delete preceding line if it is blank
        if len(lines) &gt;= 2 and not lines[-2].lstrip():
            del(lines[-2])
    # '::' follows whitespace
    elif head.rstrip() &lt; head:
        head = head.rstrip()
        lines[-2] = &quot;&quot;.join((head, tail))
    # '::' follows text
    else:
        lines[-2] = &quot;:&quot;.join((head, tail))
</pre>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id40" id="filters" name="filters">4&nbsp;&nbsp;&nbsp;Filters</a></h1>
<p>Filters allow pre- and post-processing of the data to bring it in a format
suitable for the &quot;normal&quot; text&lt;-&gt;code conversion. An example is conversion
of <cite>C</cite> <tt class="docutils literal"><span class="pre">/*</span></tt> <tt class="docutils literal"><span class="pre">*/</span></tt> comments into C++ <tt class="docutils literal"><span class="pre">//</span></tt> comments (and back).</p>
<p>Filters are generator functions that return an iterator that acts on a
<cite>data</cite> iterable and returns processed <cite>data</cite> items (lines).</p>
<p>The most basic filter is the identity filter, that returns its argument as
iterator:</p>
<pre class="literal-block">
def identity_filter(data):
    return iter(data)
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id41" id="command-line-use" name="command-line-use">5&nbsp;&nbsp;&nbsp;Command line use</a></h1>
<p>Using this script from the command line will convert a file according to its
extension. This default can be overridden by a couple of options.</p>
<div class="section">
<h2><a class="toc-backref" href="#id42" id="dual-source-handling" name="dual-source-handling">5.1&nbsp;&nbsp;&nbsp;Dual source handling</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id43" id="how-to-determine-which-source-is-up-to-date" name="how-to-determine-which-source-is-up-to-date">5.1.1&nbsp;&nbsp;&nbsp;How to determine which source is up-to-date?</a></h3>
<ul>
<li><p class="first">set modification date of <cite>oufile</cite> to the one of <cite>infile</cite></p>
<p>Points out that the source files are 'synchronized'.</p>
<ul>
<li><p class="first">Are there problems to expect from &quot;backdating&quot; a file? Which?</p>
<p>Looking at <a class="reference" href="http://www.unix.com/showthread.php?t=20526">http://www.unix.com/showthread.php?t=20526</a>, it seems
perfectly legal to set <cite>mtime</cite> (while leaving <cite>ctime</cite>) as <cite>mtime</cite> is a
description of the &quot;actuality&quot; of the data in the file.</p>
</li>
<li><p class="first">Should this become a default or an option?</p>
</li>
</ul>
</li>
<li><p class="first">alternatively move input file to a backup copy (with option: <cite>--replace</cite>)</p>
</li>
<li><p class="first">check modification date before overwriting
(with option: <cite>--overwrite=update</cite>)</p>
</li>
<li><p class="first">check modification date before editing (implemented as <a class="reference" href="http://www.jedsoft.org/jed/">Jed editor</a>
function <cite>pylit_check()</cite> in <a class="reference" href="http://jedmodes.sourceforge.net/mode/pylit/">pylit.sl</a>)</p>
</li>
</ul>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id44" id="recognised-filename-extensions" name="recognised-filename-extensions">5.1.2&nbsp;&nbsp;&nbsp;Recognised Filename Extensions</a></h3>
<p>Instead of defining a new extension for &quot;pylit&quot; literate programms,
by default <tt class="docutils literal"><span class="pre">.txt</span></tt> will be appended for the text source and stripped by
the conversion to the code source. I.e. for a Python program foo:</p>
<ul class="simple">
<li>the code source is called <tt class="docutils literal"><span class="pre">foo.py</span></tt></li>
<li>the text source is called <tt class="docutils literal"><span class="pre">foo.py.txt</span></tt></li>
<li>the html rendering is called <tt class="docutils literal"><span class="pre">foo.py.html</span></tt></li>
</ul>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id45" id="optionvalues" name="optionvalues">5.2&nbsp;&nbsp;&nbsp;OptionValues</a></h2>
<p>The following class adds <cite>as_dict</cite> and <cite>__getattr__</cite> methods to
<cite>optparse.Values</cite>:</p>
<pre class="literal-block">
class OptionValues(optparse.Values):
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id46" id="optionvalues-as-dict" name="optionvalues-as-dict">5.2.1&nbsp;&nbsp;&nbsp;OptionValues.as_dict</a></h3>
<p>For use as keyword arguments, it is handy to have the options in a
dictionary. <cite>as_dict</cite> returns a copy of the instances object dictionary:</p>
<pre class="literal-block">
def as_dict(self):
    &quot;&quot;&quot;Return options as dictionary object&quot;&quot;&quot;
    return self.__dict__.copy()
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id47" id="optionvalues-complete" name="optionvalues-complete">5.2.2&nbsp;&nbsp;&nbsp;OptionValues.complete</a></h3>
<pre class="literal-block">
def complete(self, **keyw):
    &quot;&quot;&quot;
    Complete the option values with keyword arguments.

    Do not overwrite existing values. Only use arguments that do not
    have a corresponding attribute in `self`,
    &quot;&quot;&quot;
    for key in keyw:
        if not self.__dict__.has_key(key):
            setattr(self, key, keyw[key])
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id48" id="optionvalues-getattr" name="optionvalues-getattr">5.2.3&nbsp;&nbsp;&nbsp;OptionValues.__getattr__</a></h3>
<p>To replace calls using <tt class="docutils literal"><span class="pre">options.ensure_value(&quot;OPTION&quot;,</span> <span class="pre">None)</span></tt> with the
more concise <tt class="docutils literal"><span class="pre">options.OPTION</span></tt>, we define <cite>__getattr__</cite> <a class="footnote-reference" href="#id8" id="id7" name="id7">[4]</a></p>
<pre class="literal-block">
def __getattr__(self, name):
    &quot;&quot;&quot;Return default value for non existing options&quot;&quot;&quot;
    return None
</pre>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7" name="id8">[4]</a></td><td>The special method <cite>__getattr__</cite> is only called when an attribute
lookup has not found the attribute in the usual places (i.e. it is
not an instance attribute nor is it found in the class tree for
self).</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id49" id="pylitoptions" name="pylitoptions">5.3&nbsp;&nbsp;&nbsp;PylitOptions</a></h2>
<p>The <cite>PylitOptions</cite> class comprises an option parser and methods for parsing
and completion of command line options:</p>
<pre class="literal-block">
class PylitOptions(object):
    &quot;&quot;&quot;Storage and handling of command line options for pylit&quot;&quot;&quot;
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id50" id="instantiation" name="instantiation">5.3.1&nbsp;&nbsp;&nbsp;Instantiation</a></h3>
<pre class="literal-block">
def __init__(self):
    &quot;&quot;&quot;Set up an `OptionParser` instance for pylit command line options

    &quot;&quot;&quot;
    p = optparse.OptionParser(usage=main.__doc__, version=_version)
    # add the options
    p.add_option(&quot;-c&quot;, &quot;--code2txt&quot;, dest=&quot;txt2code&quot;, action=&quot;store_false&quot;,
                 help=&quot;convert code source to text source&quot;)
    p.add_option(&quot;--comment-string&quot;, dest=&quot;comment_string&quot;,
                 help=&quot;documentation block marker (default '# ' (for python))&quot; )
    p.add_option(&quot;-d&quot;, &quot;--diff&quot;, action=&quot;store_true&quot;,
                 help=&quot;test for differences to existing file&quot;)
    p.add_option(&quot;--doctest&quot;, action=&quot;store_true&quot;,
                 help=&quot;run doctest.testfile() on the text version&quot;)
    p.add_option(&quot;-e&quot;, &quot;--execute&quot;, action=&quot;store_true&quot;,
                 help=&quot;execute code (Python only)&quot;)
    p.add_option(&quot;--language&quot;, action=&quot;store&quot;,
                 choices = defaults.languages.values(),
                 help=&quot;use LANGUAGE native comment style&quot;)
    p.add_option(&quot;--overwrite&quot;, action=&quot;store&quot;,
                 choices = [&quot;yes&quot;, &quot;update&quot;, &quot;no&quot;],
                 help=&quot;overwrite output file (default 'update')&quot;)
    p.add_option(&quot;--replace&quot;, action=&quot;store_true&quot;,
                 help=&quot;move infile to a backup copy (appending '~')&quot;)
    p.add_option(&quot;-s&quot;, &quot;--strip&quot;, action=&quot;store_true&quot;,
                 help=&quot;export by stripping documentation or code&quot;)
    p.add_option(&quot;-t&quot;, &quot;--txt2code&quot;, action=&quot;store_true&quot;,
                 help=&quot;convert text source to code source&quot;)
    self.parser = p
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id51" id="pylitoptions-parse-args" name="pylitoptions-parse-args">5.3.2&nbsp;&nbsp;&nbsp;PylitOptions.parse_args</a></h3>
<p>The <cite>parse_args</cite> method calls the <cite>optparse.OptionParser</cite> on command
line or provided args and returns the result as <cite>PylitOptions.Values</cite>
instance. Defaults can be provided as keyword arguments:</p>
<pre class="literal-block">
def parse_args(self, args=sys.argv[1:], **keyw):
    &quot;&quot;&quot;parse command line arguments using `optparse.OptionParser`

       parse_args(args, **keyw) -&gt; OptionValues instance

        args --  list of command line arguments.
        keyw --  keyword arguments or dictionary of option defaults
    &quot;&quot;&quot;
    # parse arguments
    (values, args) = self.parser.parse_args(args, OptionValues(keyw))
    # Convert FILE and OUTFILE positional args to option values
    # (other positional arguments are ignored)
    try:
        values.infile = args[0]
        values.outfile = args[1]
    except IndexError:
        pass

    return values
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id52" id="pylitoptions-complete-values" name="pylitoptions-complete-values">5.3.3&nbsp;&nbsp;&nbsp;PylitOptions.complete_values</a></h3>
<p>Complete an OptionValues instance <cite>values</cite>.  Use module-level defaults and
context information to set missing option values to sensible defaults (if
possible)</p>
<pre class="literal-block">
def complete_values(self, values):
    &quot;&quot;&quot;complete option values with module and context sensible defaults

    x.complete_values(values) -&gt; values
    values -- OptionValues instance
    &quot;&quot;&quot;
</pre>
<p>Complete with module-level <a class="reference" href="#defaults">defaults</a>:</p>
<pre class="literal-block">
values.complete(**defaults.__dict__)
</pre>
<p>Ensure infile is a string:</p>
<pre class="literal-block">
values.ensure_value(&quot;infile&quot;, &quot;&quot;)
</pre>
<p>Guess conversion direction from <cite>infile</cite> filename:</p>
<pre class="literal-block">
if values.txt2code is None:
    in_extension = os.path.splitext(values.infile)[1]
    if in_extension in values.text_extensions:
        values.txt2code = True
    elif in_extension in values.code_extensions:
        values.txt2code = False
</pre>
<p>Auto-determine the output file name:</p>
<pre class="literal-block">
values.ensure_value(&quot;outfile&quot;, self._get_outfile_name(values))
</pre>
<p>Second try: Guess conversion direction from outfile filename:</p>
<pre class="literal-block">
if values.txt2code is None:
    out_extension = os.path.splitext(values.outfile)[1]
    values.txt2code = not (out_extension in values.text_extensions)
</pre>
<p>Set the language of the code:</p>
<pre class="literal-block">
if values.txt2code is True:
    code_extension = os.path.splitext(values.outfile)[1]
elif values.txt2code is False:
    code_extension = os.path.splitext(values.infile)[1]
values.ensure_value(&quot;language&quot;,
                    values.languages.get(code_extension,
                                         values.fallback_language))

return values
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id53" id="pylitoptions-get-outfile-name" name="pylitoptions-get-outfile-name">5.3.4&nbsp;&nbsp;&nbsp;PylitOptions._get_outfile_name</a></h3>
<p>Construct a matching filename for the output file. The output filename is
constructed from <cite>infile</cite> by the following rules:</p>
<ul class="simple">
<li>'-' (stdin) results in '-' (stdout)</li>
<li>strip the <cite>txt_extension</cite> (txt2code) or</li>
<li>add a <cite>txt_ extension</cite> (code2txt)</li>
<li>fallback: if no guess can be made, add &quot;.out&quot;<!-- TODO: use values.outfile_extension if it exists? -->
</li>
</ul>
<pre class="literal-block">
def _get_outfile_name(self, values):
    &quot;&quot;&quot;Return a matching output filename for `infile`
    &quot;&quot;&quot;
    # if input is stdin, default output is stdout
    if values.infile == '-':
        return '-'

    # Derive from `infile` name: strip or add text extension
    (base, ext) = os.path.splitext(values.infile)
    if ext in values.text_extensions:
        return base # strip
    if ext in values.code_extensions or values.txt2code == False:
        return values.infile + values.text_extensions[0] # add
    # give up
    return values.infile + &quot;.out&quot;
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id54" id="pylitoptions-call" name="pylitoptions-call">5.3.5&nbsp;&nbsp;&nbsp;PylitOptions.__call__</a></h3>
<p>The special <cite>__call__</cite> method allows to use PylitOptions instances as
<em>callables</em>: Calling an instance parses the argument list to extract option
values and completes them based on &quot;context-sensitive defaults&quot;.  Keyword
arguments are passed to <a class="reference" href="#pylitoptions-parse-args">PylitOptions.parse_args</a> as default values.</p>
<pre class="literal-block">
def __call__(self, args=sys.argv[1:], **keyw):
    &quot;&quot;&quot;parse and complete command line args return option values
    &quot;&quot;&quot;
    values = self.parse_args(args, **keyw)
    return self.complete_values(values)
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id55" id="helper-functions" name="helper-functions">5.4&nbsp;&nbsp;&nbsp;Helper functions</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id56" id="open-streams" name="open-streams">5.4.1&nbsp;&nbsp;&nbsp;open_streams</a></h3>
<p>Return file objects for in- and output. If the input path is missing,
write usage and abort. (An alternative would be to use stdin as default.
However,  this leaves the uninitiated user with a non-responding application
if (s)he just tries the script without any arguments)</p>
<pre class="literal-block">
def open_streams(infile = '-', outfile = '-', overwrite='update', **keyw):
    &quot;&quot;&quot;Open and return the input and output stream

    open_streams(infile, outfile) -&gt; (in_stream, out_stream)

    in_stream   --  file(infile) or sys.stdin
    out_stream  --  file(outfile) or sys.stdout
    overwrite   --  'yes': overwrite eventually existing `outfile`,
                    'update': fail if the `outfile` is newer than `infile`,
                    'no': fail if `outfile` exists.

                    Irrelevant if `outfile` == '-'.
    &quot;&quot;&quot;
    if not infile:
        strerror = &quot;Missing input file name ('-' for stdin; -h for help)&quot;
        raise IOError, (2, strerror, infile)
    if infile == '-':
        in_stream = sys.stdin
    else:
        in_stream = file(infile, 'r')
    if outfile == '-':
        out_stream = sys.stdout
    elif overwrite == 'no' and os.path.exists(outfile):
        raise IOError, (1, &quot;Output file exists!&quot;, outfile)
    elif overwrite == 'update' and is_newer(outfile, infile):
        raise IOError, (1, &quot;Output file is newer than input file!&quot;, outfile)
    else:
        out_stream = file(outfile, 'w')
    return (in_stream, out_stream)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id57" id="is-newer" name="is-newer">5.4.2&nbsp;&nbsp;&nbsp;is_newer</a></h3>
<pre class="literal-block">
def is_newer(path1, path2):
    &quot;&quot;&quot;Check if `path1` is newer than `path2` (using mtime)

    Compare modification time of files at path1 and path2.

    Non-existing files are considered oldest: Return False if path1 doesnot
    exist and True if path2 doesnot exist.

    Return None for equal modification time. (This evaluates to False in a
    boolean context but allows a test for equality.)

    &quot;&quot;&quot;
    try:
        mtime1 = os.path.getmtime(path1)
    except OSError:
        mtime1 = -1
    try:
        mtime2 = os.path.getmtime(path2)
    except OSError:
        mtime2 = -1
    # print &quot;mtime1&quot;, mtime1, path1, &quot;\n&quot;, &quot;mtime2&quot;, mtime2, path2

    if mtime1 == mtime2:
        return None
    return mtime1 &gt; mtime2
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id58" id="get-converter" name="get-converter">5.4.3&nbsp;&nbsp;&nbsp;get_converter</a></h3>
<p>Get an instance of the converter state machine:</p>
<pre class="literal-block">
def get_converter(data, txt2code=True, **keyw):
    if txt2code:
        return Text2Code(data, **keyw)
    else:
        return Code2Text(data, **keyw)
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id59" id="use-cases" name="use-cases">5.5&nbsp;&nbsp;&nbsp;Use cases</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id60" id="run-doctest" name="run-doctest">5.5.1&nbsp;&nbsp;&nbsp;run_doctest</a></h3>
<pre class="literal-block">
def run_doctest(infile=&quot;-&quot;, txt2code=True,
                globs={}, verbose=False, optionflags=0, **keyw):
    &quot;&quot;&quot;run doctest on the text source
    &quot;&quot;&quot;
    from doctest import DocTestParser, DocTestRunner
    (data, out_stream) = open_streams(infile, &quot;-&quot;)
</pre>
<p>If source is code, convert to text, as tests in comments are not found by
doctest:</p>
<pre class="literal-block">
if txt2code is False:
    converter = Code2Text(data, **keyw)
    docstring = str(converter)
else:
    docstring = data.read()
</pre>
<p>Use the doctest Advanced API to do all doctests in a given string:</p>
<pre class="literal-block">
test = DocTestParser().get_doctest(docstring, globs={}, name=&quot;&quot;,
                                       filename=infile, lineno=0)
runner = DocTestRunner(verbose=verbose, optionflags=optionflags)
runner.run(test)
runner.summarize
if not runner.failures:
    print &quot;%d failures in %d tests&quot;%(runner.failures, runner.tries)
return runner.failures, runner.tries
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id61" id="diff" name="diff">5.5.2&nbsp;&nbsp;&nbsp;diff</a></h3>
<pre class="literal-block">
def diff(infile='-', outfile='-', txt2code=True, **keyw):
    &quot;&quot;&quot;Report differences between converted infile and existing outfile

    If outfile is '-', do a round-trip conversion and report differences
    &quot;&quot;&quot;

    import difflib

    instream = file(infile)
    # for diffing, we need a copy of the data as list::
    data = instream.readlines()
    # convert
    converter = get_converter(data, txt2code, **keyw)
    new = str(converter).splitlines(True)

    if outfile != '-':
        outstream = file(outfile)
        old = outstream.readlines()
        oldname = outfile
        newname = &quot;&lt;conversion of %s&gt;&quot;%infile
    else:
        old = data
        oldname = infile
        # back-convert the output data
        converter = get_converter(new, not txt2code)
        new = str(converter).splitlines(True)
        newname = &quot;&lt;round-conversion of %s&gt;&quot;%infile

    # find and print the differences
    delta = list(difflib.unified_diff(old, new,
                                      fromfile=oldname, tofile=newname))
    if delta:
        print &quot;&quot;.join(delta)
    else:
        print oldname
        print newname
        print &quot;no differences found&quot;
    return bool(delta)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id62" id="execute" name="execute">5.5.3&nbsp;&nbsp;&nbsp;execute</a></h3>
<p>Works only for python code.</p>
<p>Doesnot work with <cite>eval</cite>, as code is not just one expression.</p>
<pre class="literal-block">
def execute(infile=&quot;-&quot;, txt2code=True, **keyw):
    &quot;&quot;&quot;Execute the input file. Convert first, if it is a text source.
    &quot;&quot;&quot;

    data = file(infile)
    if txt2code:
        data = str(Text2Code(data, **keyw))
    # print &quot;executing &quot; + options.infile
    exec data
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id63" id="main" name="main">5.6&nbsp;&nbsp;&nbsp;main</a></h2>
<p>If this script is called from the command line, the <cite>main</cite> function will
convert the input (file or stdin) between text and code formats.</p>
<p>Option default values for the conversion can be given as keyword arguments
to <a class="reference" href="#main">main</a>.  The option defaults will be updated by command line options and
extended with &quot;intelligent guesses&quot; by <a class="reference" href="#pylitoptions">PylitOptions</a> and passed on to
helper functions and the converter instantiation.</p>
<p>This allows easy customization for programmatic use -- just call <cite>main</cite>
with the appropriate keyword options, e.g.:</p>
<pre class="doctest-block">
&gt;&gt;&gt; main(comment_string=&quot;## &quot;)
</pre>
<pre class="literal-block">
def main(args=sys.argv[1:], **defaults):
    &quot;&quot;&quot;%prog [options] INFILE [OUTFILE]

    Convert between (reStructured) text source with embedded code,
    and code source with embedded documentation (comment blocks)

    The special filename '-' stands for standard in and output.
    &quot;&quot;&quot;
</pre>
<p>Parse and complete the options:</p>
<pre class="literal-block">
options = PylitOptions()(args, **defaults)
# print &quot;infile&quot;, repr(options.infile)
</pre>
<p>Special actions with early return:</p>
<pre class="literal-block">
if options.doctest:
    return run_doctest(**options.as_dict())

if options.diff:
    return diff(**options.as_dict())

if options.execute:
    return execute(**options.as_dict())
</pre>
<p>Open in- and output streams:</p>
<pre class="literal-block">
try:
    (data, out_stream) = open_streams(**options.as_dict())
except IOError, ex:
    print &quot;IOError: %s %s&quot; % (ex.filename, ex.strerror)
    sys.exit(ex.errno)
</pre>
<p>Get a converter instance:</p>
<pre class="literal-block">
converter = get_converter(data, **options.as_dict())
</pre>
<p>Convert and write to out_stream:</p>
<pre class="literal-block">
out_stream.write(str(converter))

if out_stream is not sys.stdout:
    print &quot;extract written to&quot;, out_stream.name
    out_stream.close()
</pre>
<p>If input and output are from files, set the modification time (<cite>mtime</cite>) of
the output file to the one of the input file to indicate that the contained
information is equal. <a class="footnote-reference" href="#id10" id="id9" name="id9">[5]</a></p>
<pre class="literal-block">
    try:
        os.utime(options.outfile, (os.path.getatime(options.outfile),
                                   os.path.getmtime(options.infile))
                )
    except OSError:
        pass

## print &quot;mtime&quot;, os.path.getmtime(options.infile),  options.infile
## print &quot;mtime&quot;, os.path.getmtime(options.outfile), options.outfile
</pre>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9" name="id10">[5]</a></td><td>Make sure the corresponding file object (here <cite>out_stream</cite>) is
closed, as otherwise the change will be overwritten when <cite>close</cite> is
called afterwards (either explicitely or at program exit).</td></tr>
</tbody>
</table>
<p>Rename the infile to a backup copy if <tt class="docutils literal"><span class="pre">--replace</span></tt> is set:</p>
<pre class="literal-block">
if options.replace:
    os.rename(options.infile, options.infile + &quot;~&quot;)
</pre>
<p>Run main, if called from the command line:</p>
<pre class="literal-block">
if __name__ == '__main__':
    main()
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id64" id="open-questions" name="open-questions">6&nbsp;&nbsp;&nbsp;Open questions</a></h1>
<p>Open questions and ideas for further development</p>
<div class="section">
<h2><a class="toc-backref" href="#id65" id="clean-code" name="clean-code">6.1&nbsp;&nbsp;&nbsp;Clean code</a></h2>
<ul class="simple">
<li>can we gain from using &quot;shutils&quot; over &quot;os.path&quot; and &quot;os&quot;?</li>
<li>use pylint or pyChecker to enfoce a consistent style?</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id66" id="options" name="options">6.2&nbsp;&nbsp;&nbsp;Options</a></h2>
<ul class="simple">
<li>Use templates for the &quot;intelligent guesses&quot; (with Python syntax for string
replacement with dicts: <tt class="docutils literal"><span class="pre">&quot;hello</span> <span class="pre">%(what)s&quot;</span> <span class="pre">%</span> <span class="pre">{'what':</span> <span class="pre">'world'}</span></tt>)</li>
<li>Is it sensible to offer the <cite>header_string</cite> option also as command line
option?</li>
<li>Configurable</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id67" id="parsing-problems" name="parsing-problems">6.3&nbsp;&nbsp;&nbsp;Parsing Problems</a></h2>
<ul>
<li><p class="first">How can I include a literal block that should not be in the
executable code (e.g. an example, an earlier version or variant)?</p>
<p>Workarounds:</p>
<ul>
<li><p class="first">Use a <a class="reference" href="http://docutils.sf.net/docs/ref/rst/directives.html#parsed-literal-block">parsed-literal block</a> directive if there is no &quot;accidential&quot;
markup in the literal code</p>
</li>
<li><p class="first">Use a <a class="reference" href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#line-block">line block</a> directive or the <a class="reference" href="http://docutils.sf.net/docs/ref/rst/restructuredtext.html#line-blocks">line block syntax</a>
and mark all lines as <a class="reference" href="http://docutils.sf.net/docs/ref/rst/restructuredtext.html#inline-literals">inline literals</a>.</p>
</li>
<li><p class="first">Python session examples and doctests can use <a class="reference" href="http://docutils.sf.net/docs/ref/rst/restructuredtext.html#doctest-blocks">doctest block</a> syntax</p>
<p>No double colon! Start first line of block with <tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt>.</p>
</li>
</ul>
<p>Not implemented yet:</p>
<ul class="simple">
<li>use a dedicated <a class="reference" href="#code-block-directive">code-block directive</a> or a distinct directive for
ordinary literal blocks.</li>
</ul>
</li>
<li><p class="first">Ignore &quot;matching comments&quot; in literal strings?</p>
<p>Too complicated: Would need a specific detection algorithm for every
language that supports multi-line literal strings (C++, PHP, Python)</p>
</li>
<li><p class="first">Warn if a comment in code will become documentation after round-trip?</p>
</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id68" id="code-block-directive" name="code-block-directive">6.4&nbsp;&nbsp;&nbsp;code-block directive</a></h2>
<p>In a document where code examples are only one of several uses of literal
blocks, it would be more appropriate to single out the sourcecode with a
dedicated &quot;code-block&quot; directive.</p>
<p>Some highlight plug-ins require a special &quot;sourcecode&quot; or &quot;code-block&quot;
directive instead of the <tt class="docutils literal"><span class="pre">::</span></tt> literal block marker. Actually,
syntax-highlight is possible without changes to docutils with the <a class="reference" href="http://pygments.org/">Pygments</a>
package using a &quot;code-block&quot; directive. See the <a class="reference" href="../features/syntax-highlight.html">syntax highlight</a> section
in the features documentation.</p>
<p>TODO:</p>
<ul class="simple">
<li>provide a &quot;code-block-marker&quot; string option.</li>
<li>correctly handle the case of <tt class="docutils literal"><span class="pre">code_block_marker</span> <span class="pre">==</span> <span class="pre">'::'</span></tt> and conversion
of <tt class="docutils literal"><span class="pre">::</span></tt> to a different &quot;code_block_marker&quot; -- consider minimized forms.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id69" id="doctstrings-in-code-blocks" name="doctstrings-in-code-blocks">6.5&nbsp;&nbsp;&nbsp;doctstrings in code blocks</a></h2>
<ul class="simple">
<li>How to handle docstrings in code blocks? (it would be nice to convert them
to rst-text if <tt class="docutils literal"><span class="pre">__docformat__</span> <span class="pre">==</span> <span class="pre">restructuredtext</span></tt>)</li>
</ul>
<p>TODO: Ask at docutils users|developers</p>
<!-- References -->
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="pylit.py.txt">View document source</a>.
Generated on: 2007-05-18.

</div>
</body>
</html>
