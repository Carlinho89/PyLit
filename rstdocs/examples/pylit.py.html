<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title>pylit.py: Literate programming with reStructuredText</title>
<meta name="date" content="2007-05-30" />
<meta name="copyright" content="2005, 2007 Guenter Milde. Released under the terms of the GNU General Public License (v. 2 or later)" />
<link rel="stylesheet" href="/usr/lib/python2.4/site-packages/docutils/writers/html4css1/html4css1.css" type="text/css" />
</head>
<body>
<div class="document" id="pylit-py-literate-programming-with-restructuredtext">
<h1 class="title">pylit.py: Literate programming with reStructuredText</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Date:</th>
<td>2007-05-30</td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>SVN-Revision 50</td></tr>
<tr class="field"><th class="docinfo-name">URL:</th><td class="field-body">svn+ssh://svn.berlios.de/svnroot/repos/pylit/trunk/src/pylit.py</td>
</tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>2005, 2007 Guenter Milde.
Released under the terms of the GNU General Public License
(v. 2 or later)</td></tr>
</tbody>
</table>
<!-- #!/usr/bin/env python
# -*- coding: iso-8859-1 -*- -->
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#frontmatter" id="id9" name="id9">1&nbsp;&nbsp;&nbsp;Frontmatter</a><ul class="auto-toc">
<li><a class="reference" href="#changelog" id="id10" name="id10">1.1&nbsp;&nbsp;&nbsp;Changelog</a></li>
<li><a class="reference" href="#introduction" id="id11" name="id11">1.2&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#requirements" id="id12" name="id12">1.3&nbsp;&nbsp;&nbsp;Requirements</a></li>
</ul>
</li>
<li><a class="reference" href="#customisation" id="id13" name="id13">2&nbsp;&nbsp;&nbsp;Customisation</a><ul class="auto-toc">
<li><a class="reference" href="#defaults" id="id14" name="id14">2.1&nbsp;&nbsp;&nbsp;defaults</a><ul class="auto-toc">
<li><a class="reference" href="#defaults-languages" id="id15" name="id15">2.1.1&nbsp;&nbsp;&nbsp;defaults.languages</a></li>
<li><a class="reference" href="#defaults-fallback-language" id="id16" name="id16">2.1.2&nbsp;&nbsp;&nbsp;defaults.fallback_language</a></li>
<li><a class="reference" href="#defaults-text-extensions" id="id17" name="id17">2.1.3&nbsp;&nbsp;&nbsp;defaults.text_extensions</a></li>
<li><a class="reference" href="#defaults-comment-strings" id="id18" name="id18">2.1.4&nbsp;&nbsp;&nbsp;defaults.comment_strings</a></li>
<li><a class="reference" href="#defaults-header-string" id="id19" name="id19">2.1.5&nbsp;&nbsp;&nbsp;defaults.header_string</a></li>
<li><a class="reference" href="#defaults-strip" id="id20" name="id20">2.1.6&nbsp;&nbsp;&nbsp;defaults.strip</a></li>
<li><a class="reference" href="#defaults-preprocessors" id="id21" name="id21">2.1.7&nbsp;&nbsp;&nbsp;defaults.preprocessors</a></li>
<li><a class="reference" href="#defaults-postprocessors" id="id22" name="id22">2.1.8&nbsp;&nbsp;&nbsp;defaults.postprocessors</a></li>
<li><a class="reference" href="#defaults-codeindent" id="id23" name="id23">2.1.9&nbsp;&nbsp;&nbsp;defaults.codeindent</a></li>
<li><a class="reference" href="#defaults-overwrite" id="id24" name="id24">2.1.10&nbsp;&nbsp;&nbsp;defaults.overwrite</a></li>
</ul>
</li>
<li><a class="reference" href="#extensions" id="id25" name="id25">2.2&nbsp;&nbsp;&nbsp;Extensions</a></li>
</ul>
</li>
<li><a class="reference" href="#converter-classes" id="id26" name="id26">3&nbsp;&nbsp;&nbsp;Converter Classes</a><ul class="auto-toc">
<li><a class="reference" href="#textcodeconverter" id="id27" name="id27">3.1&nbsp;&nbsp;&nbsp;TextCodeConverter</a><ul class="auto-toc">
<li><a class="reference" href="#data-attributes" id="id28" name="id28">3.1.1&nbsp;&nbsp;&nbsp;Data attributes</a></li>
<li><a class="reference" href="#interface-methods" id="id29" name="id29">3.1.2&nbsp;&nbsp;&nbsp;Interface methods</a><ul class="auto-toc">
<li><a class="reference" href="#textcodeconverter-init" id="id30" name="id30">3.1.2.1&nbsp;&nbsp;&nbsp;TextCodeConverter.__init__</a></li>
<li><a class="reference" href="#textcodeconverter-iter" id="id31" name="id31">3.1.2.2&nbsp;&nbsp;&nbsp;TextCodeConverter.__iter__</a></li>
<li><a class="reference" href="#textcodeconverter-call" id="id32" name="id32">3.1.2.3&nbsp;&nbsp;&nbsp;TextCodeConverter.__call__</a></li>
<li><a class="reference" href="#textcodeconverter-str" id="id33" name="id33">3.1.2.4&nbsp;&nbsp;&nbsp;TextCodeConverter.__str__</a></li>
</ul>
</li>
<li><a class="reference" href="#helpers-and-convenience-methods" id="id34" name="id34">3.1.3&nbsp;&nbsp;&nbsp;Helpers and convenience methods</a><ul class="auto-toc">
<li><a class="reference" href="#textcodeconverter-convert" id="id35" name="id35">3.1.3.1&nbsp;&nbsp;&nbsp;TextCodeConverter.convert</a></li>
<li><a class="reference" href="#textcodeconverter-get-filter" id="id36" name="id36">3.1.3.2&nbsp;&nbsp;&nbsp;TextCodeConverter.get_filter</a></li>
<li><a class="reference" href="#textcodeconverter-get-indent" id="id37" name="id37">3.1.3.3&nbsp;&nbsp;&nbsp;TextCodeConverter.get_indent</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#text2code" id="id38" name="id38">3.2&nbsp;&nbsp;&nbsp;Text2Code</a><ul class="auto-toc">
<li><a class="reference" href="#text2code-set-state" id="id39" name="id39">3.2.1&nbsp;&nbsp;&nbsp;Text2Code.set_state</a></li>
<li><a class="reference" href="#text2code-header-handler" id="id40" name="id40">3.2.2&nbsp;&nbsp;&nbsp;Text2Code.header_handler</a></li>
<li><a class="reference" href="#text2code-documentation-handler" id="id41" name="id41">3.2.3&nbsp;&nbsp;&nbsp;Text2Code.documentation_handler</a></li>
<li><a class="reference" href="#text2code-code-block-handler" id="id42" name="id42">3.2.4&nbsp;&nbsp;&nbsp;Text2Code.code_block_handler</a></li>
</ul>
</li>
<li><a class="reference" href="#code2text" id="id43" name="id43">3.3&nbsp;&nbsp;&nbsp;Code2Text</a><ul class="auto-toc">
<li><a class="reference" href="#code2text-set-state" id="id44" name="id44">3.3.1&nbsp;&nbsp;&nbsp;Code2Text.set_state</a></li>
<li><a class="reference" href="#code2text-header-handler" id="id45" name="id45">3.3.2&nbsp;&nbsp;&nbsp;Code2Text.header_handler</a></li>
<li><a class="reference" href="#code2text-documentation-handler" id="id46" name="id46">3.3.3&nbsp;&nbsp;&nbsp;Code2Text.documentation_handler</a></li>
<li><a class="reference" href="#code2text-code-block-handler" id="id47" name="id47">3.3.4&nbsp;&nbsp;&nbsp;Code2Text.code_block_handler</a></li>
<li><a class="reference" href="#code2text-strip-literal-marker" id="id48" name="id48">3.3.5&nbsp;&nbsp;&nbsp;Code2Text.strip_literal_marker</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#filters" id="id49" name="id49">4&nbsp;&nbsp;&nbsp;Filters</a><ul class="auto-toc">
<li><a class="reference" href="#identity-filter" id="id50" name="id50">4.1&nbsp;&nbsp;&nbsp;identity_filter</a></li>
<li><a class="reference" href="#expandtabs-filter" id="id51" name="id51">4.2&nbsp;&nbsp;&nbsp;expandtabs_filter</a></li>
<li><a class="reference" href="#collect-blocks" id="id52" name="id52">4.3&nbsp;&nbsp;&nbsp;collect_blocks</a></li>
<li><a class="reference" href="#dumb-c-preprocessor" id="id53" name="id53">4.4&nbsp;&nbsp;&nbsp;dumb_c_preprocessor</a></li>
<li><a class="reference" href="#dumb-c-postprocessor" id="id54" name="id54">4.5&nbsp;&nbsp;&nbsp;dumb_c_postprocessor</a></li>
<li><a class="reference" href="#register-filters" id="id55" name="id55">4.6&nbsp;&nbsp;&nbsp;register filters</a></li>
</ul>
</li>
<li><a class="reference" href="#command-line-use" id="id56" name="id56">5&nbsp;&nbsp;&nbsp;Command line use</a><ul class="auto-toc">
<li><a class="reference" href="#dual-source-handling" id="id57" name="id57">5.1&nbsp;&nbsp;&nbsp;Dual source handling</a><ul class="auto-toc">
<li><a class="reference" href="#how-to-determine-which-source-is-up-to-date" id="id58" name="id58">5.1.1&nbsp;&nbsp;&nbsp;How to determine which source is up-to-date?</a></li>
<li><a class="reference" href="#recognised-filename-extensions" id="id59" name="id59">5.1.2&nbsp;&nbsp;&nbsp;Recognised Filename Extensions</a></li>
</ul>
</li>
<li><a class="reference" href="#optionvalues" id="id60" name="id60">5.2&nbsp;&nbsp;&nbsp;OptionValues</a><ul class="auto-toc">
<li><a class="reference" href="#optionvalues-as-dict" id="id61" name="id61">5.2.1&nbsp;&nbsp;&nbsp;OptionValues.as_dict</a></li>
<li><a class="reference" href="#optionvalues-complete" id="id62" name="id62">5.2.2&nbsp;&nbsp;&nbsp;OptionValues.complete</a></li>
<li><a class="reference" href="#optionvalues-getattr" id="id63" name="id63">5.2.3&nbsp;&nbsp;&nbsp;OptionValues.__getattr__</a></li>
</ul>
</li>
<li><a class="reference" href="#pylitoptions" id="id64" name="id64">5.3&nbsp;&nbsp;&nbsp;PylitOptions</a><ul class="auto-toc">
<li><a class="reference" href="#instantiation" id="id65" name="id65">5.3.1&nbsp;&nbsp;&nbsp;Instantiation</a></li>
<li><a class="reference" href="#pylitoptions-parse-args" id="id66" name="id66">5.3.2&nbsp;&nbsp;&nbsp;PylitOptions.parse_args</a></li>
<li><a class="reference" href="#pylitoptions-complete-values" id="id67" name="id67">5.3.3&nbsp;&nbsp;&nbsp;PylitOptions.complete_values</a></li>
<li><a class="reference" href="#pylitoptions-get-outfile-name" id="id68" name="id68">5.3.4&nbsp;&nbsp;&nbsp;PylitOptions._get_outfile_name</a></li>
<li><a class="reference" href="#pylitoptions-call" id="id69" name="id69">5.3.5&nbsp;&nbsp;&nbsp;PylitOptions.__call__</a></li>
</ul>
</li>
<li><a class="reference" href="#helper-functions" id="id70" name="id70">5.4&nbsp;&nbsp;&nbsp;Helper functions</a><ul class="auto-toc">
<li><a class="reference" href="#open-streams" id="id71" name="id71">5.4.1&nbsp;&nbsp;&nbsp;open_streams</a></li>
<li><a class="reference" href="#is-newer" id="id72" name="id72">5.4.2&nbsp;&nbsp;&nbsp;is_newer</a></li>
<li><a class="reference" href="#get-converter" id="id73" name="id73">5.4.3&nbsp;&nbsp;&nbsp;get_converter</a></li>
</ul>
</li>
<li><a class="reference" href="#use-cases" id="id74" name="id74">5.5&nbsp;&nbsp;&nbsp;Use cases</a><ul class="auto-toc">
<li><a class="reference" href="#run-doctest" id="id75" name="id75">5.5.1&nbsp;&nbsp;&nbsp;run_doctest</a></li>
<li><a class="reference" href="#diff" id="id76" name="id76">5.5.2&nbsp;&nbsp;&nbsp;diff</a></li>
<li><a class="reference" href="#execute" id="id77" name="id77">5.5.3&nbsp;&nbsp;&nbsp;execute</a></li>
</ul>
</li>
<li><a class="reference" href="#main" id="id78" name="id78">5.6&nbsp;&nbsp;&nbsp;main</a></li>
</ul>
</li>
<li><a class="reference" href="#open-questions" id="id79" name="id79">6&nbsp;&nbsp;&nbsp;Open questions</a><ul class="auto-toc">
<li><a class="reference" href="#clean-code" id="id80" name="id80">6.1&nbsp;&nbsp;&nbsp;Clean code</a></li>
<li><a class="reference" href="#options" id="id81" name="id81">6.2&nbsp;&nbsp;&nbsp;Options</a></li>
<li><a class="reference" href="#parsing-problems" id="id82" name="id82">6.3&nbsp;&nbsp;&nbsp;Parsing Problems</a></li>
<li><a class="reference" href="#code-block-directive" id="id83" name="id83">6.4&nbsp;&nbsp;&nbsp;code-block directive</a></li>
<li><a class="reference" href="#doctstrings-in-code-blocks" id="id84" name="id84">6.5&nbsp;&nbsp;&nbsp;doctstrings in code blocks</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id9" id="frontmatter" name="frontmatter">1&nbsp;&nbsp;&nbsp;Frontmatter</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id10" id="changelog" name="changelog">1.1&nbsp;&nbsp;&nbsp;Changelog</a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">2005-06-29:</th><td class="field-body">Initial version.</td>
</tr>
<tr class="field"><th class="field-name">2005-06-30:</th><td class="field-body">First literate version.</td>
</tr>
<tr class="field"><th class="field-name">2005-07-01:</th><td class="field-body">Object orientated script using generators.</td>
</tr>
<tr class="field"><th class="field-name">2005-07-10:</th><td class="field-body">Two state machine (later added 'header' state).</td>
</tr>
<tr class="field"><th class="field-name">2006-12-04:</th><td class="field-body">Start of work on version 0.2 (code restructuring).</td>
</tr>
<tr class="field"><th class="field-name">2007-01-23:</th><td class="field-body">0.2   Published at <a class="reference" href="http://pylit.berlios.de">http://pylit.berlios.de</a>.</td>
</tr>
<tr class="field"><th class="field-name">2007-01-25:</th><td class="field-body">0.2.1 Outsourced non-core documentation to the PyLit pages.</td>
</tr>
<tr class="field"><th class="field-name">2007-01-26:</th><td class="field-body">0.2.2 New behaviour of <cite>diff</cite> function.</td>
</tr>
<tr class="field"><th class="field-name">2007-01-29:</th><td class="field-body">0.2.3 New <cite>header</cite> methods after suggestion by Riccardo Murri.</td>
</tr>
<tr class="field"><th class="field-name">2007-01-31:</th><td class="field-body">0.2.4 Raise Error if code indent is too small.</td>
</tr>
<tr class="field"><th class="field-name">2007-02-05:</th><td class="field-body">0.2.5 New command line option --comment-string.</td>
</tr>
<tr class="field"><th class="field-name">2007-02-09:</th><td class="field-body">0.2.6 Add section with open questions,
Code2Text: let only blank lines (no comment str)
separate text and code,
fix <cite>Code2Text.header</cite>.</td>
</tr>
<tr class="field"><th class="field-name">2007-02-19:</th><td class="field-body">0.2.7 Simplify <cite>Code2Text.header</cite>,
new <cite>iter_strip</cite> method replacing a lot of <tt class="docutils literal"><span class="pre">if</span></tt>-s.</td>
</tr>
<tr class="field"><th class="field-name">2007-02-22:</th><td class="field-body">0.2.8 Set <cite>mtime</cite> of outfile to the one of infile.</td>
</tr>
<tr class="field"><th class="field-name">2007-02-27:</th><td class="field-body">0.3   New <cite>Code2Text</cite> converter after an idea by Riccardo Murri,
explicite <cite>option_defaults</cite> dict for easier customization.</td>
</tr>
<tr class="field"><th class="field-name">2007-03-02:</th><td class="field-body">0.3.1 Expand hard-tabs to prevent errors in indentation,
<cite>Text2Code</cite> now also works on blocks,
removed dependency on SimpleStates module.</td>
</tr>
<tr class="field"><th class="field-name">2007-03-06:</th><td class="field-body">0.3.2 Bugfix: do not set <cite>language</cite> in <cite>option_defaults</cite>
renamed <cite>code_languages</cite> to <cite>languages</cite>.</td>
</tr>
<tr class="field"><th class="field-name">2007-03-16:</th><td class="field-body">0.3.3 New language css,
option_defaults -&gt; defaults = optparse.Values(),
simpler PylitOptions: don't store parsed values,
don't parse at initialization,
OptionValues: return <cite>None</cite> for non-existing attributes,
removed -infile and -outfile, use positional arguments.</td>
</tr>
<tr class="field"><th class="field-name">2007-03-19:</th><td class="field-body">0.3.4 Documentation update,
separate <cite>execute</cite> function.</td>
</tr>
<tr class="field"><th class="field-name">2007-03-21:</th><td class="field-body">Code cleanup in <cite>Text2Code.__iter__</cite>.</td>
</tr>
<tr class="field"><th class="field-name">2007-03-23:</th><td class="field-body">0.3.5 Removed &quot;css&quot; from known languages after learning that
there is no C++ style &quot;// &quot; comment string in css2.</td>
</tr>
<tr class="field"><th class="field-name">2007-04-24:</th><td class="field-body">0.3.6 Documentation update.</td>
</tr>
<tr class="field"><th class="field-name">2007-05-18:</th><td class="field-body">0.4   Implement Converter.__iter__ as stack of iterator
generators. Iterating over a converter instance now
yields lines instead of blocks.
Provide &quot;hooks&quot; for pre- and postprocessing filters.
Rename states to avoid confusion with formats:
&quot;text&quot; -&gt; &quot;documentation&quot;, &quot;code&quot; -&gt; &quot;code_block&quot;.</td>
</tr>
<tr class="field"><th class="field-name">2007-05-22:</th><td class="field-body">0.4.1 Converter.__iter__: cleanup and reorganization,
rename Converter -&gt; TextCodeConverter.</td>
</tr>
<tr class="field"><th class="field-name">2007-05-23:</th><td class="field-body">0.4.2 Merged Text2Code.converter and Code2Text.converter into
TextCodeConverter.converter.</td>
</tr>
<tr class="field"><th class="field-name">2007-05-30:</th><td class="field-body">0.4.3 Replaced use of defaults.code_extensions with
values.languages.keys().
Removed spurious <cite>print</cite> statement in code_block_handler.
Added basic support for 'c' and 'css' languages
with <a class="reference" href="#dumb-c-preprocessor">dumb_c_preprocessor</a> and <a class="reference" href="#dumb-c-postprocessor">dumb_c_postprocessor</a>.</td>
</tr>
<tr class="field"><th class="field-name">2007-06-06:</th><td class="field-body">0.5   Moved <a class="reference" href="#collect-blocks">collect_blocks</a> out of <a class="reference" href="#textcodeconverter">TextCodeConverter</a>,
bugfix: collect all trailing blank lines into a block.
Expand tabs with <a class="reference" href="#expandtabs-filter">expandtabs_filter</a>.</td>
</tr>
</tbody>
</table>
<pre class="literal-block">
&quot;&quot;&quot;pylit: bidirectional converter between a *text source* with embedded
computer code and a *code source* with embedded documentation.
&quot;&quot;&quot;

__docformat__ = 'restructuredtext'

_version = &quot;0.5&quot;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id11" id="introduction" name="introduction">1.2&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>PyLit is a bidirectional converter between two formats of a computer
program source:</p>
<ul class="simple">
<li>a (reStructured) text document with program code embedded in
<em>code blocks</em>, and</li>
<li>a compilable (or executable) code source with <em>documentation</em> embedded in
comment blocks</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id12" id="requirements" name="requirements">1.3&nbsp;&nbsp;&nbsp;Requirements</a></h2>
<pre class="literal-block">
import re
import os
import sys
import optparse
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id13" id="customisation" name="customisation">2&nbsp;&nbsp;&nbsp;Customisation</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id14" id="defaults" name="defaults">2.1&nbsp;&nbsp;&nbsp;defaults</a></h2>
<p>The <cite>defaults</cite> object provides a central repository for default values
and their customisation.</p>
<pre class="literal-block">
defaults = optparse.Values()
</pre>
<p>It is used for</p>
<ul class="simple">
<li>the initialization of data arguments in <a class="reference" href="#textcodeconverter">TextCodeConverter</a> and
<a class="reference" href="#pylitoptions">PylitOptions</a></li>
<li>completion of command line options in <a class="reference" href="#pylitoptions-complete-values">PylitOptions.complete_values</a>.</li>
</ul>
<p>This allows the easy creation of custom back-ends that customise the
defaults and then call <a class="reference" href="#main">main</a> e.g.:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import pylit
&gt;&gt;&gt; defaults.comment_string = &quot;## &quot;
&gt;&gt;&gt; defaults.codeindent = 4
&gt;&gt;&gt; main()
</pre>
</blockquote>
<p>The following default values are defined in pylit.py:</p>
<div class="section">
<h3><a class="toc-backref" href="#id15" id="defaults-languages" name="defaults-languages">2.1.1&nbsp;&nbsp;&nbsp;defaults.languages</a></h3>
<p>Mapping of code file extension to code language.
Used by <a class="reference" href="#optionvalues-complete">OptionValues.complete</a> to set the <cite>defaults.language</cite>.
The <tt class="docutils literal"><span class="pre">--language</span></tt> command line option or setting <tt class="docutils literal"><span class="pre">defaults.language</span></tt> in
programmatic use override this auto-setting feature.</p>
<pre class="literal-block">
defaults.languages  = {&quot;.py&quot;: &quot;python&quot;,
                       &quot;.sl&quot;: &quot;slang&quot;,
                       &quot;.css&quot;: &quot;css&quot;,
                       &quot;.c&quot;: &quot;c&quot;,
                       &quot;.cc&quot;: &quot;c++&quot;}
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id16" id="defaults-fallback-language" name="defaults-fallback-language">2.1.2&nbsp;&nbsp;&nbsp;defaults.fallback_language</a></h3>
<p>Language to use, if there is no matching extension (e.g. if pylit is used as
filter) and no <cite>language</cite> is specified:</p>
<pre class="literal-block">
defaults.fallback_language = &quot;python&quot;
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id17" id="defaults-text-extensions" name="defaults-text-extensions">2.1.3&nbsp;&nbsp;&nbsp;defaults.text_extensions</a></h3>
<p>List of known extensions of (reStructured) text files.
Used by <cite>OptionValues._get_outfile</cite> to auto-determine the output filename.</p>
<pre class="literal-block">
defaults.text_extensions = [&quot;.txt&quot;]
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id18" id="defaults-comment-strings" name="defaults-comment-strings">2.1.4&nbsp;&nbsp;&nbsp;defaults.comment_strings</a></h3>
<p>Dictionary of comment strings for known languages. Comment strings include
trailing whitespace.</p>
<pre class="literal-block">
defaults.comment_strings = {&quot;python&quot;: '# ',
                            &quot;slang&quot;:  '% ',
                            &quot;css&quot;:    '// ',
                            &quot;c&quot;:      '// ',
                            &quot;c++&quot;:    '// '}
</pre>
<p>Used in <a class="reference" href="#code2text">Code2Text</a> to recognise text blocks and in <a class="reference" href="#text2code">Text2Code</a> to format
text blocks as comments.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id19" id="defaults-header-string" name="defaults-header-string">2.1.5&nbsp;&nbsp;&nbsp;defaults.header_string</a></h3>
<p>Marker string for a header code block in the text source. No trailing
whitespace needed as indented code follows. Default is a comment marker:</p>
<pre class="literal-block">
defaults.header_string = '..'
</pre>
<p>Must be a valid rst directive that accepts code on the same line, e.g.
<tt class="docutils literal"><span class="pre">'..admonition::'</span></tt>.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id20" id="defaults-strip" name="defaults-strip">2.1.6&nbsp;&nbsp;&nbsp;defaults.strip</a></h3>
<p>Export to the output format stripping documentation or code blocks:</p>
<pre class="literal-block">
defaults.strip = False
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id21" id="defaults-preprocessors" name="defaults-preprocessors">2.1.7&nbsp;&nbsp;&nbsp;defaults.preprocessors</a></h3>
<p>Preprocess the data with language-specific <a class="reference" href="#filters">filters</a>
Set below in <a class="reference" href="#filters">Filters</a>:</p>
<pre class="literal-block">
defaults.preprocessors = {}
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id22" id="defaults-postprocessors" name="defaults-postprocessors">2.1.8&nbsp;&nbsp;&nbsp;defaults.postprocessors</a></h3>
<p>Postprocess the data with language-specific <a class="reference" href="#filters">filters</a>:</p>
<pre class="literal-block">
defaults.postprocessors = {}
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id23" id="defaults-codeindent" name="defaults-codeindent">2.1.9&nbsp;&nbsp;&nbsp;defaults.codeindent</a></h3>
<p>Number of spaces to indent code blocks in <a class="reference" href="#code2text-code-block-handler">Code2Text.code_block_handler</a>:</p>
<pre class="literal-block">
defaults.codeindent =  2
</pre>
<p>In <a class="reference" href="#text2code-code-block-handler">Text2Code.code_block_handler</a>, the codeindent is determined by the
first recognized code line (header or first indented literal block
of the text source).</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id24" id="defaults-overwrite" name="defaults-overwrite">2.1.10&nbsp;&nbsp;&nbsp;defaults.overwrite</a></h3>
<p>What to do if the outfile already exists? (ignored if <cite>outfile</cite> == '-'):</p>
<pre class="literal-block">
defaults.overwrite = 'update'
</pre>
<p>Recognized values:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">'yes':</th><td class="field-body">overwrite eventually existing <cite>outfile</cite>,</td>
</tr>
<tr class="field"><th class="field-name">'update':</th><td class="field-body">fail if the <cite>outfile</cite> is newer than <cite>infile</cite>,</td>
</tr>
<tr class="field"><th class="field-name">'no':</th><td class="field-body">fail if <cite>outfile</cite> exists.</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id25" id="extensions" name="extensions">2.2&nbsp;&nbsp;&nbsp;Extensions</a></h2>
<p>Try to import optional extensions:</p>
<pre class="literal-block">
try:
    import pylit_elisp
except ImportError:
    pass
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id26" id="converter-classes" name="converter-classes">3&nbsp;&nbsp;&nbsp;Converter Classes</a></h1>
<p>The converter classes implement a simple state machine to separate and
transform documentation and code blocks. For this task, only a very limited
parsing is needed. PyLit's parser assumes:</p>
<ul class="simple">
<li><a class="reference" href="http://docutils.sf.net/docs/ref/rst/restructuredtext.html#indented-literal-blocks">indented literal blocks</a> in a text source are code blocks.</li>
<li>comment blocks in a code source where every line starts with a matching
comment string are documentation blocks.</li>
</ul>
<div class="section">
<h2><a class="toc-backref" href="#id27" id="textcodeconverter" name="textcodeconverter">3.1&nbsp;&nbsp;&nbsp;TextCodeConverter</a></h2>
<pre class="literal-block">
class TextCodeConverter(object):
    &quot;&quot;&quot;Parent class for the converters `Text2Code` and `Code2Text`.
    &quot;&quot;&quot;
</pre>
<p>The parent class defines data attributes and functions used in both
<a class="reference" href="#text2code">Text2Code</a> converting a text source to executable code source, and
<a class="reference" href="#code2text">Code2Text</a> converting commented code to a text source.</p>
<div class="section">
<h3><a class="toc-backref" href="#id28" id="data-attributes" name="data-attributes">3.1.1&nbsp;&nbsp;&nbsp;Data attributes</a></h3>
<p>Class default values are fetched from the <a class="reference" href="#defaults">defaults</a> object and can be
overridden by matching keyword arguments during class instantiation. This
also works with keyword arguments to <a class="reference" href="#get-converter">get_converter</a> and <a class="reference" href="#main">main</a>, as these
functions pass on unused keyword args to the instantiation of a converter
class.</p>
<pre class="literal-block">
language = defaults.fallback_language
comment_strings = defaults.comment_strings
comment_string = &quot;&quot; # set in __init__ (if empty)
codeindent =  defaults.codeindent
header_string = defaults.header_string
strip = defaults.strip
state = &quot;&quot; # type of current block, see `TextCodeConverter.convert`_
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id29" id="interface-methods" name="interface-methods">3.1.2&nbsp;&nbsp;&nbsp;Interface methods</a></h3>
<div class="section">
<h4><a class="toc-backref" href="#id30" id="textcodeconverter-init" name="textcodeconverter-init">3.1.2.1&nbsp;&nbsp;&nbsp;TextCodeConverter.__init__</a></h4>
<p>Initializing sets the <cite>data</cite> attribute, an iterable object yielding lines
of the source to convert. <a class="footnote-reference" href="#id2" id="id1" name="id1">[1]</a> Additional keyword arguments are stored
as instance variables, overwriting the class defaults. If still empty,
<cite>comment_string</cite> is set accordign to the <cite>language</cite>:</p>
<pre class="literal-block">
def __init__(self, data, **keyw):
    &quot;&quot;&quot;data   --  iterable data object
                  (list, file, generator, string, ...)
       **keyw --  remaining keyword arguments are
                  stored as data-attributes
    &quot;&quot;&quot;
    self.data = data
    self.__dict__.update(keyw)
    if not self.comment_string:
        self.comment_string = self.comment_strings[self.language]
    self.preprocessor = self.get_filter(&quot;preprocessors&quot;, self.language)
    self.postprocessor = self.get_filter(&quot;postprocessors&quot;, self.language)
</pre>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id2">[1]</a></td><td><p class="first">The most common choice of data is a <cite>file</cite> object with the text
or code source.</p>
<p class="last">To convert a string into a suitable object, use its splitlines method
like <tt class="docutils literal"><span class="pre">&quot;2</span> <span class="pre">lines\nof</span> <span class="pre">source&quot;.splitlines(True)</span></tt>.</p>
</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id31" id="textcodeconverter-iter" name="textcodeconverter-iter">3.1.2.2&nbsp;&nbsp;&nbsp;TextCodeConverter.__iter__</a></h4>
<p>Return an iterator for the instance. Iteration yields lines of converted
data.</p>
<p>The iterator is a chain of iterators acting on <cite>self.data</cite> that does</p>
<ul class="simple">
<li>preprocessing</li>
<li>text&lt;-&gt;code format conversion</li>
<li>postprocessing</li>
</ul>
<p>Pre- and postprocessing are only performed, if filters for the current
language are registered in <a class="reference" href="#defaults-preprocessors">defaults.preprocessors</a> and|or
<a class="reference" href="#defaults-postprocessors">defaults.postprocessors</a>. The filters must accept an iterable as first
argument and yield the processed input data linewise.</p>
<pre class="literal-block">
def __iter__(self):
    &quot;&quot;&quot;Iterate over input data source and yield converted lines
    &quot;&quot;&quot;
    return self.postprocessor(self.convert(self.preprocessor(self.data)))
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id32" id="textcodeconverter-call" name="textcodeconverter-call">3.1.2.3&nbsp;&nbsp;&nbsp;TextCodeConverter.__call__</a></h4>
<p>The special <cite>__call__</cite> method allows the use of class instances as callable
objects. It returns the converted data as list of lines:</p>
<pre class="literal-block">
def __call__(self):
    &quot;&quot;&quot;Iterate over state-machine and return results as list of lines&quot;&quot;&quot;
    return [line for line in self]
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id33" id="textcodeconverter-str" name="textcodeconverter-str">3.1.2.4&nbsp;&nbsp;&nbsp;TextCodeConverter.__str__</a></h4>
<p>Return converted data as string:</p>
<pre class="literal-block">
def __str__(self):
    return &quot;&quot;.join(self())
</pre>
</div>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id34" id="helpers-and-convenience-methods" name="helpers-and-convenience-methods">3.1.3&nbsp;&nbsp;&nbsp;Helpers and convenience methods</a></h3>
<div class="section">
<h4><a class="toc-backref" href="#id35" id="textcodeconverter-convert" name="textcodeconverter-convert">3.1.3.1&nbsp;&nbsp;&nbsp;TextCodeConverter.convert</a></h4>
<p>The <cite>convert</cite> method generates an iterator that does the actual  code &lt;--&gt;
text format conversion. The converted data is yielded line-wise and the
instance's <cite>status</cite> argument indicates whether the current line is &quot;header&quot;,
&quot;documentation&quot;, or &quot;code_block&quot;:</p>
<pre class="literal-block">
def convert(self, lines):
    &quot;&quot;&quot;Iterate over lines of a program document and convert
    between &quot;text&quot; and &quot;code&quot; format
    &quot;&quot;&quot;
</pre>
<p>Initialise internal data arguments. (Done here, so that every new iteration
re-initialises them.)</p>
<dl class="docutils">
<dt><cite>state</cite></dt>
<dd><p class="first">the &quot;type&quot; of the currently processed block of lines. One of</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">&quot;&quot;:</th><td class="field-body">initial state: check for header,</td>
</tr>
<tr class="field"><th class="field-name">&quot;header&quot;:</th><td class="field-body">leading code block: strip <cite>header_string</cite>,</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">&quot;documentation&quot;:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">documentation part: comment out,</td>
</tr>
<tr class="field"><th class="field-name">&quot;code_block&quot;:</th><td class="field-body">literal blocks containing source code: unindent.</td>
</tr>
</tbody>
</table>
</dd>
<dt><cite>_codeindent</cite></dt>
<dd><ul class="first last simple">
<li>Do not confuse the internal attribute <cite>_codeindent</cite> with the configurable
<cite>codeindent</cite> (without the leading underscore).</li>
<li><cite>_codeindent</cite> is set in <a class="reference" href="#text2code-code-block-handler">Text2Code.code_block_handler</a> to the indent of
first non-blank &quot;code_block&quot; line and stripped from all &quot;code_block&quot; lines
in the text-to-code conversion,</li>
<li><cite>codeindent</cite> is set in <cite>__init__</cite> to <a class="reference" href="#defaults-codeindent">defaults.codeindent</a> and added to
&quot;code_block&quot; lines in the code-to-text conversion.</li>
</ul>
</dd>
<dt><cite>_textindent</cite></dt>
<dd><ul class="first last simple">
<li>set by <a class="reference" href="#text2code-documentation-handler">Text2Code.documentation_handler</a> to the minimal indent of a
documentation block,</li>
<li>used in <a class="reference" href="#text2code-set-state">Text2Code.set_state</a> to find the end of a code block.</li>
</ul>
</dd>
<dt><cite>code_block_marker_missing</cite></dt>
<dd>If the last paragraph of a documentation block does not end with a
&quot;code_block_marker&quot; (the literal-block marker <tt class="docutils literal"><span class="pre">::</span></tt>), it must
be added (otherwise, the back-conversion fails.).
<cite>code_block_marker_missing</cite> is set by <a class="reference" href="#code2text-documentation-handler">Code2Text.documentation_handler</a>
and evaluated by <a class="reference" href="#code2text-code-block-handler">Code2Text.code_block_handler</a>.</dd>
</dl>
<pre class="literal-block">
self.state = &quot;&quot;
self._codeindent = 0
self._textindent = 0
self.code_block_marker_missing = False
</pre>
<p>Determine the state of the block and convert with the matching &quot;handler&quot;:</p>
<pre class="literal-block">
for block in collect_blocks(expandtabs_filter(lines)):
    self.set_state(block)
    for line in getattr(self, self.state+&quot;_handler&quot;)(block):
        yield line
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id36" id="textcodeconverter-get-filter" name="textcodeconverter-get-filter">3.1.3.2&nbsp;&nbsp;&nbsp;TextCodeConverter.get_filter</a></h4>
<pre class="literal-block">
def get_filter(self, filter_set, language):
    &quot;&quot;&quot;Return language specific filter&quot;&quot;&quot;
    if self.__class__ == Text2Code:
        key = &quot;text2&quot;+language
    elif self.__class__ == Code2Text:
        key = language+&quot;2text&quot;
    else:
        key = &quot;&quot;
    try:
        return getattr(defaults, filter_set)[key]
    except (AttributeError, KeyError):
        # print &quot;there is no %r filter in %r&quot;%(key, filter_set)
        pass
    return identity_filter
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id37" id="textcodeconverter-get-indent" name="textcodeconverter-get-indent">3.1.3.3&nbsp;&nbsp;&nbsp;TextCodeConverter.get_indent</a></h4>
<p>Return the number of leading spaces in <cite>line</cite>:</p>
<pre class="literal-block">
def get_indent(self, line):
    &quot;&quot;&quot;Return the indentation of `string`.
    &quot;&quot;&quot;
    return len(line) - len(line.lstrip())
</pre>
</div>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id38" id="text2code" name="text2code">3.2&nbsp;&nbsp;&nbsp;Text2Code</a></h2>
<p>The <cite>Text2Code</cite> converter separates <em>code-blocks</em> <a class="footnote-reference" href="#id4" id="id3" name="id3">[2]</a> from <em>documentation</em>.
Code blocks are unindented, documentation is commented (or filtered, if the
<tt class="docutils literal"><span class="pre">strip</span></tt> option is True).</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="id4">[2]</a></td><td><p class="first">Only <a class="reference" href="http://docutils.sf.net/docs/ref/rst/restructuredtext.html#indented-literal-blocks">indented literal blocks</a> are considered code-blocks. <a class="reference" href="http://docutils.sf.net/docs/ref/rst/restructuredtext.html#quoted-literal-blocks">quoted
literal blocks</a>, <a class="reference" href="http://docutils.sf.net/docs/ref/rst/directives.html#parsed-literal-block">parsed-literal blocks</a>, and <a class="reference" href="http://docutils.sf.net/docs/ref/rst/restructuredtext.html#doctest-blocks">doctest blocks</a> are
treated as part of the documentation. This allows the inclusion of
examples:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; 23 + 3
26
</pre>
</blockquote>
<p class="last">Mark that there is no double colon before the doctest block in the
text source.</p>
</td></tr>
</tbody>
</table>
<p>The class inherits the interface and helper functions from
<a class="reference" href="#textcodeconverter">TextCodeConverter</a> and adds functions specific to the text-to-code format
conversion:</p>
<pre class="literal-block">
class Text2Code(TextCodeConverter):
    &quot;&quot;&quot;Convert a (reStructured) text source to code source
    &quot;&quot;&quot;
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id39" id="text2code-set-state" name="text2code-set-state">3.2.1&nbsp;&nbsp;&nbsp;Text2Code.set_state</a></h3>
<pre class="literal-block">
def set_state(self, block):
    &quot;&quot;&quot;Determine state of `block`. Set `self.state`
    &quot;&quot;&quot;
</pre>
<p><cite>set_state</cite> is used inside an iteration. Hence, if we are out of data, a
StopItertion exception should be raised:</p>
<pre class="literal-block">
if not block:
    raise StopIteration
</pre>
<p>The new state depends on the active state (from the last block) and
features of the current block. It is either &quot;header&quot;, &quot;documentation&quot;, or
&quot;code_block&quot;.</p>
<p>If the current state is &quot;&quot; (first block), check for
the  <cite>header_string</cite> indicating a leading code block:</p>
<pre class="literal-block">
if self.state == &quot;&quot;:
    # print &quot;set state for %r&quot;%block
    if block[0].startswith(self.header_string):
        self.state = &quot;header&quot;
    else:
        self.state = &quot;documentation&quot;
</pre>
<p>If the current state is &quot;documentation&quot;, the next block is also
documentation. The end of a documentation part is detected in the
<a class="reference" href="#text2code-documentation-handler">Text2Code.documentation_handler</a>:</p>
<pre class="literal-block">
# elif self.state == &quot;documentation&quot;:
#    self.state = &quot;documentation&quot;
</pre>
<p>A &quot;code_block&quot; ends with the first less indented, nonblank line.
<cite>_textindent</cite> is set by the documentation handler to the indent of the
preceding documentation block:</p>
<pre class="literal-block">
elif self.state in [&quot;code_block&quot;, &quot;header&quot;]:
    indents = [self.get_indent(line) for line in block]
    # print &quot;set_state:&quot;, indents, self._textindent
    if indents and min(indents) &lt;= self._textindent:
        self.state = 'documentation'
    else:
        self.state = 'code_block'
</pre>
<p>TODO: (or not to do?) insert blank line before the first line with too-small
codeindent using self.ensure_trailing_blank_line(lines, line) (would need
split and push-back of the documentation part)?</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id40" id="text2code-header-handler" name="text2code-header-handler">3.2.2&nbsp;&nbsp;&nbsp;Text2Code.header_handler</a></h3>
<p>Sometimes code needs to remain on the first line(s) of the document to be
valid. The most common example is the &quot;shebang&quot; line that tells a POSIX
shell how to process an executable file:</p>
<pre class="literal-block">
#!/usr/bin/env python
</pre>
<p>In Python, the special comment to indicate the encoding, e.g.
<tt class="docutils literal"><span class="pre">#</span> <span class="pre">-*-</span> <span class="pre">coding:</span> <span class="pre">iso-8859-1</span> <span class="pre">-*-</span></tt>, must occure before any other comment
or code too.</p>
<p>If we want to keep the line numbers in sync for text and code source, the
reStructured Text markup for these header lines must start at the same line
as the first header line. Therfore, header lines could not be marked as
literal block (this would require the <tt class="docutils literal"><span class="pre">::</span></tt> and an empty line above the
code_block).</p>
<p>OTOH, a comment may start at the same line as the comment marker and it
includes subsequent indented lines. Comments are visible in the reStructured
Text source but hidden in the pretty-printed output.</p>
<p>With a header converted to comment in the text source, everything before
the first documentation block (i.e. before the first paragraph using the
matching comment string) will be hidden away (in HTML or PDF output).</p>
<p>This seems a good compromise, the advantages</p>
<ul class="simple">
<li>line numbers are kept</li>
<li>the &quot;normal&quot; code_block conversion rules (indent/unindent by <cite>codeindent</cite> apply</li>
<li>greater flexibility: you can hide a repeating header in a project
consisting of many source files.</li>
</ul>
<p>set off the disadvantages</p>
<ul class="simple">
<li>it may come as surprise if a part of the file is not &quot;printed&quot;,</li>
<li>one more syntax element to learn for rst newbees to start with pylit,
(however, starting from the code source, this will be auto-generated)</li>
</ul>
<p>In the case that there is no matching comment at all, the complete code
source will become a comment -- however, in this case it is not very likely
the source is a literate document anyway.</p>
<p>If needed for the documentation, it is possible to quote the header in (or
after) the first documentation block, e.g. as <cite>parsed literal</cite>.</p>
<pre class="literal-block">
def header_handler(self, lines):
    &quot;&quot;&quot;Format leading code block&quot;&quot;&quot;
    # strip header string from first line
    lines[0] = lines[0].replace(self.header_string, &quot;&quot;, 1)
    # yield remaining lines formatted as code-block
    for line in self.code_block_handler(lines):
        yield line
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id41" id="text2code-documentation-handler" name="text2code-documentation-handler">3.2.3&nbsp;&nbsp;&nbsp;Text2Code.documentation_handler</a></h3>
<p>The 'documentation' handler processes everything that is not recognized as
&quot;code_block&quot;. Documentation is quoted with <cite>self.comment_string</cite>
(or filtered with <cite>--strip=True</cite>).</p>
<pre class="literal-block">
def documentation_handler(self, lines):
    &quot;&quot;&quot;Convert documentation blocks from text to code format
    &quot;&quot;&quot;
</pre>
<p>Test for the end of the documentation block: does the second last line end
with <cite>::</cite> but is neither a comment nor a directive?</p>
<p>If end-of-documentation marker is detected,</p>
<ul class="simple">
<li>set state to 'code_block'</li>
<li>set <cite>self._textindent</cite> (needed by <a class="reference" href="#text2code-set-state">Text2Code.set_state</a> to find the
next &quot;documentation&quot; block)</li>
<li>do not comment the last line (the blank line separating documentation
and code blocks).</li>
</ul>
<p>TODO: allow different code marking directives (for syntax color etc)</p>
<pre class="literal-block">
endnum = len(lines) - 2
for (num, line) in enumerate(lines):
    if not self.strip:
        if self.state == &quot;code_block&quot;:
            yield line
        else:
            yield self.comment_string + line
    if (num == endnum
        and line.rstrip().endswith(&quot;::&quot;)
        and not line.lstrip().startswith(&quot;..&quot;)):
        self.state = &quot;code_block&quot;
        self._textindent = self.get_indent(line)
</pre>
<p>TODO: Ensure a trailing blank line? Would need to test all documentation
lines for end-of-documentation marker and add a line by calling the
<cite>ensure_trailing_blank_line</cite> method (which also issues a warning)</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id42" id="text2code-code-block-handler" name="text2code-code-block-handler">3.2.4&nbsp;&nbsp;&nbsp;Text2Code.code_block_handler</a></h3>
<p>The &quot;code_block&quot; handler is called with an indented literal block. It
removes leading whitespace up to the indentation of the first code line in
the file (this deviation from docutils behaviour allows indented blocks of
Python code).</p>
<pre class="literal-block">
def code_block_handler(self, block):
    &quot;&quot;&quot;Convert indented literal blocks to source code format
    &quot;&quot;&quot;
</pre>
<p>If still unset, determine the indentation of code blocks from first non-blank
code line:</p>
<pre class="literal-block">
if self._codeindent == 0:
    self._codeindent = self.get_indent(block[0])
</pre>
<p>Yield unindented lines after check whether we can safely unindent. If the
line is less indented then <cite>_codeindent</cite>, something got wrong.</p>
<pre class="literal-block">
for line in block:
    if line.lstrip() and self.get_indent(line) &lt; self._codeindent:
        raise ValueError, &quot;code block contains line less indented &quot; \
              &quot;than %d spaces \n%r&quot;%(self._codeindent, block)
    yield line.replace(&quot; &quot;*self._codeindent, &quot;&quot;, 1)
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id43" id="code2text" name="code2text">3.3&nbsp;&nbsp;&nbsp;Code2Text</a></h2>
<p>The <cite>Code2Text</cite> converter does the opposite of <a class="reference" href="#text2code">Text2Code</a> -- it processes
a source in &quot;code format&quot; (i.e. in a programming language), extracts
documentation from comment blocks, and puts program code in literal blocks.</p>
<p>The class inherits the interface and helper functions from
<a class="reference" href="#textcodeconverter">TextCodeConverter</a> and adds functions specific to the text-to-code  format
conversion:</p>
<pre class="literal-block">
class Code2Text(TextCodeConverter):
    &quot;&quot;&quot;Convert code source to text source
    &quot;&quot;&quot;
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id44" id="code2text-set-state" name="code2text-set-state">3.3.1&nbsp;&nbsp;&nbsp;Code2Text.set_state</a></h3>
<p>Check if block is &quot;header&quot;, &quot;documentation&quot;, or &quot;code_block&quot;:</p>
<p>A paragraph is &quot;documentation&quot;, if every non-blank line starts with a
matching comment string (including whitespace except for commented blank
lines)</p>
<pre class="literal-block">
def set_state(self, block):
    &quot;&quot;&quot;Determine state of `block`.&quot;&quot;&quot;
    for line in block:
        # skip documentation lines (commented, blank or blank comment)
        if (line.startswith(self.comment_string)
            or not line.rstrip()
            or line.rstrip() == self.comment_string.rstrip()
           ):
            continue
        # non-commented line found:
        if self.state == &quot;&quot;:
            self.state = &quot;header&quot;
        else:
            self.state = &quot;code_block&quot;
        break
    else:
        # no code line found
        # keep state if the block is just a blank line
        # if len(block) == 1 and self._is_blank_codeline(line):
        #     return
        self.state = &quot;documentation&quot;
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id45" id="code2text-header-handler" name="code2text-header-handler">3.3.2&nbsp;&nbsp;&nbsp;Code2Text.header_handler</a></h3>
<p>Handle a leading code block. (See <a class="reference" href="#text2code-header-handler">Text2Code.header_handler</a> for a
discussion of the &quot;header&quot; state.)</p>
<pre class="literal-block">
def header_handler(self, lines):
    &quot;&quot;&quot;Format leading code block&quot;&quot;&quot;
    if self.strip == True:
        return
    # get iterator over the lines that formats them as code-block
    lines = iter(self.code_block_handler(lines))
    # prepend header string to first line
    yield self.header_string + lines.next()
    # yield remaining lines
    for line in lines:
        yield line
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id46" id="code2text-documentation-handler" name="code2text-documentation-handler">3.3.3&nbsp;&nbsp;&nbsp;Code2Text.documentation_handler</a></h3>
<p>The <em>documentation state</em> handler converts a comment to a documentation block by
stripping the leading <cite>comment string</cite> from every line:</p>
<pre class="literal-block">
def documentation_handler(self, lines):
    &quot;&quot;&quot;Uncomment documentation blocks in source code
    &quot;&quot;&quot;
</pre>
<p>If the code block is stripped, the literal marker would lead to
an error when the text is converted with docutils. Strip it as well.
Otherwise, check for the code block marker (<tt class="docutils literal"><span class="pre">::</span></tt>) at the end of
the documentation block:</p>
<pre class="literal-block">
if self.strip:
    self.strip_literal_marker(lines)
else:
    try:
        self.code_block_marker_missing = not(lines[-2].rstrip().endswith(&quot;::&quot;))
    except IndexError:  # len(lines &lt; 2), e.g. last line of document
        self.code_block_marker_missing = True
</pre>
<p>Strip comment strings and yield lines. Consider the case that a blank line
has a comment string without trailing whitespace:</p>
<pre class="literal-block">
stripped_comment_string = self.comment_string.rstrip()

for line in lines:
    line = line.replace(self.comment_string, &quot;&quot;, 1)
    if line.rstrip() == stripped_comment_string:
        line = line.replace(stripped_comment_string, &quot;&quot;, 1)
    yield line
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id47" id="code2text-code-block-handler" name="code2text-code-block-handler">3.3.4&nbsp;&nbsp;&nbsp;Code2Text.code_block_handler</a></h3>
<p>The <cite>code_block</cite> handler returns the code block as indented literal
block (or filters it, if <tt class="docutils literal"><span class="pre">self.strip</span> <span class="pre">==</span> <span class="pre">True</span></tt>). The amount of the code
indentation is controled by <cite>self.codeindent</cite> (default 2).</p>
<pre class="literal-block">
def code_block_handler(self, lines):
    &quot;&quot;&quot;Covert code blocks to text format (indent or strip)
    &quot;&quot;&quot;
    if self.strip == True:
        return
    # eventually insert transition marker
    if self.code_block_marker_missing:
        self.state = &quot;documentation&quot;
        yield &quot;::\n&quot;
        yield &quot;\n&quot;
        self.state = &quot;code_block&quot;
    for line in lines:
        yield &quot; &quot;*self.codeindent + line
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id48" id="code2text-strip-literal-marker" name="code2text-strip-literal-marker">3.3.5&nbsp;&nbsp;&nbsp;Code2Text.strip_literal_marker</a></h3>
<p>Replace the literal marker with the equivalent of docutils replace rules</p>
<ul class="simple">
<li>strip <cite>::</cite>-line (and preceding blank line) if on a line on its own</li>
<li>strip <cite>::</cite> if it is preceded by whitespace.</li>
<li>convert <cite>::</cite> to a single colon if preceded by text</li>
</ul>
<p><cite>lines</cite> should be a list of documentation lines (with a trailing blank line).
It is modified in-place:</p>
<pre class="literal-block">
def strip_literal_marker(self, lines):
    try:
        line = lines[-2]
    except IndexError:  # len(lines &lt; 2)
        return

    # split at rightmost '::'
    try:
        (head, tail) = line.rsplit('::', 1)
    except ValueError:  # only one part (no '::')
        return

    # '::' on an extra line
    if not head.strip():
        del(lines[-2])
        # delete preceding line if it is blank
        if len(lines) &gt;= 2 and not lines[-2].lstrip():
            del(lines[-2])
    # '::' follows whitespace
    elif head.rstrip() &lt; head:
        head = head.rstrip()
        lines[-2] = &quot;&quot;.join((head, tail))
    # '::' follows text
    else:
        lines[-2] = &quot;:&quot;.join((head, tail))
</pre>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id49" id="filters" name="filters">4&nbsp;&nbsp;&nbsp;Filters</a></h1>
<p>Filters allow pre- and post-processing of the data to bring it in a format
suitable for the &quot;normal&quot; text&lt;-&gt;code conversion. An example is conversion
of <cite>C</cite> <tt class="docutils literal"><span class="pre">/*</span></tt> <tt class="docutils literal"><span class="pre">*/</span></tt> comments into C++ <tt class="docutils literal"><span class="pre">//</span></tt> comments (and back).
Another example is the conversion of <cite>C</cite> <tt class="docutils literal"><span class="pre">/*</span></tt> <tt class="docutils literal"><span class="pre">*/</span></tt> comments into C++
<tt class="docutils literal"><span class="pre">//</span></tt> comments (and back).</p>
<p>Filters are generator functions that return an iterator acting on a
<cite>data</cite> iterable and yielding processed <cite>data</cite> lines.</p>
<div class="section">
<h2><a class="toc-backref" href="#id50" id="identity-filter" name="identity-filter">4.1&nbsp;&nbsp;&nbsp;identity_filter</a></h2>
<p>The most basic filter is the identity filter, that returns its argument as
iterator:</p>
<pre class="literal-block">
def identity_filter(data):
    &quot;&quot;&quot;Return data iterator without any processing&quot;&quot;&quot;
    return iter(data)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id51" id="expandtabs-filter" name="expandtabs-filter">4.2&nbsp;&nbsp;&nbsp;expandtabs_filter</a></h2>
<p>Expand hard-tabs in every line of <cite>data</cite> (cf. <cite>str.expandtabs</cite>).</p>
<p>This filter is applied to the input data by <a class="reference" href="#textcodeconverter-convert">TextCodeConverter.convert</a> as
hard tabs can lead to errors when the indentation is changed.</p>
<pre class="literal-block">
def expandtabs_filter(data):
    &quot;&quot;&quot;Yield data tokens with hard-tabs expanded&quot;&quot;&quot;
    for line in data:
        yield line.expandtabs()
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id52" id="collect-blocks" name="collect-blocks">4.3&nbsp;&nbsp;&nbsp;collect_blocks</a></h2>
<p>A filter to aggregate &quot;paragraphs&quot; (blocks separated by blank
lines). Yields lists of lines:</p>
<pre class="literal-block">
def collect_blocks(lines):
    &quot;&quot;&quot;collect lines in a list

    yield list for each paragraph, i.e. block of lines separated by a
    blank line (whitespace only).

    Trailing blank lines are collected as well.
    &quot;&quot;&quot;
    blank_line_reached = False
    block = []
    for line in lines:
        if blank_line_reached and line.rstrip():
            yield block
            blank_line_reached = False
            block = [line]
            continue
        if not line.rstrip():
            blank_line_reached = True
        block.append(line)
    yield block
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id53" id="dumb-c-preprocessor" name="dumb-c-preprocessor">4.4&nbsp;&nbsp;&nbsp;dumb_c_preprocessor</a></h2>
<p>This is a basic filter to convert <cite>C</cite> to <cite>C++</cite> comments. Works line-wise and
only converts lines that</p>
<ul class="simple">
<li>start with &quot;/* &quot; and end with &quot; */&quot; (followed by whitespace only)</li>
</ul>
<p>A more sophisticated version would also</p>
<ul class="simple">
<li>convert multi-line comments<ul>
<li>Keep indentation or strip 3 leading spaces?</li>
</ul>
</li>
<li>account for nested comments</li>
<li>only convert comments that are separated from code by a blank line</li>
</ul>
<pre class="literal-block">
def dumb_c_preprocessor(data):
    &quot;&quot;&quot;change `C` ``/* `` `` */`` comments into C++ ``// `` comments&quot;&quot;&quot;
    comment_string = defaults.comment_strings[&quot;c++&quot;]
    boc_string = &quot;/* &quot;
    eoc_string = &quot; */&quot;
    for line in data:
        if (line.startswith(boc_string)
            and line.rstrip().endswith(eoc_string)
           ):
            line = line.replace(boc_string, comment_string, 1)
            line = &quot;&quot;.join(line.rsplit(eoc_string, 1))
        yield line
</pre>
<p>Unfortunately, the <cite>replace</cite> method of strings does not support negative
numbers for the <cite>count</cite> argument:</p>
<pre class="doctest-block">
&gt;&gt;&gt; &quot;foo */ baz */ bar&quot;.replace(&quot; */&quot;, &quot;&quot;, -1) == &quot;foo */ baz bar&quot;
</pre>
<p>However, there is the <cite>rsplit</cite> method, that can be used together with <cite>join</cite>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; &quot;&quot;.join(&quot;foo */ baz */ bar&quot;.rsplit(&quot; */&quot;, 1)) == &quot;foo */ baz bar&quot;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id54" id="dumb-c-postprocessor" name="dumb-c-postprocessor">4.5&nbsp;&nbsp;&nbsp;dumb_c_postprocessor</a></h2>
<p>Undo the preparations by the dumb_c_preprocessor and re-insert valid comment
delimiters</p>
<pre class="literal-block">
def dumb_c_postprocessor(data):
    &quot;&quot;&quot;change C++ ``// `` comments into `C` ``/* `` `` */`` comments&quot;&quot;&quot;
    comment_string = defaults.comment_strings[&quot;c++&quot;]
    boc_string = &quot;/* &quot;
    eoc_string = &quot; */&quot;
    for line in data:
        if line.rstrip() == comment_string.rstrip():
            line = line.replace(comment_string, &quot;&quot;, 1)
        elif line.startswith(comment_string):
            line = line.replace(comment_string, boc_string, 1)
            line = line.rstrip() + eoc_string + &quot;\n&quot;
        yield line
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id55" id="register-filters" name="register-filters">4.6&nbsp;&nbsp;&nbsp;register filters</a></h2>
<pre class="literal-block">
defaults.preprocessors['c2text'] = dumb_c_preprocessor
defaults.preprocessors['css2text'] = dumb_c_preprocessor
defaults.postprocessors['text2c'] = dumb_c_postprocessor
defaults.postprocessors['text2css'] = dumb_c_postprocessor
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id56" id="command-line-use" name="command-line-use">5&nbsp;&nbsp;&nbsp;Command line use</a></h1>
<p>Using this script from the command line will convert a file according to its
extension. This default can be overridden by a couple of options.</p>
<div class="section">
<h2><a class="toc-backref" href="#id57" id="dual-source-handling" name="dual-source-handling">5.1&nbsp;&nbsp;&nbsp;Dual source handling</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id58" id="how-to-determine-which-source-is-up-to-date" name="how-to-determine-which-source-is-up-to-date">5.1.1&nbsp;&nbsp;&nbsp;How to determine which source is up-to-date?</a></h3>
<ul>
<li><p class="first">set modification date of <cite>oufile</cite> to the one of <cite>infile</cite></p>
<p>Points out that the source files are 'synchronized'.</p>
<ul>
<li><p class="first">Are there problems to expect from &quot;backdating&quot; a file? Which?</p>
<p>Looking at <a class="reference" href="http://www.unix.com/showthread.php?t=20526">http://www.unix.com/showthread.php?t=20526</a>, it seems
perfectly legal to set <cite>mtime</cite> (while leaving <cite>ctime</cite>) as <cite>mtime</cite> is a
description of the &quot;actuality&quot; of the data in the file.</p>
</li>
<li><p class="first">Should this become a default or an option?</p>
</li>
</ul>
</li>
<li><p class="first">alternatively move input file to a backup copy (with option: <cite>--replace</cite>)</p>
</li>
<li><p class="first">check modification date before overwriting
(with option: <cite>--overwrite=update</cite>)</p>
</li>
<li><p class="first">check modification date before editing (implemented as <a class="reference" href="http://www.jedsoft.org/jed/">Jed editor</a>
function <cite>pylit_check()</cite> in <a class="reference" href="http://jedmodes.sourceforge.net/mode/pylit/">pylit.sl</a>)</p>
</li>
</ul>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id59" id="recognised-filename-extensions" name="recognised-filename-extensions">5.1.2&nbsp;&nbsp;&nbsp;Recognised Filename Extensions</a></h3>
<p>Instead of defining a new extension for &quot;pylit&quot; literate programms,
by default <tt class="docutils literal"><span class="pre">.txt</span></tt> will be appended for the text source and stripped by
the conversion to the code source. I.e. for a Python program foo:</p>
<ul class="simple">
<li>the code source is called <tt class="docutils literal"><span class="pre">foo.py</span></tt></li>
<li>the text source is called <tt class="docutils literal"><span class="pre">foo.py.txt</span></tt></li>
<li>the html rendering is called <tt class="docutils literal"><span class="pre">foo.py.html</span></tt></li>
</ul>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id60" id="optionvalues" name="optionvalues">5.2&nbsp;&nbsp;&nbsp;OptionValues</a></h2>
<p>The following class adds <cite>as_dict</cite> and <cite>__getattr__</cite> methods to
<cite>optparse.Values</cite>:</p>
<pre class="literal-block">
class OptionValues(optparse.Values):
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id61" id="optionvalues-as-dict" name="optionvalues-as-dict">5.2.1&nbsp;&nbsp;&nbsp;OptionValues.as_dict</a></h3>
<p>For use as keyword arguments, it is handy to have the options in a
dictionary. <cite>as_dict</cite> returns a copy of the instances object dictionary:</p>
<pre class="literal-block">
def as_dict(self):
    &quot;&quot;&quot;Return options as dictionary object&quot;&quot;&quot;
    return self.__dict__.copy()
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id62" id="optionvalues-complete" name="optionvalues-complete">5.2.2&nbsp;&nbsp;&nbsp;OptionValues.complete</a></h3>
<pre class="literal-block">
def complete(self, **keyw):
    &quot;&quot;&quot;
    Complete the option values with keyword arguments.

    Do not overwrite existing values. Only use arguments that do not
    have a corresponding attribute in `self`,
    &quot;&quot;&quot;
    for key in keyw:
        if not self.__dict__.has_key(key):
            setattr(self, key, keyw[key])
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id63" id="optionvalues-getattr" name="optionvalues-getattr">5.2.3&nbsp;&nbsp;&nbsp;OptionValues.__getattr__</a></h3>
<p>To replace calls using <tt class="docutils literal"><span class="pre">options.ensure_value(&quot;OPTION&quot;,</span> <span class="pre">None)</span></tt> with the
more concise <tt class="docutils literal"><span class="pre">options.OPTION</span></tt>, we define <cite>__getattr__</cite> <a class="footnote-reference" href="#id6" id="id5" name="id5">[3]</a></p>
<pre class="literal-block">
def __getattr__(self, name):
    &quot;&quot;&quot;Return default value for non existing options&quot;&quot;&quot;
    return None
</pre>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5" name="id6">[3]</a></td><td>The special method <cite>__getattr__</cite> is only called when an attribute
lookup has not found the attribute in the usual places (i.e. it is
not an instance attribute nor is it found in the class tree for
self).</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id64" id="pylitoptions" name="pylitoptions">5.3&nbsp;&nbsp;&nbsp;PylitOptions</a></h2>
<p>The <cite>PylitOptions</cite> class comprises an option parser and methods for parsing
and completion of command line options:</p>
<pre class="literal-block">
class PylitOptions(object):
    &quot;&quot;&quot;Storage and handling of command line options for pylit&quot;&quot;&quot;
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id65" id="instantiation" name="instantiation">5.3.1&nbsp;&nbsp;&nbsp;Instantiation</a></h3>
<pre class="literal-block">
def __init__(self):
    &quot;&quot;&quot;Set up an `OptionParser` instance for pylit command line options

    &quot;&quot;&quot;
    p = optparse.OptionParser(usage=main.__doc__, version=_version)
    # add the options
    p.add_option(&quot;-c&quot;, &quot;--code2txt&quot;, dest=&quot;txt2code&quot;, action=&quot;store_false&quot;,
                 help=&quot;convert code source to text source&quot;)
    p.add_option(&quot;--comment-string&quot;, dest=&quot;comment_string&quot;,
                 help=&quot;documentation block marker (default '# ' (for python))&quot; )
    p.add_option(&quot;-d&quot;, &quot;--diff&quot;, action=&quot;store_true&quot;,
                 help=&quot;test for differences to existing file&quot;)
    p.add_option(&quot;--doctest&quot;, action=&quot;store_true&quot;,
                 help=&quot;run doctest.testfile() on the text version&quot;)
    p.add_option(&quot;-e&quot;, &quot;--execute&quot;, action=&quot;store_true&quot;,
                 help=&quot;execute code (Python only)&quot;)
    p.add_option(&quot;--language&quot;, action=&quot;store&quot;,
                 choices = defaults.languages.values(),
                 help=&quot;use LANGUAGE native comment style&quot;)
    p.add_option(&quot;--overwrite&quot;, action=&quot;store&quot;,
                 choices = [&quot;yes&quot;, &quot;update&quot;, &quot;no&quot;],
                 help=&quot;overwrite output file (default 'update')&quot;)
    p.add_option(&quot;--replace&quot;, action=&quot;store_true&quot;,
                 help=&quot;move infile to a backup copy (appending '~')&quot;)
    p.add_option(&quot;-s&quot;, &quot;--strip&quot;, action=&quot;store_true&quot;,
                 help=&quot;export by stripping documentation or code&quot;)
    p.add_option(&quot;-t&quot;, &quot;--txt2code&quot;, action=&quot;store_true&quot;,
                 help=&quot;convert text source to code source&quot;)
    self.parser = p
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id66" id="pylitoptions-parse-args" name="pylitoptions-parse-args">5.3.2&nbsp;&nbsp;&nbsp;PylitOptions.parse_args</a></h3>
<p>The <cite>parse_args</cite> method calls the <cite>optparse.OptionParser</cite> on command
line or provided args and returns the result as <cite>PylitOptions.Values</cite>
instance. Defaults can be provided as keyword arguments:</p>
<pre class="literal-block">
def parse_args(self, args=sys.argv[1:], **keyw):
    &quot;&quot;&quot;parse command line arguments using `optparse.OptionParser`

       parse_args(args, **keyw) -&gt; OptionValues instance

        args --  list of command line arguments.
        keyw --  keyword arguments or dictionary of option defaults
    &quot;&quot;&quot;
    # parse arguments
    (values, args) = self.parser.parse_args(args, OptionValues(keyw))
    # Convert FILE and OUTFILE positional args to option values
    # (other positional arguments are ignored)
    try:
        values.infile = args[0]
        values.outfile = args[1]
    except IndexError:
        pass

    return values
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id67" id="pylitoptions-complete-values" name="pylitoptions-complete-values">5.3.3&nbsp;&nbsp;&nbsp;PylitOptions.complete_values</a></h3>
<p>Complete an OptionValues instance <cite>values</cite>.  Use module-level defaults and
context information to set missing option values to sensible defaults (if
possible)</p>
<pre class="literal-block">
def complete_values(self, values):
    &quot;&quot;&quot;complete option values with module and context sensible defaults

    x.complete_values(values) -&gt; values
    values -- OptionValues instance
    &quot;&quot;&quot;
</pre>
<p>Complete with module-level <a class="reference" href="#defaults">defaults</a>:</p>
<pre class="literal-block">
values.complete(**defaults.__dict__)
</pre>
<p>Ensure infile is a string:</p>
<pre class="literal-block">
values.ensure_value(&quot;infile&quot;, &quot;&quot;)
</pre>
<p>Guess conversion direction from <cite>infile</cite> filename:</p>
<pre class="literal-block">
if values.txt2code is None:
    in_extension = os.path.splitext(values.infile)[1]
    if in_extension in values.text_extensions:
        values.txt2code = True
    elif in_extension in values.languages.keys():
        values.txt2code = False
</pre>
<p>Auto-determine the output file name:</p>
<pre class="literal-block">
values.ensure_value(&quot;outfile&quot;, self._get_outfile_name(values))
</pre>
<p>Second try: Guess conversion direction from outfile filename:</p>
<pre class="literal-block">
if values.txt2code is None:
    out_extension = os.path.splitext(values.outfile)[1]
    values.txt2code = not (out_extension in values.text_extensions)
</pre>
<p>Set the language of the code:</p>
<pre class="literal-block">
if values.txt2code is True:
    code_extension = os.path.splitext(values.outfile)[1]
elif values.txt2code is False:
    code_extension = os.path.splitext(values.infile)[1]
values.ensure_value(&quot;language&quot;,
                    values.languages.get(code_extension,
                                         values.fallback_language))

return values
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id68" id="pylitoptions-get-outfile-name" name="pylitoptions-get-outfile-name">5.3.4&nbsp;&nbsp;&nbsp;PylitOptions._get_outfile_name</a></h3>
<p>Construct a matching filename for the output file. The output filename is
constructed from <cite>infile</cite> by the following rules:</p>
<ul class="simple">
<li>'-' (stdin) results in '-' (stdout)</li>
<li>strip the <cite>txt_extension</cite> (txt2code) or</li>
<li>add a <cite>txt_ extension</cite> (code2txt)</li>
<li>fallback: if no guess can be made, add &quot;.out&quot;<!-- TODO: use values.outfile_extension if it exists? -->
</li>
</ul>
<pre class="literal-block">
def _get_outfile_name(self, values):
    &quot;&quot;&quot;Return a matching output filename for `infile`
    &quot;&quot;&quot;
    # if input is stdin, default output is stdout
    if values.infile == '-':
        return '-'

    # Derive from `infile` name: strip or add text extension
    (base, ext) = os.path.splitext(values.infile)
    if ext in values.text_extensions:
        return base # strip
    if ext in values.languages.keys() or values.txt2code == False:
        return values.infile + values.text_extensions[0] # add
    # give up
    return values.infile + &quot;.out&quot;
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id69" id="pylitoptions-call" name="pylitoptions-call">5.3.5&nbsp;&nbsp;&nbsp;PylitOptions.__call__</a></h3>
<p>The special <cite>__call__</cite> method allows to use PylitOptions instances as
<em>callables</em>: Calling an instance parses the argument list to extract option
values and completes them based on &quot;context-sensitive defaults&quot;.  Keyword
arguments are passed to <a class="reference" href="#pylitoptions-parse-args">PylitOptions.parse_args</a> as default values.</p>
<pre class="literal-block">
def __call__(self, args=sys.argv[1:], **keyw):
    &quot;&quot;&quot;parse and complete command line args return option values
    &quot;&quot;&quot;
    values = self.parse_args(args, **keyw)
    return self.complete_values(values)
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id70" id="helper-functions" name="helper-functions">5.4&nbsp;&nbsp;&nbsp;Helper functions</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id71" id="open-streams" name="open-streams">5.4.1&nbsp;&nbsp;&nbsp;open_streams</a></h3>
<p>Return file objects for in- and output. If the input path is missing,
write usage and abort. (An alternative would be to use stdin as default.
However,  this leaves the uninitiated user with a non-responding application
if (s)he just tries the script without any arguments)</p>
<pre class="literal-block">
def open_streams(infile = '-', outfile = '-', overwrite='update', **keyw):
    &quot;&quot;&quot;Open and return the input and output stream

    open_streams(infile, outfile) -&gt; (in_stream, out_stream)

    in_stream   --  file(infile) or sys.stdin
    out_stream  --  file(outfile) or sys.stdout
    overwrite   --  'yes': overwrite eventually existing `outfile`,
                    'update': fail if the `outfile` is newer than `infile`,
                    'no': fail if `outfile` exists.

                    Irrelevant if `outfile` == '-'.
    &quot;&quot;&quot;
    if not infile:
        strerror = &quot;Missing input file name ('-' for stdin; -h for help)&quot;
        raise IOError, (2, strerror, infile)
    if infile == '-':
        in_stream = sys.stdin
    else:
        in_stream = file(infile, 'r')
    if outfile == '-':
        out_stream = sys.stdout
    elif overwrite == 'no' and os.path.exists(outfile):
        raise IOError, (1, &quot;Output file exists!&quot;, outfile)
    elif overwrite == 'update' and is_newer(outfile, infile):
        raise IOError, (1, &quot;Output file is newer than input file!&quot;, outfile)
    else:
        out_stream = file(outfile, 'w')
    return (in_stream, out_stream)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id72" id="is-newer" name="is-newer">5.4.2&nbsp;&nbsp;&nbsp;is_newer</a></h3>
<pre class="literal-block">
def is_newer(path1, path2):
    &quot;&quot;&quot;Check if `path1` is newer than `path2` (using mtime)

    Compare modification time of files at path1 and path2.

    Non-existing files are considered oldest: Return False if path1 doesnot
    exist and True if path2 doesnot exist.

    Return None for equal modification time. (This evaluates to False in a
    boolean context but allows a test for equality.)

    &quot;&quot;&quot;
    try:
        mtime1 = os.path.getmtime(path1)
    except OSError:
        mtime1 = -1
    try:
        mtime2 = os.path.getmtime(path2)
    except OSError:
        mtime2 = -1
    # print &quot;mtime1&quot;, mtime1, path1, &quot;\n&quot;, &quot;mtime2&quot;, mtime2, path2

    if mtime1 == mtime2:
        return None
    return mtime1 &gt; mtime2
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id73" id="get-converter" name="get-converter">5.4.3&nbsp;&nbsp;&nbsp;get_converter</a></h3>
<p>Get an instance of the converter state machine:</p>
<pre class="literal-block">
def get_converter(data, txt2code=True, **keyw):
    if txt2code:
        return Text2Code(data, **keyw)
    else:
        return Code2Text(data, **keyw)
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id74" id="use-cases" name="use-cases">5.5&nbsp;&nbsp;&nbsp;Use cases</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id75" id="run-doctest" name="run-doctest">5.5.1&nbsp;&nbsp;&nbsp;run_doctest</a></h3>
<pre class="literal-block">
def run_doctest(infile=&quot;-&quot;, txt2code=True,
                globs={}, verbose=False, optionflags=0, **keyw):
    &quot;&quot;&quot;run doctest on the text source
    &quot;&quot;&quot;
    from doctest import DocTestParser, DocTestRunner
    (data, out_stream) = open_streams(infile, &quot;-&quot;)
</pre>
<p>If source is code, convert to text, as tests in comments are not found by
doctest:</p>
<pre class="literal-block">
if txt2code is False:
    converter = Code2Text(data, **keyw)
    docstring = str(converter)
else:
    docstring = data.read()
</pre>
<p>Use the doctest Advanced API to do all doctests in a given string:</p>
<pre class="literal-block">
test = DocTestParser().get_doctest(docstring, globs={}, name=&quot;&quot;,
                                       filename=infile, lineno=0)
runner = DocTestRunner(verbose=verbose, optionflags=optionflags)
runner.run(test)
runner.summarize
if not runner.failures:
    print &quot;%d failures in %d tests&quot;%(runner.failures, runner.tries)
return runner.failures, runner.tries
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id76" id="diff" name="diff">5.5.2&nbsp;&nbsp;&nbsp;diff</a></h3>
<pre class="literal-block">
def diff(infile='-', outfile='-', txt2code=True, **keyw):
    &quot;&quot;&quot;Report differences between converted infile and existing outfile

    If outfile is '-', do a round-trip conversion and report differences
    &quot;&quot;&quot;

    import difflib

    instream = file(infile)
    # for diffing, we need a copy of the data as list::
    data = instream.readlines()
    # convert
    converter = get_converter(data, txt2code, **keyw)
    new = converter()

    if outfile != '-':
        outstream = file(outfile)
        old = outstream.readlines()
        oldname = outfile
        newname = &quot;&lt;conversion of %s&gt;&quot;%infile
    else:
        old = data
        oldname = infile
        # back-convert the output data
        converter = get_converter(new, not txt2code)
        new = converter()
        newname = &quot;&lt;round-conversion of %s&gt;&quot;%infile

    # find and print the differences
    is_different = False
    # print type(old), old
    # print type(new), new
    delta = difflib.unified_diff(old, new,
    # delta = difflib.unified_diff([&quot;heute\n&quot;, &quot;schon\n&quot;], [&quot;heute\n&quot;, &quot;noch\n&quot;],
                                      fromfile=oldname, tofile=newname)
    for line in delta:
        is_different = True
        print line,
    if not is_different:
        print oldname
        print newname
        print &quot;no differences found&quot;
    return is_different
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id77" id="execute" name="execute">5.5.3&nbsp;&nbsp;&nbsp;execute</a></h3>
<p>Works only for python code.</p>
<p>Doesnot work with <cite>eval</cite>, as code is not just one expression.</p>
<pre class="literal-block">
def execute(infile=&quot;-&quot;, txt2code=True, **keyw):
    &quot;&quot;&quot;Execute the input file. Convert first, if it is a text source.
    &quot;&quot;&quot;

    data = file(infile)
    if txt2code:
        data = str(Text2Code(data, **keyw))
    # print &quot;executing &quot; + options.infile
    exec data
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id78" id="main" name="main">5.6&nbsp;&nbsp;&nbsp;main</a></h2>
<p>If this script is called from the command line, the <cite>main</cite> function will
convert the input (file or stdin) between text and code formats.</p>
<p>Option default values for the conversion can be given as keyword arguments
to <a class="reference" href="#main">main</a>.  The option defaults will be updated by command line options and
extended with &quot;intelligent guesses&quot; by <a class="reference" href="#pylitoptions">PylitOptions</a> and passed on to
helper functions and the converter instantiation.</p>
<p>This allows easy customization for programmatic use -- just call <cite>main</cite>
with the appropriate keyword options, e.g.:</p>
<pre class="doctest-block">
&gt;&gt;&gt; main(comment_string=&quot;## &quot;)
</pre>
<pre class="literal-block">
def main(args=sys.argv[1:], **defaults):
    &quot;&quot;&quot;%prog [options] INFILE [OUTFILE]

    Convert between (reStructured) text source with embedded code,
    and code source with embedded documentation (comment blocks)

    The special filename '-' stands for standard in and output.
    &quot;&quot;&quot;
</pre>
<p>Parse and complete the options:</p>
<pre class="literal-block">
options = PylitOptions()(args, **defaults)
# print &quot;infile&quot;, repr(options.infile)
</pre>
<p>Special actions with early return:</p>
<pre class="literal-block">
if options.doctest:
    return run_doctest(**options.as_dict())

if options.diff:
    return diff(**options.as_dict())

if options.execute:
    return execute(**options.as_dict())
</pre>
<p>Open in- and output streams:</p>
<pre class="literal-block">
try:
    (data, out_stream) = open_streams(**options.as_dict())
except IOError, ex:
    print &quot;IOError: %s %s&quot; % (ex.filename, ex.strerror)
    sys.exit(ex.errno)
</pre>
<p>Get a converter instance:</p>
<pre class="literal-block">
converter = get_converter(data, **options.as_dict())
</pre>
<p>Convert and write to out_stream:</p>
<pre class="literal-block">
out_stream.write(str(converter))

if out_stream is not sys.stdout:
    print &quot;extract written to&quot;, out_stream.name
    out_stream.close()
</pre>
<p>If input and output are from files, set the modification time (<cite>mtime</cite>) of
the output file to the one of the input file to indicate that the contained
information is equal. <a class="footnote-reference" href="#id8" id="id7" name="id7">[4]</a></p>
<pre class="literal-block">
    try:
        os.utime(options.outfile, (os.path.getatime(options.outfile),
                                   os.path.getmtime(options.infile))
                )
    except OSError:
        pass

## print &quot;mtime&quot;, os.path.getmtime(options.infile),  options.infile
## print &quot;mtime&quot;, os.path.getmtime(options.outfile), options.outfile
</pre>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7" name="id8">[4]</a></td><td>Make sure the corresponding file object (here <cite>out_stream</cite>) is
closed, as otherwise the change will be overwritten when <cite>close</cite> is
called afterwards (either explicitely or at program exit).</td></tr>
</tbody>
</table>
<p>Rename the infile to a backup copy if <tt class="docutils literal"><span class="pre">--replace</span></tt> is set:</p>
<pre class="literal-block">
if options.replace:
    os.rename(options.infile, options.infile + &quot;~&quot;)
</pre>
<p>Run main, if called from the command line:</p>
<pre class="literal-block">
if __name__ == '__main__':
    main()
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id79" id="open-questions" name="open-questions">6&nbsp;&nbsp;&nbsp;Open questions</a></h1>
<p>Open questions and ideas for further development</p>
<div class="section">
<h2><a class="toc-backref" href="#id80" id="clean-code" name="clean-code">6.1&nbsp;&nbsp;&nbsp;Clean code</a></h2>
<ul class="simple">
<li>can we gain from using &quot;shutils&quot; over &quot;os.path&quot; and &quot;os&quot;?</li>
<li>use pylint or pyChecker to enfoce a consistent style?</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id81" id="options" name="options">6.2&nbsp;&nbsp;&nbsp;Options</a></h2>
<ul class="simple">
<li>Use templates for the &quot;intelligent guesses&quot; (with Python syntax for string
replacement with dicts: <tt class="docutils literal"><span class="pre">&quot;hello</span> <span class="pre">%(what)s&quot;</span> <span class="pre">%</span> <span class="pre">{'what':</span> <span class="pre">'world'}</span></tt>)</li>
<li>Is it sensible to offer the <cite>header_string</cite> option also as command line
option?</li>
<li>Configurable</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id82" id="parsing-problems" name="parsing-problems">6.3&nbsp;&nbsp;&nbsp;Parsing Problems</a></h2>
<ul>
<li><p class="first">How can I include a literal block that should not be in the
executable code (e.g. an example, an earlier version or variant)?</p>
<p>Workarounds:</p>
<ul>
<li><p class="first">Use a <a class="reference" href="http://docutils.sf.net/docs/ref/rst/directives.html#parsed-literal-block">parsed-literal block</a> directive if there is no &quot;accidential&quot;
markup in the literal code</p>
</li>
<li><p class="first">Use a <a class="reference" href="http://docutils.sf.net/docs/ref/rst/restructuredtext.html#line-blocks">line block</a> and mark all lines as <a class="reference" href="http://docutils.sf.net/docs/ref/rst/restructuredtext.html#inline-literals">inline literals</a>.</p>
</li>
<li><p class="first">Python session examples and doctests can use <a class="reference" href="http://docutils.sf.net/docs/ref/rst/restructuredtext.html#doctest-blocks">doctest block</a> syntax</p>
<p>No double colon! Start first line of block with <tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt>.</p>
</li>
</ul>
<p>Not implemented yet:</p>
<ul class="simple">
<li>use a dedicated <a class="reference" href="#code-block-directive">code-block directive</a> or a distinct directive for
ordinary literal blocks.</li>
</ul>
</li>
<li><p class="first">Ignore &quot;matching comments&quot; in literal strings?</p>
<p>Too complicated: Would need a specific detection algorithm for every
language that supports multi-line literal strings (C++, PHP, Python)</p>
</li>
<li><p class="first">Warn if a comment in code will become documentation after round-trip?</p>
</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id83" id="code-block-directive" name="code-block-directive">6.4&nbsp;&nbsp;&nbsp;code-block directive</a></h2>
<p>In a document where code examples are only one of several uses of literal
blocks, it would be more appropriate to single out the sourcecode with a
dedicated &quot;code-block&quot; directive.</p>
<p>Some highlight plug-ins require a special &quot;sourcecode&quot; or &quot;code-block&quot;
directive instead of the <tt class="docutils literal"><span class="pre">::</span></tt> literal block marker. Actually,
syntax-highlight is possible without changes to docutils with the <a class="reference" href="http://pygments.org/">Pygments</a>
package using a &quot;code-block&quot; directive. See the <a class="reference" href="../features/syntax-highlight.html">syntax highlight</a> section
in the features documentation.</p>
<p>TODO:</p>
<ul class="simple">
<li>provide a &quot;code-block-marker&quot; string option.</li>
<li>correctly handle the case of <tt class="docutils literal"><span class="pre">code_block_marker</span> <span class="pre">==</span> <span class="pre">'::'</span></tt> and conversion
of <tt class="docutils literal"><span class="pre">::</span></tt> to a different &quot;code_block_marker&quot; -- consider minimized forms.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id84" id="doctstrings-in-code-blocks" name="doctstrings-in-code-blocks">6.5&nbsp;&nbsp;&nbsp;doctstrings in code blocks</a></h2>
<ul class="simple">
<li>How to handle docstrings in code blocks? (it would be nice to convert them
to rst-text if <tt class="docutils literal"><span class="pre">__docformat__</span> <span class="pre">==</span> <span class="pre">restructuredtext</span></tt>)</li>
</ul>
<p>TODO: Ask at docutils users|developers</p>
<!-- References -->
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="pylit.py.txt">View document source</a>.
Generated on: 2007-06-06.

</div>
</body>
</html>
