<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title>pylit.py: Literate programming with Python and reStructuredText</title>
<meta name="date" content="2007-01-31" />
<meta name="copyright" content="2005, 2007 Guenter Milde. Released under the terms of the GNU General Public License (v. 2 or later)" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="pylit-py-literate-programming-with-python-and-restructuredtext">
<h1 class="title">pylit.py: Literate programming with Python and reStructuredText</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Date:</th>
<td>2007-01-31</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>2005, 2007 Guenter Milde.
Released under the terms of the GNU General Public License
(v. 2 or later)</td></tr>
</tbody>
</table>
<!-- #!/usr/bin/env python
# -*- coding: iso-8859-1 -*- -->
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#frontmatter" id="id8" name="id8">1&nbsp;&nbsp;&nbsp;Frontmatter</a><ul class="auto-toc">
<li><a class="reference" href="#changelog" id="id9" name="id9">1.1&nbsp;&nbsp;&nbsp;Changelog</a></li>
<li><a class="reference" href="#requirements" id="id10" name="id10">1.2&nbsp;&nbsp;&nbsp;Requirements</a></li>
</ul>
</li>
<li><a class="reference" href="#customization" id="id11" name="id11">2&nbsp;&nbsp;&nbsp;Customization</a></li>
<li><a class="reference" href="#classes" id="id12" name="id12">3&nbsp;&nbsp;&nbsp;Classes</a><ul class="auto-toc">
<li><a class="reference" href="#pushiterator" id="id13" name="id13">3.1&nbsp;&nbsp;&nbsp;PushIterator</a></li>
<li><a class="reference" href="#converter" id="id14" name="id14">3.2&nbsp;&nbsp;&nbsp;Converter</a><ul class="auto-toc">
<li><a class="reference" href="#data-attributes" id="id15" name="id15">3.2.1&nbsp;&nbsp;&nbsp;Data attributes</a></li>
<li><a class="reference" href="#instantiation" id="id16" name="id16">3.2.2&nbsp;&nbsp;&nbsp;Instantiation</a></li>
<li><a class="reference" href="#converter-str" id="id17" name="id17">3.2.3&nbsp;&nbsp;&nbsp;Converter.__str__</a></li>
<li><a class="reference" href="#converter-get-indent" id="id18" name="id18">3.2.4&nbsp;&nbsp;&nbsp;Converter.get_indent</a></li>
<li><a class="reference" href="#converter-ensure-trailing-blank-line" id="id19" name="id19">3.2.5&nbsp;&nbsp;&nbsp;Converter.ensure_trailing_blank_line</a></li>
<li><a class="reference" href="#converter-collect-blocks" id="id20" name="id20">3.2.6&nbsp;&nbsp;&nbsp;Converter.collect_blocks</a></li>
</ul>
</li>
<li><a class="reference" href="#text2code" id="id21" name="id21">3.3&nbsp;&nbsp;&nbsp;Text2Code</a><ul class="auto-toc">
<li><a class="reference" href="#text2code-header" id="id22" name="id22">3.3.1&nbsp;&nbsp;&nbsp;Text2Code.header</a></li>
<li><a class="reference" href="#text2code-text-handler-generator" id="id23" name="id23">3.3.2&nbsp;&nbsp;&nbsp;Text2Code.text_handler_generator</a></li>
<li><a class="reference" href="#text2code-code-handler-generator" id="id24" name="id24">3.3.3&nbsp;&nbsp;&nbsp;Text2Code.code_handler_generator</a></li>
<li><a class="reference" href="#txt2code-remove-literal-marker" id="id25" name="id25">3.3.4&nbsp;&nbsp;&nbsp;Txt2Code.remove_literal_marker</a></li>
<li><a class="reference" href="#text2code-iter-strip" id="id26" name="id26">3.3.5&nbsp;&nbsp;&nbsp;Text2Code.iter_strip</a></li>
</ul>
</li>
<li><a class="reference" href="#code2text" id="id27" name="id27">3.4&nbsp;&nbsp;&nbsp;Code2Text</a><ul class="auto-toc">
<li><a class="reference" href="#code2text-iter" id="id28" name="id28">3.4.1&nbsp;&nbsp;&nbsp;Code2Text.__iter__</a></li>
<li><a class="reference" href="#header-state" id="id29" name="id29">3.4.2&nbsp;&nbsp;&nbsp;&quot;header&quot; state</a></li>
<li><a class="reference" href="#code2text-text" id="id30" name="id30">3.4.3&nbsp;&nbsp;&nbsp;Code2Text.text</a></li>
<li><a class="reference" href="#code2text-code" id="id31" name="id31">3.4.4&nbsp;&nbsp;&nbsp;Code2Text.code</a></li>
<li><a class="reference" href="#code2text-block-is-text" id="id32" name="id32">3.4.5&nbsp;&nbsp;&nbsp;Code2Text.block_is_text</a></li>
<li><a class="reference" href="#code2text-strip-literal-marker" id="id33" name="id33">3.4.6&nbsp;&nbsp;&nbsp;Code2Text.strip_literal_marker</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#command-line-use" id="id34" name="id34">4&nbsp;&nbsp;&nbsp;Command line use</a><ul class="auto-toc">
<li><a class="reference" href="#dual-source-handling" id="id35" name="id35">4.1&nbsp;&nbsp;&nbsp;Dual source handling</a><ul class="auto-toc">
<li><a class="reference" href="#how-to-determine-which-source-is-up-to-date" id="id36" name="id36">4.1.1&nbsp;&nbsp;&nbsp;How to determine which source is up-to-date?</a></li>
<li><a class="reference" href="#recognised-filename-extensions" id="id37" name="id37">4.1.2&nbsp;&nbsp;&nbsp;Recognised Filename Extensions</a></li>
</ul>
</li>
<li><a class="reference" href="#optionvalues" id="id38" name="id38">4.2&nbsp;&nbsp;&nbsp;OptionValues</a></li>
<li><a class="reference" href="#pylitoptions" id="id39" name="id39">4.3&nbsp;&nbsp;&nbsp;PylitOptions</a><ul class="auto-toc">
<li><a class="reference" href="#id5" id="id40" name="id40">4.3.1&nbsp;&nbsp;&nbsp;Instantiation</a></li>
<li><a class="reference" href="#calling" id="id41" name="id41">4.3.2&nbsp;&nbsp;&nbsp;Calling</a></li>
<li><a class="reference" href="#pylitoptions-parse-args" id="id42" name="id42">4.3.3&nbsp;&nbsp;&nbsp;PylitOptions.parse_args</a></li>
<li><a class="reference" href="#pylitoptions-complete-values" id="id43" name="id43">4.3.4&nbsp;&nbsp;&nbsp;PylitOptions.complete_values</a></li>
<li><a class="reference" href="#pylitoptions-get-outfile-name" id="id44" name="id44">4.3.5&nbsp;&nbsp;&nbsp;PylitOptions.get_outfile_name</a></li>
</ul>
</li>
<li><a class="reference" href="#helper-functions" id="id45" name="id45">4.4&nbsp;&nbsp;&nbsp;Helper functions</a><ul class="auto-toc">
<li><a class="reference" href="#open-streams" id="id46" name="id46">4.4.1&nbsp;&nbsp;&nbsp;open_streams</a></li>
<li><a class="reference" href="#is-newer" id="id47" name="id47">4.4.2&nbsp;&nbsp;&nbsp;is_newer</a></li>
<li><a class="reference" href="#get-converter" id="id48" name="id48">4.4.3&nbsp;&nbsp;&nbsp;get_converter</a></li>
</ul>
</li>
<li><a class="reference" href="#use-cases" id="id49" name="id49">4.5&nbsp;&nbsp;&nbsp;Use cases</a><ul class="auto-toc">
<li><a class="reference" href="#run-doctest" id="id50" name="id50">4.5.1&nbsp;&nbsp;&nbsp;run_doctest</a></li>
<li><a class="reference" href="#diff" id="id51" name="id51">4.5.2&nbsp;&nbsp;&nbsp;diff</a></li>
</ul>
</li>
<li><a class="reference" href="#main" id="id52" name="id52">4.6&nbsp;&nbsp;&nbsp;main</a><ul class="auto-toc">
<li><a class="reference" href="#id6" id="id53" name="id53">4.6.1&nbsp;&nbsp;&nbsp;Customization</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#open-questions" id="id54" name="id54">5&nbsp;&nbsp;&nbsp;Open questions</a><ul class="auto-toc">
<li><a class="reference" href="#options" id="id55" name="id55">5.1&nbsp;&nbsp;&nbsp;Options</a></li>
<li><a class="reference" href="#parsing-problems" id="id56" name="id56">5.2&nbsp;&nbsp;&nbsp;Parsing Problems</a></li>
<li><a class="reference" href="#code-syntax-highlight" id="id57" name="id57">5.3&nbsp;&nbsp;&nbsp;code syntax highlight</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id8" id="frontmatter" name="frontmatter">1&nbsp;&nbsp;&nbsp;Frontmatter</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id9" id="changelog" name="changelog">1.1&nbsp;&nbsp;&nbsp;Changelog</a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">2005-06-29:</th><td class="field-body">Initial version</td>
</tr>
<tr class="field"><th class="field-name">2005-06-30:</th><td class="field-body">first literate version of the script</td>
</tr>
<tr class="field"><th class="field-name">2005-07-01:</th><td class="field-body">object orientated script using generators</td>
</tr>
<tr class="field"><th class="field-name">2005-07-10:</th><td class="field-body">Two state machine (later added 'header' state)</td>
</tr>
<tr class="field"><th class="field-name">2006-12-04:</th><td class="field-body">Start of work on version 0.2 (code restructuring)</td>
</tr>
<tr class="field"><th class="field-name">2007-01-23:</th><td class="field-body">0.2   published at <a class="reference" href="http://pylit.berlios.de">http://pylit.berlios.de</a></td>
</tr>
<tr class="field"><th class="field-name">2007-01-25:</th><td class="field-body">0.2.1 Outsourced non-core documentation to the PyLit pages.</td>
</tr>
<tr class="field"><th class="field-name">2007-01-26:</th><td class="field-body">0.2.2 new behaviour of <cite>diff</cite> function</td>
</tr>
<tr class="field"><th class="field-name">2007-01-29:</th><td class="field-body">0.2.3 new <cite>header</cite> methods after suggestion by Riccardo Murri</td>
</tr>
<tr class="field"><th class="field-name">2007-01-31:</th><td class="field-body">0.2.4 raise Error if code indent is too small</td>
</tr>
<tr class="field"><th class="field-name">2007-02-05:</th><td class="field-body">0.2.5 new command line option --comment-string</td>
</tr>
<tr class="field"><th class="field-name">2007-02-09:</th><td class="field-body">0.2.6 add section with open questions,
Code2Text: let only blank lines (no comment str)
separate text and code,
fix <cite>Code2Text.header</cite></td>
</tr>
<tr class="field"><th class="field-name">2007-02-19:</th><td class="field-body">0.2.7 simplify <cite>Code2Text.header,</cite>
new <cite>iter_strip</cite> method replacing a lot of <tt class="docutils literal"><span class="pre">if</span></tt>-s</td>
</tr>
<tr class="field"><th class="field-name">2007-02-22:</th><td class="field-body">0.2.8 set <cite>mtime</cite> of outfile to the one of infile</td>
</tr>
<tr class="field"><th class="field-name">2007-02-27:</th><td class="field-body">0.3   new <cite>Code2Text</cite> converter after an idea by Riccardo Murri
a new <cite>Text2Code</cite> will follow soon
explicite <cite>option_defaults</cite> dict for easier customization</td>
</tr>
</tbody>
</table>
<pre class="literal-block">
&quot;&quot;&quot;pylit: Literate programming with Python and reStructuredText

   PyLit is a bidirectional converter between

   * a (reStructured) text source with embedded code, and
   * a code source with embedded text blocks (comments)
&quot;&quot;&quot;

__docformat__ = 'restructuredtext'

_version = &quot;0.3&quot;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id10" id="requirements" name="requirements">1.2&nbsp;&nbsp;&nbsp;Requirements</a></h2>
<ul class="simple">
<li>library modules</li>
</ul>
<pre class="literal-block">
import re
import os
import sys
import optparse
</pre>
<ul class="simple">
<li>non-standard extensions</li>
</ul>
<pre class="literal-block">
from simplestates import SimpleStates  # generic state machine
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id11" id="customization" name="customization">2&nbsp;&nbsp;&nbsp;Customization</a></h1>
<pre class="literal-block">
option_defaults = {}
</pre>
<p>Default language and language specific defaults:</p>
<pre class="literal-block">
option_defaults[&quot;language&quot;] =        &quot;python&quot;
option_defaults[&quot;comment_strings&quot;] = {&quot;python&quot;: '# ',
                                      &quot;slang&quot;:  '% ',
                                      &quot;c++&quot;:    '// ',
                                      &quot;elisp&quot;:  ';; '}
</pre>
<p>Recognized file extensions for text and code versions of the source.
Used to guess the language from the filename.</p>
<pre class="literal-block">
option_defaults[&quot;code_languages&quot;]  = {&quot;.py&quot;: &quot;python&quot;,
                                      &quot;.sl&quot;: &quot;slang&quot;,
                                      &quot;.c&quot;: &quot;c++&quot;,
                                      &quot;.el&quot;:&quot;elisp&quot;}
option_defaults[&quot;code_extensions&quot;] = option_defaults[&quot;code_languages&quot;].keys()
option_defaults[&quot;text_extensions&quot;] = [&quot;.txt&quot;]
</pre>
<p>Number of spaces to indent code blocks in the code -&gt; text conversion.[#]_</p>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="id1">[2]</a></td><td>For the text -&gt; code conversion, the codeindent is determined by the
first recognized code line (leading comment or first indented literal
block of the text source).</td></tr>
</tbody>
</table>
<pre class="literal-block">
option_defaults[&quot;codeindent&quot;] =  2
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id12" id="classes" name="classes">3&nbsp;&nbsp;&nbsp;Classes</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id13" id="pushiterator" name="pushiterator">3.1&nbsp;&nbsp;&nbsp;PushIterator</a></h2>
<p>The PushIterator is a minimal implementation of an iterator with
backtracking from the <a class="reference" href="http://www.interlink.com.au/anthony/tech/talks/OSCON2005/effective_r27.pdf">Effective Python Programming</a> OSCON 2005 tutorial by
Anthony&nbsp;Baxter. As the definition is small, it is inlined now. For the full
reasoning and documentation see <a class="reference" href="iterqueue.py.html">iterqueue.py</a>.</p>
<pre class="literal-block">
class PushIterator(object):
    def __init__(self, iterable):
        self.it = iter(iterable)
        self.cache = []
    def __iter__(self):
        &quot;&quot;&quot;Return `self`, as this is already an iterator&quot;&quot;&quot;
        return self
    def next(self):
        return (self.cache and self.cache.pop()) or self.it.next()
    def push(self, value):
        self.cache.append(value)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id14" id="converter" name="converter">3.2&nbsp;&nbsp;&nbsp;Converter</a></h2>
<p>The converter classes implement a simple <cite>state machine</cite> to separate and
transform text and code blocks. For this task, only a very limited parsing
is needed.  Using the full blown <a class="reference" href="http://docutils.sourceforge.net/">docutils</a> rst parser would introduce a
large overhead and slow down the conversion.</p>
<p>PyLit's simple parser assumes:</p>
<ul class="simple">
<li>indented literal blocks in a text source are code blocks.</li>
<li>comment lines that start with a matching comment string in a code source
are text blocks.</li>
</ul>
<p>The actual converter classes are derived from <cite>PyLitConverter</cite>:
<a class="reference" href="#text2code">Text2Code</a> converts a text source to executable code, while <a class="reference" href="#code2text">Code2Text</a>
does the opposite: converting commented code to a text source.</p>
<p>The <cite>PyLitConverter</cite> class inherits the state machine framework
(initalisation, scheduler, iterator interface, ...) from <cite>SimpleStates</cite>,
overrides the <tt class="docutils literal"><span class="pre">__init__</span></tt> method, and adds auxiliary methods and
configuration attributes (options).</p>
<pre class="literal-block">
class PyLitConverter(SimpleStates):
    &quot;&quot;&quot;parent class for `Text2Code` and `Code2Text`, the state machines
    converting between text source and code source of a literal program.
    &quot;&quot;&quot;
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id15" id="data-attributes" name="data-attributes">3.2.1&nbsp;&nbsp;&nbsp;Data attributes</a></h3>
<p>The data attributes are class default values. They will be overridden by
matching keyword arguments during class instantiation.</p>
<p><a class="reference" href="#get-converter">get_converter</a> and <a class="reference" href="#main">main</a> pass on unused keyword arguments to
the instantiation of a converter class. This way, keyword arguments
to these functions can be used to customize the converter.</p>
<p>Default language and language specific defaults:</p>
<pre class="literal-block">
language = option_defaults[&quot;language&quot;]
comment_strings = option_defaults[&quot;comment_strings&quot;]
</pre>
<p>Number of spaces to indent code blocks in the code -&gt; text conversion:</p>
<pre class="literal-block">
codeindent =  option_defaults[&quot;codeindent&quot;]
</pre>
<p>Marker string for the first code block. (Should be a valid rst directive
that accepts code on the same line, e.g. <tt class="docutils literal"><span class="pre">'..</span> <span class="pre">admonition::'</span></tt>.)  No
trailing whitespace needed as indented code follows. Default is a comment
marker:</p>
<pre class="literal-block">
header_string = '..'
</pre>
<p>Export to the output format stripping text or code blocks:</p>
<pre class="literal-block">
strip =           False
</pre>
<p>Initial state:</p>
<pre class="literal-block">
state = 'header'
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id16" id="instantiation" name="instantiation">3.2.2&nbsp;&nbsp;&nbsp;Instantiation</a></h3>
<p>Initializing sets up the <cite>data</cite> attribute, an iterable object yielding
lines of the source to convert.[1]_</p>
<pre class="literal-block">
def __init__(self, data, **keyw):
    &quot;&quot;&quot;data   --  iterable data object
                  (list, file, generator, string, ...)
       **keyw --  all remaining keyword arguments are
                  stored as class attributes
    &quot;&quot;&quot;
</pre>
<p>As the state handlers need backtracking, the data is wrapped in a
<a class="reference" href="#pushiterator">PushIterator</a> if it doesnot already have a <cite>push</cite> method:</p>
<pre class="literal-block">
if hasattr(data, 'push'):
    self.data = data
else:
    self.data = PushIterator(data)
self._textindent = 0
</pre>
<p>Additional keyword arguments are stored as data attributes, overwriting the
class defaults:</p>
<pre class="literal-block">
self.__dict__.update(keyw)
</pre>
<p>The comment string is set to the language's comment string if not given in
the keyword arguments:</p>
<pre class="literal-block">
if not hasattr(self, &quot;comment_string&quot;) or not self.comment_string:
    self.comment_string = self.comment_strings[self.language]
</pre>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="id2">[1]</a></td><td><p class="first">The most common choice of data is a <cite>file</cite> object with the text
or code source.</p>
<p class="last">To convert a string into a suitable object, use its splitlines method
with the optional <cite>keepends</cite> argument set to True.</p>
</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id17" id="converter-str" name="converter-str">3.2.3&nbsp;&nbsp;&nbsp;Converter.__str__</a></h3>
<p>Return converted data as string:</p>
<pre class="literal-block">
def __str__(self):
    blocks = [&quot;&quot;.join(block) for block in self()]
    return &quot;&quot;.join(blocks)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id18" id="converter-get-indent" name="converter-get-indent">3.2.4&nbsp;&nbsp;&nbsp;Converter.get_indent</a></h3>
<p>Return the number of leading spaces in <cite>string</cite> after expanding tabs</p>
<pre class="literal-block">
def get_indent(self, string):
    &quot;&quot;&quot;Return the indentation of `string`.
    &quot;&quot;&quot;
    line = string.expandtabs()
    return len(line) - len(line.lstrip())
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id19" id="converter-ensure-trailing-blank-line" name="converter-ensure-trailing-blank-line">3.2.5&nbsp;&nbsp;&nbsp;Converter.ensure_trailing_blank_line</a></h3>
<p>Ensure there is a blank line as last element of the list <cite>lines</cite>:</p>
<pre class="literal-block">
def ensure_trailing_blank_line(self, lines, next_line):
    if not lines:
        return
    if lines[-1].lstrip():
        sys.stderr.write(&quot;\nWarning: inserted blank line between\n %s %s&quot;
                         %(lines[-1], next_line))
        lines.append(&quot;\n&quot;)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id20" id="converter-collect-blocks" name="converter-collect-blocks">3.2.6&nbsp;&nbsp;&nbsp;Converter.collect_blocks</a></h3>
<pre class="literal-block">
def collect_blocks(self):
    &quot;&quot;&quot;collect lines in a list

    return list for each block of lines (paragraph) seperated by a
    blank line (whitespace only)
    &quot;&quot;&quot;
    block = []
    for line in self.data:
        block.append(line)
        if not line.rstrip():
            yield block
            block = []
    yield block
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id21" id="text2code" name="text2code">3.3&nbsp;&nbsp;&nbsp;Text2Code</a></h2>
<p>The <cite>Text2Code</cite> class separates code blocks (indented literal blocks) from
reStructured text. Code blocks are unindented, text is commented (or
filtered, if the <tt class="docutils literal"><span class="pre">strip</span></tt> option is True.</p>
<p>Only <cite>indented literal blocks</cite> are extracted. <cite>quoted literal blocks</cite> and
<cite>pydoc blocks</cite> are treated as text. This allows the easy inclusion of
examples: <a class="footnote-reference" href="#id1" id="id3" name="id3">[2]</a></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; 23 + 3
26
</pre>
</blockquote>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="id4">[3]</a></td><td>Mark that there is no double colon before the doctest block in
the text source.</td></tr>
</tbody>
</table>
<p>The state handlers are implemented as generators. Iterating over a
<cite>Text2Code</cite> instance initializes them to generate iterators for
the respective states (see <tt class="docutils literal"><span class="pre">simplestates.py</span></tt>).</p>
<pre class="literal-block">
class Text2Code(PyLitConverter):
    &quot;&quot;&quot;Convert a (reStructured) text source to code source
    &quot;&quot;&quot;
</pre>
<p>INIT: call the parent classes init method.</p>
<p>If the <cite>strip</cite> argument is true, replace the <cite>__iter_</cite> method
with a special one that drops &quot;spurious&quot; blocks:</p>
<pre class="literal-block">
def __init__(self, data, **keyw):
    PyLitConverter.__init__(self, data, **keyw)
    if getattr(self, &quot;strip&quot;, False):
        self.__iter__ = self.iter_strip
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id22" id="text2code-header" name="text2code-header">3.3.1&nbsp;&nbsp;&nbsp;Text2Code.header</a></h3>
<p>Convert the header (leading rst comment block) to code:</p>
<pre class="literal-block">
def header(self):
    &quot;&quot;&quot;Convert header (comment) to code&quot;&quot;&quot;
    line = self.data_iterator.next()
</pre>
<p>Test first line for rst comment: (We need to do this explicitely here, as
the code handler will only recognize the start of a text block if a line
starting with &quot;matching comment&quot; is preceded by an empty line. However, we
have to care for the case of the first line beeing a &quot;text line&quot;.</p>
<p>Which variant is better?</p>
<ol class="arabic">
<li><p class="first">starts with comment marker and has
something behind the comment on the first line:</p>
<pre class="literal-block">
# if line.startswith(&quot;..&quot;) and len(line.rstrip()) &gt; 2:
</pre>
</li>
<li><p class="first">Convert any leading comment to code:</p>
<pre class="literal-block">
if line.startswith(self.header_string):
</pre>
</li>
</ol>
<p>Strip leading comment string (typically added by <cite>Code2Text.header</cite>) and
return the result of processing the data with the code handler:</p>
<pre class="literal-block">
self.data_iterator.push(line.replace(self.header_string, &quot;&quot;, 1))
return self.code()
</pre>
<p>No header code found: Push back first non-header line and set state to
&quot;text&quot;:</p>
<pre class="literal-block">
self.data_iterator.push(line)
self.state = 'text'
return []
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id23" id="text2code-text-handler-generator" name="text2code-text-handler-generator">3.3.2&nbsp;&nbsp;&nbsp;Text2Code.text_handler_generator</a></h3>
<p>The 'text' handler processes everything that is not an indented literal
comment. Text is quoted with <cite>self.comment_string</cite> or filtered (with
strip=True).</p>
<p>It is implemented as a generator function that acts on the <cite>data</cite> iterator
and yields text blocks.</p>
<p>Declaration and initialization:</p>
<pre class="literal-block">
def text_handler_generator(self):
    &quot;&quot;&quot;Convert text blocks from rst to comment
    &quot;&quot;&quot;
    lines = []
</pre>
<p>Iterate over the data_iterator (which yields the data lines):</p>
<pre class="literal-block">
for line in self.data_iterator:
    # print &quot;Text: '%s'&quot;%line
</pre>
<p>Default action: add comment string and collect in <cite>lines</cite> list:</p>
<pre class="literal-block">
lines.append(self.comment_string + line)
</pre>
<p>Test for the end of the text block: a line that ends with <cite>::</cite> but is neither
a comment nor a directive:</p>
<pre class="literal-block">
if (line.rstrip().endswith(&quot;::&quot;)
    and not line.lstrip().startswith(&quot;..&quot;)):
</pre>
<p>End of text block is detected, now:</p>
<p>set the current text indent level (needed by the code handler to find the
end of code block) and set the state to &quot;code&quot; (i.e. the next call of
<cite>self.next</cite> goes to the code handler):</p>
<pre class="literal-block">
self._textindent = self.get_indent(line)
self.state = 'code'
</pre>
<p>Ensure a trailing blank line (which is the paragraph separator in
reStructured Text. Look at the next line, if it is blank -- OK, if it is
not blank, push it back (it should be code) and add a line by calling the
<cite>ensure_trailing_blank_line</cite> method (which also issues a warning):</p>
<pre class="literal-block">
line = self.data_iterator.next()
if line.lstrip():
    self.data_iterator.push(line) # push back
    self.ensure_trailing_blank_line(lines, line)
else:
    lines.append(line)
</pre>
<p>Now yield and reset the lines. (There was a function call to remove a
literal marker (if on a line on itself) to shorten the comment. However,
this behaviour was removed as the resulting difference in line numbers leads
to misleading error messages in doctests):</p>
<pre class="literal-block">
#remove_literal_marker(lines)
yield lines
lines = []
</pre>
<p>End of data: if we &quot;fall of&quot; the iteration loop, just join and return the
lines:</p>
<pre class="literal-block">
yield lines
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id24" id="text2code-code-handler-generator" name="text2code-code-handler-generator">3.3.3&nbsp;&nbsp;&nbsp;Text2Code.code_handler_generator</a></h3>
<p>The <cite>code</cite> handler is called when a literal block marker is encounterd. It
returns a code block (indented literal block), removing leading whitespace
up to the indentation of the first code line in the file (this deviation
from docutils behaviour allows indented blocks of Python code).</p>
<p>As the code handler detects the switch to &quot;text&quot; state by looking at
the line indents, it needs to push back the last probed data token. I.e.
the  data_iterator must support a <cite>push</cite> method. (This is the
reason for the use of the PushIterator class in <cite>__init__</cite>.)</p>
<pre class="literal-block">
def code_handler_generator(self):
    &quot;&quot;&quot;Convert indented literal blocks to source code
    &quot;&quot;&quot;
    lines = []
    codeindent = None  # indent of first non-blank code line, set below
    indent_string = &quot;&quot; # leading whitespace chars ...
</pre>
<p>Iterate over the lines in the input data:</p>
<pre class="literal-block">
for line in self.data_iterator:
    # print &quot;Code: '%s'&quot;%line
</pre>
<p>Pass on blank lines (no test for end of code block needed|possible):</p>
<pre class="literal-block">
if not line.rstrip():
    lines.append(line.replace(indent_string, &quot;&quot;, 1))
    continue
</pre>
<p>Test for end of code block:</p>
<p>A literal block ends with the first less indented, nonblank line.
<cite>self._textindent</cite> is set by the text handler to the indent of the
preceding paragraph.</p>
<p>To prevent problems with different tabulator settings, hard tabs in code
lines  are expanded with the <cite>expandtabs</cite> string method when calculating the
indentation (i.e. replaced by 8 spaces, by default).</p>
<pre class="literal-block">
if self.get_indent(line) &lt;= self._textindent:
    # push back line
    self.data_iterator.push(line)
    self.state = 'text'
    # append blank line (if not already present)
    self.ensure_trailing_blank_line(lines, line)
    yield lines
    # reset list of lines
    lines = []
    continue
</pre>
<p>OK, we are sure now that the current line is neither blank nor a text line.</p>
<p>If still unset, determine the code indentation from first non-blank code
line:</p>
<pre class="literal-block">
if codeindent is None and line.lstrip():
    codeindent = self.get_indent(line)
    indent_string = line[:codeindent]
</pre>
<p>Append unindented line to lines cache (but check if we can safely unindent
first):</p>
<pre class="literal-block">
if not line.startswith(indent_string):
    raise ValueError, &quot;cannot unindent line %r,\n&quot;%line \
    + &quot;  doesnot start with code indent string %r&quot;%indent_string

lines.append(line[codeindent:])
</pre>
<p>No more lines in the input data: just return what we have:</p>
<pre class="literal-block">
yield lines
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id25" id="txt2code-remove-literal-marker" name="txt2code-remove-literal-marker">3.3.4&nbsp;&nbsp;&nbsp;Txt2Code.remove_literal_marker</a></h3>
<p>Remove literal marker (::) in &quot;expanded form&quot; i.e. in a paragraph on its own.</p>
<p>While cleaning up the code source, it leads to confusion for doctest and
searches (e.g. grep) as line-numbers between text and code source will
differ.</p>
<pre class="literal-block">
def remove_literal_marker(list):
    try:
        # print lines[-3:]
        if (lines[-3].strip() == self.comment_string.strip()
            and lines[-2].strip() == self.comment_string + '::'):
            del(lines[-3:-1])
    except IndexError:
        pass
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id26" id="text2code-iter-strip" name="text2code-iter-strip">3.3.5&nbsp;&nbsp;&nbsp;Text2Code.iter_strip</a></h3>
<p>Modification of the <cite>simplestates.__iter__</cite> method that will replace it when
the <cite>strip</cite> keyword argument is <cite>True</cite> during class instantiation:</p>
<p>Iterate over class instances dropping text blocks:</p>
<pre class="literal-block">
def iter_strip(self):
    &quot;&quot;&quot;Generate and return an iterator dropping text blocks
    &quot;&quot;&quot;
    self.data_iterator = self.data
    self._initialize_state_generators()
    while True:
        yield getattr(self, self.state)()
        getattr(self, self.state)() # drop text block
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id27" id="code2text" name="code2text">3.4&nbsp;&nbsp;&nbsp;Code2Text</a></h2>
<p>The <cite>Code2Text</cite> class does the opposite of <a class="reference" href="#text2code">Text2Code</a> -- it processes
valid source code, extracts comments, and puts non-commented code in literal
blocks.</p>
<p>The class is derived from the PyLitConverter state machine and adds  an
<cite>__iter__</cite> method as well as handlers for &quot;text&quot;, and &quot;code&quot; states.</p>
<pre class="literal-block">
class Code2Text(PyLitConverter):
    &quot;&quot;&quot;Convert code source to text source
    &quot;&quot;&quot;
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id28" id="code2text-iter" name="code2text-iter">3.4.1&nbsp;&nbsp;&nbsp;Code2Text.__iter__</a></h3>
<pre class="literal-block">
def __iter__(self):
</pre>
<p>If the last text block doesnot end with a code marker (by default, the
literal-block marker <tt class="docutils literal"><span class="pre">::</span></tt>), the <cite>text</cite> method will set <cite>code marker</cite> to
a paragraph that will start the next code block. It is yielded if non-empty
at a text-code transition. If there is no preceding text block, <cite>code_marker</cite>
contains the  <cite>header_string</cite>:</p>
<pre class="literal-block">
if self.strip:
    self.code_marker = []
else:
    self.code_marker = [self.header_string]

for block in self.collect_blocks():
</pre>
<p>Test the state of the block with <a class="reference" href="#code2text-block-is-text">Code2Text.block_is_text</a>, return it
processed with the matching handler:</p>
<pre class="literal-block">
if self.block_is_text(block):
    self.state = &quot;text&quot;
else:
    if self.state != &quot;code&quot; and self.code_marker:
        yield self.code_marker
    self.state = &quot;code&quot;
yield getattr(self, self.state)(block)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id29" id="header-state" name="header-state">3.4.2&nbsp;&nbsp;&nbsp;&quot;header&quot; state</a></h3>
<p>Sometimes code needs to remain on the first line(s) of the document to be
valid. The most common example is the &quot;shebang&quot; line that tells a POSIX
shell how to process an executable file:</p>
<pre class="literal-block">
#!/usr/bin/env python
</pre>
<p>In Python, the <tt class="docutils literal"><span class="pre">#</span> <span class="pre">-*-</span> <span class="pre">coding:</span> <span class="pre">iso-8859-1</span> <span class="pre">-*-</span></tt> line must occure before any
other comment or code.</p>
<p>If we want to keep the line numbers in sync for text and code source, the
reStructured Text markup for these header lines must start at the same line
as the first header line. Therfore, header lines could not be marked as
literal block (this would require the <tt class="docutils literal"><span class="pre">::</span></tt> and an empty line above the code).</p>
<p>OTOH, a comment may start at the same line as the comment marker and it
includes subsequent indented lines. Comments are visible in the reStructured
Text source but hidden in the pretty-printed output.</p>
<p>With a header converted to comment in the text source, everything before the
first text block (i.e. before the first paragraph using the matching comment
string) will be hidden away (in HTML or PDF output).</p>
<p>This seems a good compromise, the advantages</p>
<ul class="simple">
<li>line numbers are kept</li>
<li>the &quot;normal&quot; code conversion rules (indent/unindent by <cite>codeindent</cite> apply</li>
<li>greater flexibility: you can hide a repeating header in a project
consisting of many source files.</li>
</ul>
<p>set off the disadvantages</p>
<ul class="simple">
<li>it may come as surprise if a part of the file is not &quot;printed&quot;,</li>
<li>one more syntax element to learn for rst newbees to start with pylit,
(however, starting from the code source, this will be auto-generated)</li>
</ul>
<p>In the case that there is no matching comment at all, the complete code
source will become a comment -- however, in this case it is not very likely
the source is a literate document anyway.</p>
<p>If needed for the documentation, it is possible to repeat the header in (or
after) the first text block, e.g. with a <cite>line block</cite> in a <cite>block quote</cite>:</p>
<blockquote>
<div class="line-block">
<div class="line"><tt class="docutils literal"><span class="pre">#!/usr/bin/env</span> <span class="pre">python</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">#</span> <span class="pre">-*-</span> <span class="pre">coding:</span> <span class="pre">iso-8859-1</span> <span class="pre">-*-</span></tt></div>
</div>
</blockquote>
<p>The current implementation represents the header state by the setting of
<cite>code_marker</cite> to <tt class="docutils literal"><span class="pre">[self.header_string]</span></tt>. The first non-empty text block
will overwrite this setting.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id30" id="code2text-text" name="code2text-text">3.4.3&nbsp;&nbsp;&nbsp;Code2Text.text</a></h3>
<p>The <em>text state handler</em> converts a comment to a text block by stripping
the leading <cite>comment string</cite> from every line:</p>
<pre class="literal-block">
def text(self, lines):
    &quot;&quot;&quot;Uncomment text blocks in source code
    &quot;&quot;&quot;

    lines = [line.replace(self.comment_string, &quot;&quot;, 1) for line in lines]

    lines = [re.sub(&quot;^&quot;+self.comment_string.rstrip(), &quot;&quot;, line)
             for line in lines]
</pre>
<p>If the code block is stripped, the literal marker would lead to an error
when the text is converted with docutils. Replace it with
<a class="reference" href="#code2text-strip-literal-marker">Code2Text.strip_literal_marker</a>:</p>
<pre class="literal-block">
if self.strip:
    self.strip_literal_marker(lines)
    self.code_marker = []
</pre>
<p>Check for code block marker (double colon) at the end of the text block
Update the <cite>code_marker</cite> argument. (The <cite>code marker</cite> is yielded by
<a class="reference" href="#code2text-iter">Code2Text.__iter__</a> at a text -&gt; code transition if it is not empty):</p>
<pre class="literal-block">
elif len(lines)&gt;1:
    if lines[-2].rstrip().endswith(&quot;::&quot;):
        self.code_marker = []
    else:
        self.code_marker = [&quot;::\n&quot;, &quot;\n&quot;]
</pre>
<p>Return the text block to the calling function:</p>
<pre class="literal-block">
return lines
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id31" id="code2text-code" name="code2text-code">3.4.4&nbsp;&nbsp;&nbsp;Code2Text.code</a></h3>
<p>The <cite>code</cite> method is called on non-commented code. Code is returned as
indented literal block (or filtered, if <tt class="docutils literal"><span class="pre">self.strip</span> <span class="pre">==</span> <span class="pre">True</span></tt>). The amount
of the code indentation is controled by <cite>self.codeindent</cite> (default 2).</p>
<pre class="literal-block">
def code(self, lines):
    &quot;&quot;&quot;Indent lines or strip if `strip` == `True`
    &quot;&quot;&quot;
    if self.strip == True:
        return []

    return [&quot; &quot;*self.codeindent + line for line in lines]
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id32" id="code2text-block-is-text" name="code2text-block-is-text">3.4.5&nbsp;&nbsp;&nbsp;Code2Text.block_is_text</a></h3>
<p>A paragraph is a text block, if every non-blank line starts with a matching
comment string  (test includes whitespace except for commented blank lines!)</p>
<pre class="literal-block">
def block_is_text(self, block):
    for line in block:
        if (line.rstrip()
            and not line.startswith(self.comment_string)
            and line.rstrip() != self.comment_string.rstrip()):
            return False
    return True
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id33" id="code2text-strip-literal-marker" name="code2text-strip-literal-marker">3.4.6&nbsp;&nbsp;&nbsp;Code2Text.strip_literal_marker</a></h3>
<p>Replace the literal marker with the equivalent of docutils replace rules</p>
<ul class="simple">
<li>strip <cite>::</cite>-line (and preceding blank line) if on a line on its own</li>
<li>strip <cite>::</cite> if it is preceded by whitespace.</li>
<li>convert <cite>::</cite> to a single colon if preceded by text</li>
</ul>
<p><cite>lines</cite> should be list of text lines (with a trailing blank line).
It is modified in-place:</p>
<pre class="literal-block">
def strip_literal_marker(self, lines):
    try:
        line = lines[-2]
    except IndexError:  # len(lines &lt; 2)
        return

    # split at rightmost '::'
    try:
        (head, tail) = line.rsplit('::', 1)
    except ValueError:  # only one part (no '::')
        return

    # '::' on an extra line
    if not head.strip():
        del(lines[-2])
        # delete preceding line if it is blank
        if len(lines) &gt;= 2 and not lines[-2].lstrip():
            del(lines[-2])
    # '::' follows whitespace
    elif head.rstrip() &lt; head:
        head = head.rstrip()
        lines[-2] = &quot;&quot;.join((head, tail))
    # '::' follows text
    else:
        lines[-2] = &quot;:&quot;.join((head, tail))
</pre>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id34" id="command-line-use" name="command-line-use">4&nbsp;&nbsp;&nbsp;Command line use</a></h1>
<p>Using this script from the command line will convert a file according to its
extension. This default can be overridden by a couple of options.</p>
<div class="section">
<h2><a class="toc-backref" href="#id35" id="dual-source-handling" name="dual-source-handling">4.1&nbsp;&nbsp;&nbsp;Dual source handling</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id36" id="how-to-determine-which-source-is-up-to-date" name="how-to-determine-which-source-is-up-to-date">4.1.1&nbsp;&nbsp;&nbsp;How to determine which source is up-to-date?</a></h3>
<ul>
<li><p class="first">set modification date of <cite>oufile</cite> to the one of <cite>infile</cite></p>
<p>Points out that the source files are 'synchronized'.</p>
<ul>
<li><p class="first">Are there problems to expect from &quot;backdating&quot; a file? Which?</p>
<p>Looking at <a class="reference" href="http://www.unix.com/showthread.php?t=20526">http://www.unix.com/showthread.php?t=20526</a>, it seems
perfectly legal to set <cite>mtime</cite> (while leaving <cite>ctime</cite>) as <cite>mtime</cite> is a
description of the &quot;actuality&quot; of the data in the file.</p>
</li>
<li><p class="first">Should this become a default or an option?</p>
</li>
</ul>
</li>
<li><p class="first">alternatively move input file to a backup copy (with option: <cite>--replace</cite>)</p>
</li>
<li><p class="first">check modification date before overwriting
(with option: <cite>--overwrite=update</cite>)</p>
</li>
<li><p class="first">check modification date before editing (implemented as <a class="reference" href="http://www.jedsoft.org/jed/">Jed editor</a>
function <cite>pylit_check()</cite> in <a class="reference" href="http://jedmodes.sourceforge.net/mode/pylit/">pylit.sl</a>)</p>
</li>
</ul>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id37" id="recognised-filename-extensions" name="recognised-filename-extensions">4.1.2&nbsp;&nbsp;&nbsp;Recognised Filename Extensions</a></h3>
<p>Finding an easy to remember, unused filename extension is not easy.</p>
<dl class="docutils">
<dt>.py.txt</dt>
<dd>a double extension (similar to .tar.gz, say) seems most appropriate
(at least on UNIX). However, it fails on FAT16 filesystems.
The same scheme can be used for c.txt, p.txt and the like.</dd>
<dt>.pytxt</dt>
<dd>is recognised as extension by os.path.splitext but also fails on FAT16</dd>
<dt>.pyt</dt>
<dd>(PYthon Text) is used by the Python test interpreter
<a class="reference" href="http:www.zetadev.com/software/pytest/">pytest</a></dd>
<dt>.pyl</dt>
<dd>was even mentioned as extension for &quot;literate Python&quot; files in an
email exchange (<a class="reference" href="http://www.python.org/tim_one/000115.html">http://www.python.org/tim_one/000115.html</a>) but
subsequently used for Python libraries.</dd>
<dt>.lpy</dt>
<dd>seems to be free (as by a Google search, &quot;lpy&quot; is the name of a python
code pretty printer but this should not pose a problem).</dd>
<dt>.tpy</dt>
<dd>seems to be free as well.</dd>
</dl>
<p>Instead of defining a new extension for &quot;pylit&quot; literate programms,
by default <tt class="docutils literal"><span class="pre">.txt</span></tt> will be appended for literate code and stripped by
the conversion to executable code. i.e. for a program foo:</p>
<ul class="simple">
<li>the literate source is called <tt class="docutils literal"><span class="pre">foo.py.txt</span></tt></li>
<li>the html rendering is called <tt class="docutils literal"><span class="pre">foo.py.html</span></tt></li>
<li>the python source is called <tt class="docutils literal"><span class="pre">foo.py</span></tt></li>
</ul>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id38" id="optionvalues" name="optionvalues">4.2&nbsp;&nbsp;&nbsp;OptionValues</a></h2>
<p>For use as keyword arguments, it is handy to have the options
in a dictionary. The following class adds an <cite>as_dict</cite> method
to  <cite>optparse.Values</cite>:</p>
<pre class="literal-block">
class OptionValues(optparse.Values):
    def as_dict(self):
        &quot;&quot;&quot;Return options as dictionary object&quot;&quot;&quot;
        return dict([(option, getattr(self, option)) for option in dir(self)
                     if option not in dir(OptionValues)
                     and option is not None
                    ])
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id39" id="pylitoptions" name="pylitoptions">4.3&nbsp;&nbsp;&nbsp;PylitOptions</a></h2>
<p>Options are stored in the values attribute of the <cite>PylitOptions</cite> class.
It is initialized with default values and parsed command line options (and
arguments)  This scheme allows easy customization by code importing the
<cite>pylit</cite> module.</p>
<pre class="literal-block">
class PylitOptions(object):
    &quot;&quot;&quot;Storage and handling of program options
    &quot;&quot;&quot;
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id40" id="id5" name="id5">4.3.1&nbsp;&nbsp;&nbsp;Instantiation</a></h3>
<p>Instantiation sets up an OptionParser and initializes it with pylit's
command line options and <cite>default_values</cite>. It then updates the values based
on command line options and sensible defaults:</p>
<pre class="literal-block">
def __init__(self, args=sys.argv[1:], **keyw):
    &quot;&quot;&quot;Set up an `OptionParser` instance and parse and complete arguments
    &quot;&quot;&quot;
    p = optparse.OptionParser(usage=main.__doc__, version=_version)
    # set defaults (from modules option_defaults dict and keyword args)
    defaults = dict(option_defaults) # copy module-level defaults
    defaults.update(keyw)
    p.set_defaults(**defaults)
    # add the options
    p.add_option(&quot;-c&quot;, &quot;--code2txt&quot;, dest=&quot;txt2code&quot;, action=&quot;store_false&quot;,
                 help=&quot;convert code to reStructured text&quot;)
    p.add_option(&quot;--comment-string&quot;, dest=&quot;comment_string&quot;,
                 help=&quot;text block marker (default '# ' (for Python))&quot; )
    p.add_option(&quot;-d&quot;, &quot;--diff&quot;, action=&quot;store_true&quot;,
                 help=&quot;test for differences to existing file&quot;)
    p.add_option(&quot;--doctest&quot;, action=&quot;store_true&quot;,
                 help=&quot;run doctest.testfile() on the text version&quot;)
    p.add_option(&quot;-e&quot;, &quot;--execute&quot;, action=&quot;store_true&quot;,
                 help=&quot;execute code (Python only)&quot;)
    p.add_option(&quot;-f&quot;, &quot;--infile&quot;,
                 help=&quot;input file name ('-' for stdout)&quot; )
    p.add_option(&quot;--language&quot;, action=&quot;store&quot;,
                 choices = option_defaults[&quot;code_languages&quot;].values(),
                 help=&quot;use LANGUAGE native comment style&quot;)
    p.add_option(&quot;--overwrite&quot;, action=&quot;store&quot;,
                 choices = [&quot;yes&quot;, &quot;update&quot;, &quot;no&quot;],
                 help=&quot;overwrite output file (default 'update')&quot;)
    p.add_option(&quot;-o&quot;, &quot;--outfile&quot;,
                 help=&quot;output file name ('-' for stdout)&quot; )
    p.add_option(&quot;--replace&quot;, action=&quot;store_true&quot;,
                 help=&quot;move infile to a backup copy (appending '~')&quot;)
    p.add_option(&quot;-s&quot;, &quot;--strip&quot;, action=&quot;store_true&quot;,
                 help=&quot;export by stripping text or code&quot;)
    p.add_option(&quot;-t&quot;, &quot;--txt2code&quot;, action=&quot;store_true&quot;,
                 help=&quot;convert reStructured text to code&quot;)
    self.parser = p

    # parse to fill a self.Values instance
    self.values = self.parse_args(args)
    # complete with context-sensitive defaults
    self.values = self.complete_values(self.values)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id41" id="calling" name="calling">4.3.2&nbsp;&nbsp;&nbsp;Calling</a></h3>
<p>&quot;Calling&quot; an instance updates the option values based on command line
arguments and default values and does a completion of the options based on
&quot;context-sensitive defaults&quot;:</p>
<pre class="literal-block">
def __call__(self, args=sys.argv[1:], **default_values):
    &quot;&quot;&quot;parse and complete command line args
    &quot;&quot;&quot;
    values = self.parse_args(args, **default_values)
    return self.complete_values(values)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id42" id="pylitoptions-parse-args" name="pylitoptions-parse-args">4.3.3&nbsp;&nbsp;&nbsp;PylitOptions.parse_args</a></h3>
<p>The <cite>parse_args</cite> method calls the <cite>optparse.OptionParser</cite> on command
line or provided args and returns the result as <cite>PylitOptions.Values</cite>
instance.  Defaults can be provided as keyword arguments:</p>
<pre class="literal-block">
def parse_args(self, args=sys.argv[1:], **default_values):
    &quot;&quot;&quot;parse command line arguments using `optparse.OptionParser`

       args           --  list of command line arguments.
       default_values --  dictionary of option defaults
    &quot;&quot;&quot;
    # update defaults
    defaults = self.parser.defaults.copy()
    defaults.update(default_values)
    # parse arguments
    (values, args) = self.parser.parse_args(args, OptionValues(defaults))
    # Convert FILE and OUTFILE positional args to option values
    # (other positional arguments are ignored)
    try:
        values.infile = args[0]
        values.outfile = args[1]
    except IndexError:
        pass
    return values
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id43" id="pylitoptions-complete-values" name="pylitoptions-complete-values">4.3.4&nbsp;&nbsp;&nbsp;PylitOptions.complete_values</a></h3>
<p>The <cite>complete</cite> method uses context information to set missing option values
to sensible defaults (if possible).</p>
<pre class="literal-block">
def complete_values(self, values):
    &quot;&quot;&quot;complete option values with context sensible defaults
    &quot;&quot;&quot;
    values.ensure_value(&quot;infile&quot;, &quot;&quot;)
    # Guess conversion direction from infile filename
    if values.ensure_value(&quot;txt2code&quot;, None) is None:
        in_extension = os.path.splitext(values.infile)[1]
        if in_extension in self.values.text_extensions:
            values.txt2code = True
        elif in_extension in self.values.code_extensions:
            values.txt2code = False
    # Auto-determine the output file name
    values.ensure_value(&quot;outfile&quot;, self.get_outfile_name(values.infile,
                                                         values.txt2code))
    # Guess conversion direction from outfile filename or set to default
    if values.txt2code is None:
        out_extension = os.path.splitext(values.outfile)[1]
        values.txt2code = not (out_extension in self.values.text_extensions)

    # Set the language of the code (default &quot;python&quot;)
    if values.txt2code is True:
        code_extension = os.path.splitext(values.outfile)[1]
    elif values.txt2code is False:
        code_extension = os.path.splitext(values.infile)[1]
    values.ensure_value(&quot;language&quot;,
                        self.values.code_languages.get(code_extension, &quot;python&quot;))
    # Set the default overwrite mode
    values.ensure_value(&quot;overwrite&quot;, 'update')

    return values
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id44" id="pylitoptions-get-outfile-name" name="pylitoptions-get-outfile-name">4.3.5&nbsp;&nbsp;&nbsp;PylitOptions.get_outfile_name</a></h3>
<p>Construct a matching filename for the output file. The output filename is
constructed from <cite>infile</cite> by the following rules:</p>
<ul class="simple">
<li>'-' (stdin) results in '-' (stdout)</li>
<li>strip the <cite>txt_extension</cite> or add the <cite>code_extension</cite> (txt2code)</li>
<li>add a <cite>txt_ extension</cite> (code2txt)</li>
<li>fallback: if no guess can be made, add &quot;.out&quot;</li>
</ul>
<pre class="literal-block">
def get_outfile_name(self, infile, txt2code=None):
    &quot;&quot;&quot;Return a matching output filename for `infile`
    &quot;&quot;&quot;
    # if input is stdin, default output is stdout
    if infile == '-':
        return '-'
    # Modify `infile`
    (base, ext) = os.path.splitext(infile)
    # TODO: should get_outfile_name() use self.values.outfile_extension
    #       if it exists?

    # strip text extension
    if ext in self.values.text_extensions:
        return base
    # add (first) text extension for code files
    if ext in self.values.code_extensions or txt2code == False:
        return infile + self.values.text_extensions[0]
    # give up
    return infile + &quot;.out&quot;
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id45" id="helper-functions" name="helper-functions">4.4&nbsp;&nbsp;&nbsp;Helper functions</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id46" id="open-streams" name="open-streams">4.4.1&nbsp;&nbsp;&nbsp;open_streams</a></h3>
<p>Return file objects for in- and output. If the input path is missing,
write usage and abort. (An alternative would be to use stdin as default.
However,  this leaves the uninitiated user with a non-responding application
if (s)he just tries the script without any arguments)</p>
<pre class="literal-block">
def open_streams(infile = '-', outfile = '-', overwrite='update', **keyw):
    &quot;&quot;&quot;Open and return the input and output stream

    open_streams(infile, outfile) -&gt; (in_stream, out_stream)

    in_stream   --  file(infile) or sys.stdin
    out_stream  --  file(outfile) or sys.stdout
    overwrite   --  ['yes', 'update', 'no']
                    if 'update', only open output file if it is older than
                    the input stream.
                    Irrelevant if outfile == '-'.
    &quot;&quot;&quot;
    if not infile:
        strerror = &quot;Missing input file name ('-' for stdin; -h for help)&quot;
        raise IOError, (2, strerror, infile)
    if infile == '-':
        in_stream = sys.stdin
    else:
        in_stream = file(infile, 'r')
    if outfile == '-':
        out_stream = sys.stdout
    elif overwrite == 'no' and os.path.exists(outfile):
        raise IOError, (1, &quot;Output file exists!&quot;, outfile)
    elif overwrite == 'update' and is_newer(outfile, infile):
        raise IOError, (1, &quot;Output file is newer than input file!&quot;, outfile)
    else:
        out_stream = file(outfile, 'w')
    return (in_stream, out_stream)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id47" id="is-newer" name="is-newer">4.4.2&nbsp;&nbsp;&nbsp;is_newer</a></h3>
<pre class="literal-block">
def is_newer(path1, path2):
    &quot;&quot;&quot;Check if `path1` is newer than `path2` (using mtime)

    Compare modification time of files at path1 and path2.

    Non-existing files are considered oldest: Return False if path1 doesnot
    exist and True if path2 doesnot exist.

    Return None for equal modification time. (This evaluates to False in a
    boolean context but allows a test for equality.)

    &quot;&quot;&quot;
    try:
        mtime1 = os.path.getmtime(path1)
    except OSError:
        mtime1 = -1
    try:
        mtime2 = os.path.getmtime(path2)
    except OSError:
        mtime2 = -1
    # print &quot;mtime1&quot;, mtime1, path1, &quot;\n&quot;, &quot;mtime2&quot;, mtime2, path2

    if mtime1 == mtime2:
        return None
    return mtime1 &gt; mtime2
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id48" id="get-converter" name="get-converter">4.4.3&nbsp;&nbsp;&nbsp;get_converter</a></h3>
<p>Get an instance of the converter state machine:</p>
<pre class="literal-block">
def get_converter(data, txt2code=True, **keyw):
    if txt2code:
        return Text2Code(data, **keyw)
    else:
        return Code2Text(data, **keyw)
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id49" id="use-cases" name="use-cases">4.5&nbsp;&nbsp;&nbsp;Use cases</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id50" id="run-doctest" name="run-doctest">4.5.1&nbsp;&nbsp;&nbsp;run_doctest</a></h3>
<pre class="literal-block">
def run_doctest(infile=&quot;-&quot;, txt2code=True,
                globs={}, verbose=False, optionflags=0, **keyw):
    &quot;&quot;&quot;run doctest on the text source
    &quot;&quot;&quot;
    from doctest import DocTestParser, DocTestRunner
    (data, out_stream) = open_streams(infile, &quot;-&quot;)
</pre>
<p>If source is code, convert to text, as tests in comments are not found by
doctest:</p>
<pre class="literal-block">
if txt2code is False:
    converter = Code2Text(data, **keyw)
    docstring = str(converter)
else:
    docstring = data.read()
</pre>
<p>Use the doctest Advanced API to do all doctests in a given string:</p>
<pre class="literal-block">
test = DocTestParser().get_doctest(docstring, globs={}, name=&quot;&quot;,
                                       filename=infile, lineno=0)
runner = DocTestRunner(verbose=verbose, optionflags=optionflags)
runner.run(test)
runner.summarize
if not runner.failures:
    print &quot;%d failures in %d tests&quot;%(runner.failures, runner.tries)
return runner.failures, runner.tries
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id51" id="diff" name="diff">4.5.2&nbsp;&nbsp;&nbsp;diff</a></h3>
<pre class="literal-block">
def diff(infile='-', outfile='-', txt2code=True, **keyw):
    &quot;&quot;&quot;Report differences between converted infile and existing outfile

    If outfile is '-', do a round-trip conversion and report differences
    &quot;&quot;&quot;

    import difflib

    instream = file(infile)
    # for diffing, we need a copy of the data as list::
    data = instream.readlines()
    # convert
    converter = get_converter(data, txt2code, **keyw)
    new = str(converter).splitlines(True)

    if outfile != '-':
        outstream = file(outfile)
        old = outstream.readlines()
        oldname = outfile
        newname = &quot;&lt;conversion of %s&gt;&quot;%infile
    else:
        old = data
        oldname = infile
        # back-convert the output data
        converter = get_converter(new, not txt2code)
        new = str(converter).splitlines(True)
        newname = &quot;&lt;round-conversion of %s&gt;&quot;%infile

    # find and print the differences
    delta = list(difflib.unified_diff(old, new, fromfile=oldname,
                                      tofile=newname))
    if not delta:
        print oldname
        print newname
        print &quot;no differences found&quot;
        return False
    print &quot;&quot;.join(delta)
    return True
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id52" id="main" name="main">4.6&nbsp;&nbsp;&nbsp;main</a></h2>
<p>If this script is called from the command line, the <cite>main</cite> function will
convert the input (file or stdin) between text and code formats.</p>
<div class="section">
<h3><a class="toc-backref" href="#id53" id="id6" name="id6">4.6.1&nbsp;&nbsp;&nbsp;Customization</a></h3>
<p>Option defaults for the conversion can be as keyword arguments to <a class="reference" href="#main">main</a>.
The option defaults will be updated by command line options and extended
with &quot;intelligent guesses&quot; by <cite>PylitOptions</cite> and passed on to helper
functions and the converter instantiation.</p>
<p>This allows easy customization for programmatic use -- just or call <cite>main</cite>
with the appropriate keyword options (or with a <cite>option_defaults</cite>
dictionary.), e.g.:</p>
<pre class="doctest-block">
&gt;&gt;&gt; option_defaults = {'language': &quot;c++&quot;,
...                    'codeindent': 4,
...                    'header_string': '..admonition::'
...                   }
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; main(**option_defaults)
</pre>
<pre class="literal-block">
def main(args=sys.argv[1:], **option_defaults):
    &quot;&quot;&quot;%prog [options] FILE [OUTFILE]

    Convert between reStructured Text with embedded code, and
    Source code with embedded text comment blocks&quot;&quot;&quot;
</pre>
<p>Parse and complete the options:</p>
<pre class="literal-block">
options = PylitOptions(args, **option_defaults).values
</pre>
<p>Run doctests if <tt class="docutils literal"><span class="pre">--doctest</span></tt> option is set:</p>
<pre class="literal-block">
if options.ensure_value(&quot;doctest&quot;, None):
    return run_doctest(**options.as_dict())
</pre>
<p>Do a round-trip and report differences if the <tt class="docutils literal"><span class="pre">--diff</span></tt> opton is set:</p>
<pre class="literal-block">
if options.ensure_value(&quot;diff&quot;, None):
    return diff(**options.as_dict())
</pre>
<p>Open in- and output streams:</p>
<pre class="literal-block">
try:
    (data, out_stream) = open_streams(**options.as_dict())
except IOError, ex:
    print &quot;IOError: %s %s&quot; % (ex.filename, ex.strerror)
    sys.exit(ex.errno)
</pre>
<p>Get a converter instance:</p>
<pre class="literal-block">
converter = get_converter(data, **options.as_dict())
</pre>
<p>Execute if the <tt class="docutils literal"><span class="pre">-execute</span></tt> option is set:</p>
<pre class="literal-block">
if options.ensure_value(&quot;execute&quot;, None):
    print &quot;executing &quot; + options.infile
    if options.txt2code:
        code = str(converter)
    else:
        code = data
    exec code
    return
</pre>
<p>Default action: Convert and write to out_stream:</p>
<pre class="literal-block">
out_stream.write(str(converter))

if out_stream is not sys.stdout:
    print &quot;extract written to&quot;, out_stream.name
    out_stream.close()
</pre>
<p>Rename the infile to a backup copy if <tt class="docutils literal"><span class="pre">--replace</span></tt> is set:</p>
<pre class="literal-block">
if options.ensure_value(&quot;replace&quot;, None):
    os.rename(options.infile, options.infile + &quot;~&quot;)
</pre>
<p>If not (and input and output are from files), set the modification time
(<cite>mtime</cite>) of the output file to the one of the input file to indicate that
the contained information is equal.[#]_</p>
<pre class="literal-block">
else:
    try:
        os.utime(options.outfile, (os.path.getatime(options.outfile),
                                   os.path.getmtime(options.infile))
                )
    except OSError:
        pass

## print &quot;mtime&quot;, os.path.getmtime(options.infile),  options.infile
## print &quot;mtime&quot;, os.path.getmtime(options.outfile), options.outfile
</pre>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="id7">[4]</a></td><td>Make sure the corresponding file object (here <cite>out_stream</cite>) is
closed, as otherwise the change will be overwritten when <cite>close</cite> is
called afterwards (either explicitely or at program exit).</td></tr>
</tbody>
</table>
<p>Run main, if called from the command line:</p>
<pre class="literal-block">
if __name__ == '__main__':
    main()
</pre>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id54" id="open-questions" name="open-questions">5&nbsp;&nbsp;&nbsp;Open questions</a></h1>
<p>Open questions and ideas for further development</p>
<div class="section">
<h2><a class="toc-backref" href="#id55" id="options" name="options">5.1&nbsp;&nbsp;&nbsp;Options</a></h2>
<ul>
<li><p class="first">Collect option defaults in a dictionary (on module level)</p>
<p>Facilitates the setting of options in programmatic use</p>
<p>Use templates for the &quot;intelligent guesses&quot; (with Python syntax for string
replacement with dicts: <tt class="docutils literal"><span class="pre">&quot;hello</span> <span class="pre">%(what)s&quot;</span> <span class="pre">%</span> <span class="pre">{'what':</span> <span class="pre">'world'}</span></tt>)</p>
</li>
<li><p class="first">Is it sensible to offer the <cite>header_string</cite> option also as command line
option?</p>
</li>
<li><p class="first">Configurable</p>
</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id56" id="parsing-problems" name="parsing-problems">5.2&nbsp;&nbsp;&nbsp;Parsing Problems</a></h2>
<ul>
<li><p class="first">How can I include a literal block that should not be in the
executable code (e.g. an example, an earlier version or variant)?</p>
<dl class="docutils">
<dt>Workaround:</dt>
<dd><p class="first">Use a <cite>quoted literal block</cite> (with a quotation different from
the comment string used for text blocks to keep it as commented over the
code-text round-trips.</p>
<p class="last">Python <cite>pydoc</cite> examples can also use the special pydoc block syntax (no
double colon!).</p>
</dd>
<dt>Alternative:</dt>
<dd><p class="first last">use a special &quot;code block&quot; directive or a special &quot;no code
block&quot; directive.</p>
</dd>
</dl>
</li>
<li><p class="first">ignore &quot;matching comments&quot; in literal strings?</p>
<p>(would need a specific detection algorithm for every language that
supports multi-line literal strings (C++, PHP, Python)</p>
</li>
<li><p class="first">Warn if a comment in code will become text after round-trip?</p>
</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id57" id="code-syntax-highlight" name="code-syntax-highlight">5.3&nbsp;&nbsp;&nbsp;code syntax highlight</a></h2>
<p>use <cite>listing</cite> package in LaTeX-&gt;PDF</p>
<p>in html, see</p>
<ul class="simple">
<li>the syntax highlight support in rest2web
(uses the Moin-Moin Python colorizer, see a version at
<a class="reference" href="http://www.standards-schmandards.com/2005/fangs-093/">http://www.standards-schmandards.com/2005/fangs-093/</a>)</li>
<li>Pygments (pure Python, many languages, rst integration recipe):
<a class="reference" href="http://pygments.org/docs/rstdirective/">http://pygments.org/docs/rstdirective/</a></li>
<li>Silvercity, enscript, ...</li>
</ul>
<p>Some plug-ins require a special &quot;code block&quot; directive instead of the
<cite>::</cite>-literal block. TODO: make this an option</p>
<p>Ask at docutils users|developers</p>
<ul class="simple">
<li>How to handle docstrings in code blocks? (it would be nice to convert them
to rst-text if <tt class="docutils literal"><span class="pre">__docformat__</span> <span class="pre">==</span> <span class="pre">restructuredtext</span></tt>)</li>
</ul>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2007-03-02.

</div>
</body>
</html>
