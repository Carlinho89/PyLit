<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title></title>
<link rel="stylesheet" href="/usr/lib/python2.4/site-packages/docutils/writers/html4css1/html4css1.css" type="text/css" />
</head>
<body>
<div class="document">
<!-- #!/usr/bin/env python
# -*- coding: iso-8859-1 -*- -->
<div class="section">
<h1><a class="toc-backref" href="#id3" id="test-the-pylit-py-literal-python-module" name="test-the-pylit-py-literal-python-module">Test the pylit.py literal python module</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Version:</th><td class="field-body">0.2</td>
</tr>
<tr class="field"><th class="field-name">Date:</th><td class="field-body">2005-09-02</td>
</tr>
<tr class="field"><th class="field-name">Copyright:</th><td class="field-body">2006 Guenter Milde.
Released under the terms of the GNU General Public License
(v. 2 or later)</td>
</tr>
</tbody>
</table>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#test-the-pylit-py-literal-python-module" id="id3" name="id3">Test the pylit.py literal python module</a></li>
<li><a class="reference" href="#text-code-conversion" id="id4" name="id4">Text &lt;-&gt; Code conversion</a><ul>
<li><a class="reference" href="#test-strings" id="id5" name="id5">Test strings</a></li>
<li><a class="reference" href="#text2code" id="id6" name="id6">Text2Code</a><ul>
<li><a class="reference" href="#special-cases" id="id7" name="id7">Special Cases</a><ul>
<li><a class="reference" href="#code-follows-text-block-without-blank-line" id="id8" name="id8">Code follows text block without blank line</a></li>
<li><a class="reference" href="#text-follows-code-block-without-blank-line" id="id9" name="id9">Text follows code block without blank line</a></li>
<li><a class="reference" href="#a-double-colon-on-a-line-on-its-own" id="id10" name="id10">A double colon on a line on its own</a></li>
<li><a class="reference" href="#header-samples" id="id11" name="id11">header samples</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#code2text" id="id12" name="id12">Code2Text</a><ul>
<li><a class="reference" href="#id1" id="id13" name="id13">Special cases</a><ul>
<li><a class="reference" href="#blank-comment-line" id="id14" name="id14">blank comment line</a></li>
<li><a class="reference" href="#no-blank-line-after-text" id="id15" name="id15">No blank line after text</a></li>
<li><a class="reference" href="#missing-literal-block-marker" id="id16" name="id16">missing literal block marker</a></li>
<li><a class="reference" href="#id2" id="id17" name="id17">header samples</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#global-defaults" id="id18" name="id18">Global defaults</a></li>
<li><a class="reference" href="#command-line-use" id="id19" name="id19">Command line use</a><ul>
<li><a class="reference" href="#input-and-output-streams" id="id20" name="id20">Input and Output streams</a></li>
</ul>
</li>
</ul>
</div>
<pre class="literal-block">
&quot;&quot;&quot;pylit_test.py: test the &quot;literal python&quot; module&quot;&quot;&quot;

from pprint import pprint
from pylit import *
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id4" id="text-code-conversion" name="text-code-conversion">Text &lt;-&gt; Code conversion</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id5" id="test-strings" name="test-strings">Test strings</a></h2>
<p>Example of text, code and stripped code with typical features&quot;:</p>
<pre class="literal-block">
text = &quot;&quot;&quot;..  #!/usr/bin/env python
  # -*- coding: iso-8859-1 -*-

Leading text

in several paragraphs followed by a literal block::

  block1 = 'first block'

Some more text and the next block. ::

  block2 = 'second block'
  print block1, block2

Trailing text.
&quot;&quot;&quot;
# print text
</pre>
<p>The converter expects the data in separate lines (iterator or list)
with trailing newlines. We use the <cite>splitlines</cite> string method with
<cite>keepends=True</cite>:</p>
<pre class="literal-block">
textdata = text.splitlines(True)
# print textdata
</pre>
<p>If a &quot;code source&quot; is converted with the <cite>strip</cite> option, only text blocks
are extracted, which leads to:</p>
<pre class="literal-block">
stripped_text = &quot;&quot;&quot;Leading text

in several paragraphs followed by a literal block:

Some more text and the next block.

Trailing text.
&quot;&quot;&quot;
</pre>
<p>The code corresponding to the text test string.</p>
<p>Using a triple-quoted string for the code (and stripped_code) can create
problems with the conversion of this test by pylit (as the text parts
would be converted to text). This is catered for by using a different
comment string for the text blocks in this file: convert to text with
<tt class="docutils literal"><span class="pre">pylit</span> <span class="pre">--comment-string='##</span> <span class="pre">'</span> <span class="pre">pylit_test.py</span></tt>:</p>
<pre class="literal-block">
code = &quot;&quot;&quot;#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

# Leading text
#
# in several paragraphs followed by a literal block::

block1 = 'first block'

# Some more text and the next block. ::

block2 = 'second block'
print block1, block2

# Trailing text.
&quot;&quot;&quot;
# print code

codedata = code.splitlines(True)
</pre>
<p>Converting the text teststring with the <cite>strip</cite> option leads to:</p>
<pre class="literal-block">
stripped_code = &quot;&quot;&quot;#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

block1 = 'first block'

block2 = 'second block'
print block1, block2

&quot;&quot;&quot;
</pre>
<p>pprint(textdata)
pprint(stripped_code.splitlines(True))</p>
<p>Containers for special case examples:</p>
<p>1. Text2Code samples
<tt class="docutils literal"><span class="pre">textsamples[&quot;what&quot;]</span> <span class="pre">=</span> <span class="pre">(&lt;text</span> <span class="pre">data&gt;,</span> <span class="pre">&lt;output&gt;,</span> <span class="pre">&lt;output</span> <span class="pre">(with</span> <span class="pre">`strip`)</span></tt></p>
<pre class="literal-block">
textsamples = {}
</pre>
<p>2. Code2Text samples
<tt class="docutils literal"><span class="pre">codesamples[&quot;what&quot;]</span> <span class="pre">=</span> <span class="pre">(&lt;code</span> <span class="pre">data&gt;,</span> <span class="pre">&lt;output&gt;,</span> <span class="pre">&lt;output</span> <span class="pre">(with</span> <span class="pre">`strip`)</span></tt></p>
<pre class="literal-block">
codesamples = {}
</pre>
<p>Auxiliary function to test the textsamples and codesamples:</p>
<pre class="literal-block">
def check_converter(key, converter, output):
    print &quot;E:&quot;, key
    extract = converter()
    pprint(extract)
    outstr = &quot;&quot;.join([&quot;&quot;.join(block) for block in extract])
    print &quot;soll:&quot;, repr(output)
    print &quot;ist: &quot;, repr(outstr)
    assert output == outstr
</pre>
<p>Test generator for textsample tests:</p>
<pre class="literal-block">
def test_Text2Code_samples():
    for key, sample in textsamples.iteritems():
        yield (check_converter, key,
               Text2Code(sample[0].splitlines(True)), sample[1])
        if len(sample) == 3:
            yield (check_converter, key,
                   Text2Code(sample[0].splitlines(True), strip=True),
                   sample[2])
</pre>
<p>Test generator for codesample tests:</p>
<pre class="literal-block">
def test_Code2Text_samples():
    for key, sample in codesamples.iteritems():
        yield (check_converter, key,
               Code2Text(sample[0].splitlines(True)), sample[1])
        if len(sample) == 3:
            yield (check_converter, key,
                   Code2Text(sample[0].splitlines(True), strip=True),
                   sample[2])
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id6" id="text2code" name="text2code">Text2Code</a></h2>
<p>base tests on the &quot;long&quot; test data</p>
<pre class="literal-block">
def test_Text2Code():
    &quot;&quot;&quot;Test the Text2Code class converting rst-&gt;code&quot;&quot;&quot;
    outstr = str(Text2Code(textdata))
    print code,
    print outstr
    assert code == outstr

def test_Text2Code_strip():
    &quot;&quot;&quot;strip=True should strip text parts&quot;&quot;&quot;
    outstr = str(Text2Code(textdata, strip=True))
    print &quot;ist &quot;, repr(outstr)
    print &quot;soll&quot;, repr(stripped_code)
    # pprint(outstr)
    assert stripped_code == outstr

def test_Text2Code_malindented_code_line():
    &quot;&quot;&quot;raise error if code line is less indented than code-indent&quot;&quot;&quot;
    data1 = [&quot;..    #!/usr/bin/env python\n&quot;, # indent == 4 * &quot; &quot;
            &quot;\n&quot;,
            &quot;  print 'hello world'&quot;]          # indent == 2 * &quot; &quot;
    data2 = [&quot;..\t#!/usr/bin/env python\n&quot;,   # indent == 8 * &quot; &quot;
            &quot;\n&quot;,
            &quot;  print 'hello world'&quot;]          # indent == 2 * &quot; &quot;
    for data in (data1, data2):
        try:
            blocks = Text2Code(data)()
            assert False, &quot;wrong indent did not raise ValueError&quot;
        except ValueError:
            pass
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id7" id="special-cases" name="special-cases">Special Cases</a></h3>
<div class="section">
<h4><a class="toc-backref" href="#id8" id="code-follows-text-block-without-blank-line" name="code-follows-text-block-without-blank-line">Code follows text block without blank line</a></h4>
<p>End of text block detected ('::') but no paragraph separator (blank line)
follows</p>
<p>It is an reStructuredText syntax error, if a &quot;literal block
marker&quot; is not followed by a blank line.</p>
<p>Assuming that no double colon at end of line occures accidentially,
pylit will fix this and issue a warning:</p>
<pre class="literal-block">
# Do we need this feature? (Complicates code a lot)
# textsamples[&quot;ensure blank line after text&quot;] = (
# &quot;&quot;&quot;text followed by a literal block::
#   block1 = 'first block'
# &quot;&quot;&quot;,
# &quot;&quot;&quot;# text followed by a literal block::
#
# block1 = 'first block'
# &quot;&quot;&quot;)
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id9" id="text-follows-code-block-without-blank-line" name="text-follows-code-block-without-blank-line">Text follows code block without blank line</a></h4>
<p>End of code block detected (a line not more indented than the preceding text
block)</p>
<p>reStructuredText syntax demands a paragraph separator (blank line) before
it.</p>
<p>Assuming that the unindent is not accidential, pylit fixes this and issues a
warning:</p>
<pre class="literal-block">
# Do we need this feature? (Complicates code a lot)
# textsamples[&quot;ensure blank line after code&quot;] = (
# &quot;&quot;&quot;::
#
#   block1 = 'first block'
# more text
# &quot;&quot;&quot;,
# &quot;&quot;&quot;# ::
#
# block1 = 'first block'

# more text
# &quot;&quot;&quot;)
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id10" id="a-double-colon-on-a-line-on-its-own" name="a-double-colon-on-a-line-on-its-own">A double colon on a line on its own</a></h4>
<p>As a double colon is added by the Code2Text conversion after a text block
(if not already present), it could be removed by the Text2Code conversion
to keep the source small and pretty.</p>
<p>However, this would put the text and code source line numbers out of sync,
which is bad for error reporting, failing doctests, and the <cite>pylit_buffer()</cite>
function in <a class="reference" href="http://jedmodes.sf.net/mode/pylit.sl">http://jedmodes.sf.net/mode/pylit.sl</a></p>
<pre class="literal-block">
# textsamples[&quot;remove single double colon&quot;] = (
#    [&quot;text followed by a literal block\n&quot;,
#     &quot;\n&quot;,
#     &quot;::\n&quot;,
#     &quot;\n&quot;,
#     &quot;  foo = 'first'\n&quot;]
#    [&quot;&quot;, # empty header
#     &quot;# text followed by a literal block\n\n&quot;,
#     &quot;foo = 'first'\n&quot;]
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id11" id="header-samples" name="header-samples">header samples</a></h4>
<p>Convert a leading reStructured text comment  (variant: only if there is
content on the first line) to a leading code block.  Return an empty list,
if there is no header.</p>
<pre class="literal-block">
textsamples[&quot;simple header&quot;] = (&quot;..  print 'hello world'&quot;,
                                &quot;print 'hello world'&quot;)

textsamples[&quot;no header (start with text)&quot;] = (
&quot;&quot;&quot;a classical example without header::

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;# a classical example without header::

print 'hello world'
&quot;&quot;&quot;)

textsamples[&quot;standard header, followed by text&quot;] = (
&quot;&quot;&quot;..  #!/usr/bin/env python
  # -*- coding: iso-8859-1 -*-

a classical example with header::

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

# a classical example with header::

print 'hello world'
&quot;&quot;&quot;)

textsamples[&quot;standard header, followed by code&quot;] = (
&quot;&quot;&quot;..  #!/usr/bin/env python

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;#!/usr/bin/env python

print 'hello world'
&quot;&quot;&quot;)
</pre>
</div>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id12" id="code2text" name="code2text">Code2Text</a></h2>
<pre class="literal-block">
class test_Code2Text(object):

    def setUp(self):
        self.converter = Code2Text(codedata)
</pre>
<p>Code2Text.strip_literal_marker</p>
<ul class="simple">
<li>strip <cite>::</cite>-line as well as preceding blank line if on a line on its own</li>
<li>strip <cite>::</cite> if it is preceded by whitespace.</li>
<li>convert <cite>::</cite> to a single colon if preceded by text</li>
</ul>
<pre class="literal-block">
def test_strip_literal_marker(self):
    samples = ((&quot;text\n\n::\n\n&quot;, &quot;text\n\n&quot;),
               (&quot;text\n::\n\n&quot;, &quot;text\n\n&quot;),
               (&quot;text ::\n\n&quot;, &quot;text\n\n&quot;),
               (&quot;text::\n\n&quot;, &quot;text:\n\n&quot;),
               (&quot;text:\n\n&quot;, &quot;text:\n\n&quot;),
               (&quot;text\n\n&quot;, &quot;text\n\n&quot;),
               (&quot;text\n&quot;, &quot;text\n&quot;)
               )
    for (ist, soll) in samples:
        ist = ist.splitlines(True)
        soll = soll.splitlines(True)
        print &quot;before&quot;, ist
        self.converter.strip_literal_marker(ist)
        print &quot;soll:&quot;, repr(soll)
        print &quot;ist: &quot;, repr(ist)
        assert ist == soll
</pre>
<p>Code2Text.normalize_line</p>
<pre class="literal-block">
# Missing whitespace in the `comment_string` is not significant for otherwise
# blank lines. Add it::

    def test_block_is_text(self):
        samples = (([&quot;code\n&quot;], False),
                   ([&quot;#code\n&quot;], False),
                   ([&quot;## code\n&quot;], False),
                   ([&quot;# text\n&quot;], True),
                   ([&quot;#  text\n&quot;], True),
                   ([&quot;# \n&quot;], True),
                   ([&quot;#\n&quot;], True),
                   ([&quot;\n&quot;], True))
        for (line, soll) in samples:
            result = self.converter.block_is_text(line)
            print repr(line), &quot;soll&quot;, soll, &quot;result&quot;, result
            assert result == soll
</pre>
<p>base tests on the &quot;long&quot; test strings</p>
<pre class="literal-block">
def test_str(self):
    &quot;&quot;&quot;Test Code2Text class converting code-&gt;text&quot;&quot;&quot;
    outstr = str(Code2Text(codedata))
    # print text
    print &quot;soll:&quot;, repr(text)
    print &quot;ist: &quot;, repr(outstr)
    assert text == outstr

def test_str_strip(self):
    &quot;&quot;&quot;Test Code2Text class converting code-&gt;rst with strip=True

    Should strip code blocks
    &quot;&quot;&quot;
    pprint(Code2Text(codedata, strip=True)())
    outstr = str(Code2Text(codedata, strip=True))
    print repr(stripped_text)
    print repr(outstr)
    assert stripped_text == outstr

def test_str_different_comment_string(self):
    &quot;&quot;&quot;Convert only comments with the specified comment string to text
    &quot;&quot;&quot;
    outstr = str(Code2Text(codedata, comment_string=&quot;##&quot;, strip=True))
    print outstr
    assert outstr == &quot;&quot;
    data = [&quot;# ::\n&quot;,
            &quot;\n&quot;,
            &quot;block1 = 'first block'\n&quot;,
            &quot;\n&quot;,
            &quot;## more text&quot;]
    soll = &quot;\n&quot;.join(['..  # ::',  # leading code block as header
                      '  ',
                      &quot;  block1 = 'first block'&quot;,
                      '  ',
                      ' more text']   # keep space (not part of comment string)
                    )
    outstr = str(Code2Text(data, comment_string=&quot;##&quot;))
    print &quot;soll:&quot;, repr(soll)
    print &quot;ist: &quot;, repr(outstr)
    assert outstr == soll
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id13" id="id1" name="id1">Special cases</a></h3>
<div class="section">
<h4><a class="toc-backref" href="#id14" id="blank-comment-line" name="blank-comment-line">blank comment line</a></h4>
<p>Normally, whitespace in the comment string is significant, i.e. with
<cite>comment_string = &quot;# &quot;</cite>, a line &quot;#somethingn&quot; will count as code.</p>
<p>However, if a comment line is blank, trailing whitespace in the comment
string should be ignored, i.e. &quot;#n&quot; is recognized as a blank text line:</p>
<pre class="literal-block">
codesamples[&quot;ignore trailing whitespace in comment string for blank line&quot;] = (
&quot;&quot;&quot;# ::

block1 = 'first block'

#
# more text
&quot;&quot;&quot;,
&quot;&quot;&quot;::

  block1 = 'first block'


more text
&quot;&quot;&quot;)
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id15" id="no-blank-line-after-text" name="no-blank-line-after-text">No blank line after text</a></h4>
<p>If a matching comment precedes oder follows a code line (i.e. any line
without matching comment) without a blank line inbetween, it counts as code
line.</p>
<p>This will keep small inline comments close to the code they comment on. It
will also keep blocks together where one commented line doesnot match the
comment string (the whole block will be kept as commented code)</p>
<pre class="literal-block">
codesamples[&quot;comment before code (without blank line)&quot;] = (
&quot;&quot;&quot;# this is text::

# this is a comment
foo = 'first'
&quot;&quot;&quot;,
&quot;&quot;&quot;this is text::

  # this is a comment
  foo = 'first'
&quot;&quot;&quot;,
&quot;&quot;&quot;this is text:

&quot;&quot;&quot;)

codesamples[&quot;comment block before code (without blank line)&quot;] = (
&quot;&quot;&quot;# no text (watch the comment sign in the next line)::
#
# this is a comment
foo = 'first'
&quot;&quot;&quot;,
&quot;&quot;&quot;..  # no text (watch the comment sign in the next line)::
  #
  # this is a comment
  foo = 'first'
&quot;&quot;&quot;,
&quot;&quot;)

codesamples[&quot;comment after code (without blank line)&quot;] = (
&quot;&quot;&quot;# ::

block1 = 'first block'
# commented code

# text again
&quot;&quot;&quot;,
&quot;&quot;&quot;::

  block1 = 'first block'
  # commented code

text again
&quot;&quot;&quot;,
&quot;&quot;&quot;
text again
&quot;&quot;&quot;)

codesamples[&quot;comment block after code (without blank line)&quot;] = (
&quot;&quot;&quot;# ::

block1 = 'first block'
# commented code
#
# still comment
&quot;&quot;&quot;,
&quot;&quot;&quot;::

  block1 = 'first block'
  # commented code
  #
  # still comment
&quot;&quot;&quot;,
&quot;&quot;&quot;
&quot;&quot;&quot;)
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id16" id="missing-literal-block-marker" name="missing-literal-block-marker">missing literal block marker</a></h4>
<p>If text (with matching comment string) is followed by code (line(s) without
matching comment string), but there is no double colon at the end, back
conversion would not recognize the end of text!</p>
<p>Therefore, pylit adds a paragraph containing only &quot;::&quot; -- the literal block
marker in expanded form. (While it would in many cases be nicer to add the
double colon to the last text line, this is not always valid rst syntax,
e.g. after a section header or a list. Therefore the automatic insertion
will use the save form, feel free to correct this by hand.):</p>
<pre class="literal-block">
codesamples[&quot;insert missing double colon after text block&quot;] = (
&quot;&quot;&quot;# text followed by code without double colon

foo = 'first'
&quot;&quot;&quot;,
&quot;&quot;&quot;text followed by code without double colon

::

  foo = 'first'
&quot;&quot;&quot;,
&quot;&quot;&quot;text followed by code without double colon

&quot;&quot;&quot;)
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id17" id="id2" name="id2">header samples</a></h4>
<p>Convert a header (leading code block) to a reStructured text comment.</p>
<pre class="literal-block">
codesamples[&quot;no matching comment, just code&quot;] = (
&quot;&quot;&quot;print 'hello world'

print 'ende'
&quot;&quot;&quot;,
&quot;&quot;&quot;..  print 'hello world'

  print 'ende'
&quot;&quot;&quot;)

codesamples[&quot;empty header (start with matching comment)&quot;] = (
&quot;&quot;&quot;# a classical example without header::

print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;a classical example without header::

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;a classical example without header:

&quot;&quot;&quot;)

codesamples[&quot;standard header, followed by text&quot;] = (
&quot;&quot;&quot;#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

# a classical example with header::

print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;..  #!/usr/bin/env python
  # -*- coding: iso-8859-1 -*-

a classical example with header::

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;a classical example with header:

&quot;&quot;&quot;)

codesamples[&quot;standard header, followed by code&quot;] = (
&quot;&quot;&quot;#!/usr/bin/env python

print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;..  #!/usr/bin/env python

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;)
</pre>
</div>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id18" id="global-defaults" name="global-defaults">Global defaults</a></h1>
<pre class="literal-block">
def test_global_option_defaults():
    &quot;&quot;&quot;dictionary of programming languages and extensions&quot;&quot;&quot;
    for ext in [&quot;.py&quot;, &quot;.sl&quot;, &quot;.c&quot;]:
        assert ext in defaults.code_extensions
    assert defaults.languages[&quot;.py&quot;] == &quot;python&quot;
    assert defaults.languages[&quot;.sl&quot;] == &quot;slang&quot;
    assert defaults.languages[&quot;.c&quot;] == &quot;c++&quot;
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id19" id="command-line-use" name="command-line-use">Command line use</a></h1>
<p>Test the option parsing:</p>
<pre class="literal-block">
class test_OptionValues(object):
    defaults = {&quot;a1&quot;: 1, &quot;a2&quot;: False}
    def setUp(self):
        self.values = OptionValues(self.defaults)
        print self.values

    def test_setup(self):
        assert self.values.a1 == 1
        assert self.values.a2 == False

    def test_as_dict(self):
        print &quot;as_dict() -&gt;&quot;, self.values.as_dict()
        assert self.values.as_dict() == self.defaults

    def test_complete(self):
        &quot;&quot;&quot;complete should update non-existing values only&quot;&quot;&quot;
        self.values.complete(**{&quot;a1&quot;: 2, &quot;a2&quot;: 4, &quot;a3&quot;: 3})
        print &quot;completed -&gt;&quot;, self.values
        assert self.values.a1 == 1, &quot;must not overwrite existing value&quot;
        assert self.values.a2 == False, &quot;must not overwrite existing value&quot;
        assert self.values.a3 == 3, &quot;should set new attributes&quot;
        self.values.complete(a1=2, a4=20)
        assert self.values.a1 == 1, &quot;must not overwrite existing value&quot;
        assert self.values.a4 == 20, &quot;should set new attributes&quot;

    def test_getattr(self):
        &quot;&quot;&quot;Attempt to get a non-existing argument should return None

        This make the code more concise as a try: except: AttributeError
        statement or the parent class method `ensure_value(name, default)`.
        &quot;&quot;&quot;
        assert self.values.a3 == None

    def test_getattr_ensure_value(self):
        &quot;&quot;&quot;Ensure value can be used to set a default different from None&quot;&quot;&quot;
        assert self.values.a4 == None
        self.values.ensure_value(&quot;a4&quot;, 32)
        assert self.values.a4 == 32


class test_PylitOptions:
    &quot;&quot;&quot;Test the PylitOption class&quot;&quot;&quot;
    def setUp(self):
        self.options = PylitOptions()

    def test_parse_args(self):
        &quot;&quot;&quot;parse cmd line args&quot;&quot;&quot;
        # default should appear in options
        values = self.options.parse_args(txt2code=False)
        print values, type(values), dir(values)
        assert values.txt2code == False
        # &quot;cmd line arg should appear as option overwriting default&quot;
        values = self.options.parse_args([&quot;--txt2code&quot;], txt2code=False)
        assert values.txt2code == True
        # &quot;1st non option arg is infile, 2nd is outfile&quot;
        values = self.options.parse_args([&quot;--txt2code&quot;, &quot;text.txt&quot;, &quot;code.py&quot;])
        print values.infile
        assert values.infile == &quot;text.txt&quot;
        assert values.outfile == &quot;code.py&quot;
        # option with argument
        values = self.options.parse_args([&quot;--language&quot;, &quot;slang&quot;])
        assert values.language == &quot;slang&quot;

    def test_parse_args_comment_string(self):
       # default should appear in options
        values = self.options.parse_args([&quot;--comment-string=% &quot;])
        pprint(values.as_dict())
        assert values.comment_string == &quot;% &quot;
        # &quot;cmd line arg should appear as option overwriting default&quot;
        values = self.options.parse_args([&quot;--comment-string=% &quot;],
                                         comment_string=&quot;##&quot;)
        assert values.comment_string == '% '

    def test_get_outfile_name(self):
        &quot;&quot;&quot;should return a sensible outfile name given an infile name&quot;&quot;&quot;
        # return stdout for stdin
        values = OptionValues({&quot;infile&quot;: &quot;-&quot;})
        values.complete(**defaults.__dict__)
        assert &quot;-&quot; == self.options._get_outfile_name(values)
        # return with &quot;.txt&quot; stripped
        values = OptionValues({&quot;infile&quot;: &quot;foo.py.txt&quot;})
        values.complete(**defaults.__dict__)
        assert &quot;foo.py&quot; == self.options._get_outfile_name(values)
        # return with &quot;.txt&quot; added if extension marks code file
        values = OptionValues({&quot;infile&quot;: &quot;foo.py&quot;})
        values.complete(**defaults.__dict__)
        assert &quot;foo.py.txt&quot; == self.options._get_outfile_name(values)
        values = OptionValues({&quot;infile&quot;: &quot;foo.sl&quot;})
        values.complete(**defaults.__dict__)
        assert &quot;foo.sl.txt&quot; == self.options._get_outfile_name(values)
        values = OptionValues({&quot;infile&quot;: &quot;foo.c&quot;})
        values.complete(**defaults.__dict__)
        assert &quot;foo.c.txt&quot; == self.options._get_outfile_name(values)
        # return with &quot;.txt&quot; added if txt2code == False (not None!)
        values = OptionValues({&quot;infile&quot;: &quot;foo.py&quot;, &quot;txt2code&quot;: False})
        values.complete(**defaults.__dict__)
        assert &quot;foo.py.txt&quot; == self.options._get_outfile_name(values)
        # catchall: add &quot;.out&quot; if no other guess possible
        values = OptionValues({&quot;infile&quot;: &quot;foo&quot;, &quot;txt2code&quot;: None})
        values.complete(**defaults.__dict__)
        assert &quot;foo.out&quot; == self.options._get_outfile_name(values)

    def test_complete_values(self):
        &quot;&quot;&quot;Basic test of the option completion&quot;&quot;&quot;
        values = OptionValues()
        values.infile = &quot;foo&quot;
        values = self.options.complete_values(values)
        # the following options should be set:
        print values.infile # logo, as we give it...
        print values.outfile
        assert values.outfile == &quot;foo.out&quot; # fallback extension .out added
        print values.txt2code
        assert values.txt2code == True # the default
        print values.language
        assert values.language == &quot;python&quot; # the default

    def test_complete_values_txt(self):
        &quot;&quot;&quot;Test the option completion with a text input file&quot;&quot;&quot;
        values = OptionValues()
        values.infile = &quot;foo.txt&quot;
        values = self.options.complete_values(values)
        # should set outfile (see also `test_get_outfile_name`)
        assert values.outfile == &quot;foo&quot;
        # should set conversion direction according to extension
        assert values.txt2code == True

    def test_complete_values_code(self):
        &quot;&quot;&quot;Test the option completion with a code input file&quot;&quot;&quot;
        values = OptionValues()
        values.infile = &quot;foo.py&quot;
        values = self.options.complete_values(values)
        # should set outfile name
        assert values.outfile == &quot;foo.py.txt&quot;
        # should set conversion directions according to extension
        print values.txt2code
        assert values.txt2code == False, &quot;set conversion according to extension&quot;

    def test_complete_values_dont_overwrite(self):
        &quot;&quot;&quot;The option completion must not overwrite existing option values&quot;&quot;&quot;
        values = OptionValues()
        values.infile = &quot;foo.py&quot;
        values.outfile = &quot;bar.txt&quot;
        values.txt2code = True
        values = self.options.complete_values(values)
        pprint(values)
        assert values.outfile == &quot;bar.txt&quot;
        assert values.txt2code == True

    def test_complete_values_language_infile(self):
        &quot;&quot;&quot;set the language from the infile extension&quot;&quot;&quot;
        values = OptionValues()
        values.infile = &quot;foo.c&quot;
        values = self.options.complete_values(values)
        pprint(values)
        assert values.language == &quot;c++&quot;

    def test_complete_values_language_outfile(self):
        &quot;&quot;&quot;set the language from the outfile extension&quot;&quot;&quot;
        values = OptionValues()
        values.outfile = &quot;foo.sl&quot;
        values = self.options.complete_values(values)
        pprint(values)
        assert values.language == &quot;slang&quot;

    def test_complete_values_language_fallback(self):
        &quot;&quot;&quot;set the language from the fallback language&quot;&quot;&quot;
        values = OptionValues()
        values = self.options.complete_values(values)
        pprint(values)
        print &quot;fallback language:&quot;, defaults.fallback_language
        assert values.language == defaults.fallback_language

    def test_call(self):
        values = self.options([&quot;--txt2code&quot;, &quot;foo.sl&quot;], txt2code=False)
        pprint(values)
        assert values.txt2code == True
        assert values.infile == &quot;foo.sl&quot;

    def test_call_language(self):
        &quot;&quot;&quot;test the language setting from filename&quot;&quot;&quot;
        values = self.options([&quot;foo.sl&quot;])
        pprint(values)
        assert values.language == &quot;slang&quot;

    def test_call_language_outfile(self):
        &quot;&quot;&quot;test the language setting from filename&quot;&quot;&quot;
        values = self.options([&quot;foo, foo.sl&quot;])
        pprint(values)
        assert values.language == &quot;slang&quot;
</pre>
<div class="section">
<h2><a class="toc-backref" href="#id20" id="input-and-output-streams" name="input-and-output-streams">Input and Output streams</a></h2>
<pre class="literal-block">
class IOTests:
    &quot;&quot;&quot;base class for IO tests, sets up and tears down example files in /tmp
    &quot;&quot;&quot;
    txtpath = &quot;/tmp/pylit_test.py.txt&quot;
    codepath = &quot;/tmp/pylit_test.py&quot;
    outpath = &quot;/tmp/pylit_test.out&quot;
    #
    def setUp(self):
        &quot;&quot;&quot;Set up the test files&quot;&quot;&quot;
        txtfile = file(self.txtpath, 'w')
        txtfile.write(text)
        # txtfile.flush()  # is this needed if we close?
        txtfile.close()
        #
        codefile = file(self.codepath, 'w')
        codefile.write(code)
        # codefile.flush()  # is this needed if we close?
        codefile.close()
    #
    def tearDown(self):
        &quot;&quot;&quot;clean up after all member tests are done&quot;&quot;&quot;
        try:
            os.unlink(self.txtpath)
            os.unlink(self.codepath)
            os.unlink(self.outpath)
        except OSError:
            pass

class test_Streams(IOTests):
    def test_is_newer(self):
        # this __file__ is older, than code file
        print __file__, os.path.getmtime(__file__)
        print self.codepath, os.path.getmtime(self.codepath)
        #
        assert is_newer(self.codepath, __file__) is True, &quot;file1 is newer&quot;
        assert is_newer(__file__, self.codepath) is False, &quot;file2 is newer&quot;
        assert is_newer(__file__, &quot;fffo&quot;) is True, &quot;file2 doesnot exist&quot;
        assert is_newer(&quot;fflo&quot;, __file__) is False, &quot;file1 doesnot exist&quot;
        #
        assert is_newer(__file__, __file__) is None, &quot;equal is not newer&quot;
        assert is_newer(&quot;fflo&quot;, &quot;fffo&quot;) is None, &quot;no file exists -&gt; equal&quot;

    def test_open_streams(self):
        # default should return stdin and -out:
        (instream, outstream) = open_streams()
        assert instream is sys.stdin
        assert outstream is sys.stdout

        # open input and output file
        (instream, outstream) = open_streams(self.txtpath, self.outpath)
        assert type(instream) == file
        assert type(outstream) == file
        # read something from the input
        assert instream.read() == text
        # write something to the output
        outstream.write(text)
        # check the output, we have to flush first
        outstream.flush()
        outfile = file(self.outpath, 'r')
        assert outfile.read() == text

    def test_open_streams_no_infile(self):
        &quot;&quot;&quot;should exit with usage info if no infile given&quot;&quot;&quot;
        try:
            (instream, outstream) = open_streams(&quot;&quot;)
            assert False, &quot;should rise SystemExit&quot;
        except IOError:
            pass
</pre>
<p>Another convenience function that returns a converter instance:</p>
<pre class="literal-block">
def test_get_converter():
    # with default or txt2code
    converter = get_converter(textdata)
    print converter.__class__
    assert converter.__class__ == Text2Code
    converter = get_converter(textdata, txt2code=False)
    assert converter.__class__ == Code2Text

# the run_doctest runs a doctest on the text version (as doc-string)
class test_Run_Doctest(IOTests):
    &quot;&quot;&quot;Doctest should run on the text source&quot;&quot;&quot;
    def test_doctest_txt2code(self):
        (failures, tests) = run_doctest(self.txtpath, txt2code=True)
        assert (failures, tests) == (0, 0)
    def test_doctest_code2txt(self):
        (failures, tests) = run_doctest(self.codepath, txt2code=False)
        assert (failures, tests) == (0, 0)
</pre>
<p>The main() function is called if the script is run from the command line</p>
<pre class="literal-block">
class test_Main(IOTests):
    &quot;&quot;&quot;test default operation from command line
    &quot;&quot;&quot;
    def get_output(self):
        &quot;&quot;&quot;read and return the content of the output file&quot;&quot;&quot;
        outstream = file(self.outpath, 'r')
        return outstream.read()

    def test_text_to_code(self):
        &quot;&quot;&quot;test conversion of text file to code file&quot;&quot;&quot;
        main(infile=self.txtpath, outfile=self.outpath)
        output = self.get_output()
        print repr(output)
        assert output == code

    def test_text_to_code_strip(self):
        &quot;&quot;&quot;test conversion of text file to stripped code file&quot;&quot;&quot;
        main(infile=self.txtpath, outfile=self.outpath, strip=True)
        output = self.get_output()
        print repr(output)
        assert output == stripped_code

    def test_main_code_to_text(self):
        &quot;&quot;&quot;test conversion of code file to text file&quot;&quot;&quot;
        main(infile=self.codepath, outfile=self.outpath)
        output = self.get_output()
        assert output == text

    def test_main_code_to_text_strip(self):
        &quot;&quot;&quot;test conversion of code file to stripped text file&quot;&quot;&quot;
        main(infile=self.codepath, outfile=self.outpath, strip=True)
        output = self.get_output()
        assert output == stripped_text

    def test_main_diff(self):
        result = main(infile=self.codepath, diff=True)
        print &quot;diff return value&quot;, result
        assert result is False # no differences found

    def test_main_diff_with_differences(self):
        &quot;&quot;&quot;diffing a file to itself should fail, as the input is converted&quot;&quot;&quot;
        result = main(infile=self.codepath, outfile=self.codepath, diff=True)
        print &quot;diff return value&quot;, result
        assert result is True # differences found

    def test_main_execute(self):
        result = main(infile=self.txtpath, execute=True)
        print result

    def test_main_execute_code(self):
        result = main(infile=self.codepath, execute=True)

import nose
nose.runmodule() # requires nose 0.9.1
sys.exit()
</pre>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="pylit_test.py.txt">View document source</a>.
Generated on: 2007-03-19.

</div>
</body>
</html>
