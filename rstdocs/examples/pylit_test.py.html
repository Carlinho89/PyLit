<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title></title>
<link rel="stylesheet" href="/usr/lib/python2.4/site-packages/docutils/writers/html4css1/html4css1.css" type="text/css" />
</head>
<body>
<div class="document">
<!-- #!/usr/bin/env python
# -*- coding: iso-8859-1 -*- -->
<div class="section">
<h1><a class="toc-backref" href="#id3" id="test-the-pylit-py-literal-python-module" name="test-the-pylit-py-literal-python-module">Test the pylit.py literal python module</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Date:</th><td class="field-body">$Date: 2007-05-17 $</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">SVN-Revision $Revision: 45 $</td>
</tr>
<tr class="field"><th class="field-name">URL:</th><td class="field-body">$URL: svn+ssh://svn.berlios.de/svnroot/repos/pylit/trunk/test/pylit_test.py $</td>
</tr>
<tr class="field"><th class="field-name">Copyright:</th><td class="field-body">2006 Guenter Milde.
Released under the terms of the GNU General Public License
(v. 2 or later)</td>
</tr>
</tbody>
</table>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#test-the-pylit-py-literal-python-module" id="id3" name="id3">Test the pylit.py literal python module</a><ul>
<li><a class="reference" href="#a-catalog-of-errors" id="id4" name="id4">A catalog of errors</a></li>
</ul>
</li>
<li><a class="reference" href="#text-code-conversion" id="id5" name="id5">Text &lt;-&gt; Code conversion</a><ul>
<li><a class="reference" href="#test-strings" id="id6" name="id6">Test strings</a></li>
<li><a class="reference" href="#textcodeconverter" id="id7" name="id7">TextCodeConverter</a></li>
<li><a class="reference" href="#text2code" id="id8" name="id8">Text2Code</a><ul>
<li><a class="reference" href="#special-cases" id="id9" name="id9">Special Cases</a><ul>
<li><a class="reference" href="#code-follows-text-block-without-blank-line" id="id10" name="id10">Code follows text block without blank line</a></li>
<li><a class="reference" href="#text-follows-code-block-without-blank-line" id="id11" name="id11">Text follows code block without blank line</a></li>
<li><a class="reference" href="#a-double-colon-on-a-line-on-its-own" id="id12" name="id12">A double colon on a line on its own</a></li>
<li><a class="reference" href="#header-samples" id="id13" name="id13">header samples</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#code2text" id="id14" name="id14">Code2Text</a><ul>
<li><a class="reference" href="#id1" id="id15" name="id15">Special cases</a><ul>
<li><a class="reference" href="#blank-comment-line" id="id16" name="id16">blank comment line</a></li>
<li><a class="reference" href="#no-blank-line-after-text" id="id17" name="id17">No blank line after text</a></li>
<li><a class="reference" href="#missing-literal-block-marker" id="id18" name="id18">missing literal block marker</a></li>
<li><a class="reference" href="#id2" id="id19" name="id19">header samples</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#filter-tests" id="id20" name="id20">Filter tests</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id4" id="a-catalog-of-errors" name="a-catalog-of-errors">A catalog of errors</a></h2>
<p>from <a class="reference" href="file:///home/milde/Texte/Doc/Programmierung/Software-Carpentry/lec/unit.html">file:///home/milde/Texte/Doc/Programmierung/Software-Carpentry/lec/unit.html</a></p>
<ul class="simple">
<li>Numbers: zero, largest, smallest magnitude, most negative</li>
<li>Structures: empty, exactly one element, maximum number of elements
- Duplicate elements (e.g., letter &quot;J&quot; appears three times in a string)
- Aliased elements (e.g., a list contains two references to another list)
- Circular structures (e.g., a list that contains a reference to itself)</li>
<li>Searching: no match found, one match found, multiple matches found,
everything matches
- Code like x = find_all(structure)[0] is almost always wrong
- Should also check aliased matches (same thing found multiple times)</li>
</ul>
<pre class="literal-block">
&quot;&quot;&quot;pylit_test.py: test the &quot;literal python&quot; module&quot;&quot;&quot;

from pprint import pprint
import operator
from pylit import *
import nose
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id5" id="text-code-conversion" name="text-code-conversion">Text &lt;-&gt; Code conversion</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id6" id="test-strings" name="test-strings">Test strings</a></h2>
<p>Example of text, code and stripped code with typical features&quot;:</p>
<pre class="literal-block">
text = &quot;&quot;&quot;..  #!/usr/bin/env python
  # -*- coding: iso-8859-1 -*-

Leading text

in several paragraphs followed by a literal block::

  block1 = 'first block'

Some more text and the next block. ::

  block2 = 'second block'
  print block1, block2

Trailing text.
&quot;&quot;&quot;
# print text
</pre>
<p>The converter expects the data in separate lines (iterator or list)
with trailing newlines. We use the <cite>splitlines</cite> string method with
<cite>keepends=True</cite>:</p>
<pre class="literal-block">
textdata = text.splitlines(True)
# print textdata
</pre>
<p>If a &quot;code&quot; source is converted with the <cite>strip</cite> option, only text blocks
are extracted, which leads to:</p>
<pre class="literal-block">
stripped_text = &quot;&quot;&quot;Leading text

in several paragraphs followed by a literal block:

Some more text and the next block.

Trailing text.
&quot;&quot;&quot;
</pre>
<p>The code corresponding to the text test string.</p>
<p>Using a triple-quoted string for the code (and stripped_code) can create
problems with the conversion of this test by pylit (as the text parts
would be converted to text).
A workaround is using a different comment string for the text blocks and
converting with e.g. <tt class="docutils literal"><span class="pre">pylit</span> <span class="pre">--comment-string='##</span> <span class="pre">'</span> <span class="pre">pylit_test.py</span></tt>.</p>
<pre class="literal-block">
code = &quot;&quot;&quot;#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

# Leading text
#
# in several paragraphs followed by a literal block::

block1 = 'first block'

# Some more text and the next block. ::

block2 = 'second block'
print block1, block2

# Trailing text.
&quot;&quot;&quot;
# print code

codedata = code.splitlines(True)
</pre>
<p>Converting the text teststring with the <cite>strip</cite> option leads to:</p>
<pre class="literal-block">
stripped_code = &quot;&quot;&quot;#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

block1 = 'first block'

block2 = 'second block'
print block1, block2

&quot;&quot;&quot;
</pre>
<p>pprint(textdata)
pprint(stripped_code.splitlines(True))</p>
<p>Containers for special case examples:</p>
<p>1. Text2Code samples
<tt class="docutils literal"><span class="pre">textsamples[&quot;what&quot;]</span> <span class="pre">=</span> <span class="pre">(&lt;text</span> <span class="pre">data&gt;,</span> <span class="pre">&lt;output&gt;,</span> <span class="pre">&lt;output</span> <span class="pre">(with</span> <span class="pre">`strip`)</span></tt></p>
<pre class="literal-block">
textsamples = {}
</pre>
<p>2. Code2Text samples
<tt class="docutils literal"><span class="pre">codesamples[&quot;what&quot;]</span> <span class="pre">=</span> <span class="pre">(&lt;code</span> <span class="pre">data&gt;,</span> <span class="pre">&lt;output&gt;,</span> <span class="pre">&lt;output</span> <span class="pre">(with</span> <span class="pre">`strip`)</span></tt></p>
<pre class="literal-block">
codesamples = {}
</pre>
<p>Auxiliary function to test the textsamples and codesamples:</p>
<pre class="literal-block">
def check_converter(key, converter, output):
    print &quot;E:&quot;, key
    extract = converter()
    print(extract)
    outstr = &quot;&quot;.join(extract)
    print &quot;soll:&quot;, repr(output)
    print &quot;ist: &quot;, repr(outstr)
    assert output == outstr
</pre>
<p>Test generator for textsample tests:</p>
<pre class="literal-block">
def test_Text2Code_samples():
    for key, sample in textsamples.iteritems():
        yield (check_converter, key,
               Text2Code(sample[0].splitlines(True)), sample[1])
        if len(sample) == 3:
            yield (check_converter, key,
                   Text2Code(sample[0].splitlines(True), strip=True),
                   sample[2])
</pre>
<p>Test generator for codesample tests:</p>
<pre class="literal-block">
def test_Code2Text_samples():
    for key, sample in codesamples.iteritems():
        yield (check_converter, key,
               Code2Text(sample[0].splitlines(True)), sample[1])
        if len(sample) == 3:
            yield (check_converter, key,
                   Code2Text(sample[0].splitlines(True), strip=True),
                   sample[2])
</pre>
<p>Pre and postprocessing filters (for testing the filter hooks)</p>
<pre class="literal-block">
def r2l_filter(data):
    print &quot;applying r2l filter&quot;
    for line in data:
        yield line.replace(&quot;r&quot;, &quot;l&quot;)
</pre>
<pre class="literal-block">
defaults.preprocessors[&quot;rl2text&quot;] = r2l_filter
</pre>
<pre class="literal-block">
def l2r_filter(data):
    print &quot;applying l2r filter&quot;
    for line in data:
        yield line.replace(&quot;l&quot;, &quot;r&quot;)
</pre>
<pre class="literal-block">
defaults.preprocessors[&quot;text2rl&quot;] = l2r_filter
</pre>
<pre class="literal-block">
def x2u_filter(data):
    print &quot;applying x2u filter&quot;
    for line in data:
        yield line.replace(&quot;x&quot;, &quot;u&quot;)
</pre>
<pre class="literal-block">
defaults.postprocessors[&quot;x2text&quot;] = x2u_filter
</pre>
<pre class="literal-block">
def u2x_filter(data):
    print &quot;applying u2x filter&quot;
    for line in data:
        yield line.replace(&quot;u&quot;, &quot;x&quot;)
</pre>
<pre class="literal-block">
defaults.postprocessors[&quot;text2x&quot;] = u2x_filter
</pre>
<pre class="literal-block">
def test_x2u_filter():
    soll = text.replace(&quot;x&quot;, &quot;u&quot;)
    result = &quot;&quot;.join([line for line in x2u_filter(textdata)])
    print &quot;soll&quot;, repr(text)
    print &quot;ist&quot;, repr(result)
    assert soll == result
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id7" id="textcodeconverter" name="textcodeconverter">TextCodeConverter</a></h2>
<pre class="literal-block">
class test_TextCodeConverter(object):
    &quot;&quot;&quot;Test the TextCodeConverter parent class&quot;&quot;&quot;
</pre>
<pre class="literal-block">
def check_marker_regexp_true(self, sample):
    match = self.converter.marker_regexp.search(sample)
    print 'marker: %r; sample %r' %(self.converter.code_block_marker, sample)
    print 'match %r'%match
    assert match is not None
</pre>
<pre class="literal-block">
def check_marker_regexp_false(self, sample):
    assert self.converter.marker_regexp.search(sample) is None
</pre>
<pre class="literal-block">
def test_marker_regexp(self):
    # Samples
    literal = ['::',
               '  ::',
               't ::',
               'text::',
               ' indented::',
               ' indented ::',
               'more text :: ',
               ' indented text :: ',
               '. no-directive::',
               'a .. directive:: somewhere::']
    directive = ['.. code-block:: python',
                 '  .. code-block:: python',
                 '.. code-block:: python listings',
                 '  .. code-block:: python listings']
    misses = ['.. comment string ::',
              '.. ::',
              'text:']
    # default code_block_marker ('::')
    self.converter = TextCodeConverter(textdata)
    for sample in literal:
        yield (self.check_marker_regexp_true, sample)
    for sample in directive+misses:
        yield (self.check_marker_regexp_false, sample)
    # code-block directive as marker
    self.converter = TextCodeConverter(textdata,
                                       code_block_marker='.. code-block::')
    for sample in directive:
        yield (self.check_marker_regexp_true, sample)
    for sample in literal+misses:
        yield (self.check_marker_regexp_false, sample)
</pre>
<pre class="literal-block">
def test_get_indent(self):
    converter = TextCodeConverter(textdata)
    assert converter.get_indent(&quot;foo&quot;) == 0
    assert converter.get_indent(&quot; foo&quot;) == 1
    assert converter.get_indent(&quot;  foo&quot;) == 2
</pre>
<pre class="literal-block">
def test_collect_blocks(self):
    converter = TextCodeConverter(textdata)
    textblocks = [block for block in collect_blocks(textdata)]
    print textblocks
    assert len(textblocks) == 7, &quot;text sample has 7 blocks&quot;
    assert reduce(operator.__add__, textblocks) == textdata
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id8" id="text2code" name="text2code">Text2Code</a></h2>
<pre class="literal-block">
class test_Text2Code(object):
    &quot;&quot;&quot;Test the Text2Code class converting rst-&gt;code&quot;&quot;&quot;
</pre>
<pre class="literal-block">
def setUp(self):
    self.converter = Text2Code(textdata)
</pre>
<p>test helper funs</p>
<pre class="literal-block">
def test_set_state_empty(self):
    try:
        self.converter.set_state([])
        raise AssertionError, &quot;should raise StopIteration&quot;
    except StopIteration:
        pass

def test_set_state_header(self):
    &quot;&quot;&quot;test for &quot;header&quot; or &quot;documentation&quot; for first block&quot;&quot;&quot;
    self.converter.state = &quot;&quot; # normally set by the `convert` method
    self.converter.set_state([&quot;.. header&quot;, &quot; block&quot;])
    assert self.converter.state == &quot;header&quot;
    self.converter.state = &quot;&quot; # normally set by the `convert` method
    self.converter.set_state([&quot;documentation&quot;, &quot;block&quot;])
    assert self.converter.state == &quot;documentation&quot;

def test_set_state_code_block(self):
    &quot;&quot;&quot;test for &quot;header&quot; or &quot;documentation&quot; for &quot;code_block&quot; &quot;&quot;&quot;
    # normally set by the `convert` method
    self.converter._textindent = 0
    self.converter.state = &quot;code_block&quot;
    self.converter.set_state([&quot;documentation&quot;, &quot;  block&quot;])
    assert self.converter.state == &quot;documentation&quot;

    self.converter.state = &quot;code_block&quot;
    self.converter.set_state([&quot;  documentation&quot;, &quot;block&quot;])
    assert self.converter.state == &quot;documentation&quot;

    self.converter.state = &quot;code_block&quot;
    self.converter.set_state([&quot;  code&quot;, &quot;  block&quot;])
    print self.converter.state
    assert self.converter.state == &quot;code_block&quot;

def test_header_handler(self):
    &quot;&quot;&quot;should strip header-string from header&quot;&quot;&quot;
    self.converter._codeindent = 0
    sample = [&quot;.. header&quot;, &quot; block&quot;]
    lines = [line for line in self.converter.header_handler(sample)]
    print lines
    assert lines == [&quot;header&quot;, &quot;block&quot;]

def test_documentation_handler(self):
    &quot;&quot;&quot;should add comment string to documentation&quot;&quot;&quot;
    sample = [&quot;doc&quot;, &quot;block&quot;, &quot;&quot;]
    lines = [line for line
              in self.converter.documentation_handler(sample)]
    print lines
    assert lines == [&quot;# doc&quot;, &quot;# block&quot;, &quot;# &quot;]

def test_documentation_handler_set_state(self):
    &quot;&quot;&quot;should add comment string to documentation&quot;&quot;&quot;
    sample = [&quot;doc&quot;, &quot;block::&quot;, &quot;&quot;]
    lines = [line for line
              in self.converter.documentation_handler(sample)]
    print lines
    assert lines == [&quot;# doc&quot;, &quot;# block::&quot;, &quot;&quot;]
    assert self.converter.state == &quot;code_block&quot;

def test_code_block_handler(self):
    &quot;&quot;&quot;should un-indent code-blocks&quot;&quot;&quot;
    self.converter._codeindent = 0 # normally set in `convert`
    sample = [&quot;  code&quot;, &quot;  block&quot;, &quot;&quot;]
    lines = [line for line
              in self.converter.code_block_handler(sample)]
    print lines
    assert lines == [&quot;code&quot;, &quot;block&quot;, &quot;&quot;]
</pre>
<p>base tests on the &quot;long&quot; test data</p>
<pre class="literal-block">
def test_call(self):
    &quot;&quot;&quot;Calling a Text2Code instance should return the converted data as list of lines&quot;&quot;&quot;
    output = self.converter()
    print repr(codedata)
    print repr(output)
    assert codedata == output

def test_call_strip(self):
    &quot;&quot;&quot;strip=True should strip text parts&quot;&quot;&quot;
    self.converter.strip = True
    output = self.converter()
    print repr(stripped_code.splitlines(True))
    print repr(output)
    assert stripped_code.splitlines(True) == output

def test_str(self):
    outstr = str(self.converter)
    print repr(code)
    print repr(outstr)
    assert code == outstr

def test_str_strip1(self):
    &quot;&quot;&quot;strip=True should strip text parts.

    Version 1 with `strip` given as optional argument&quot;&quot;&quot;
    outstr = str(Text2Code(textdata, strip=True))
    print &quot;ist &quot;, repr(outstr)
    print &quot;soll&quot;, repr(stripped_code)
    # pprint(outstr)
    assert stripped_code == outstr

def test_str_strip2(self):
    &quot;&quot;&quot;strip=True should strip text parts

    Version 2 with `strip` set after instantiation&quot;&quot;&quot;
    self.converter.strip = True
    outstr = str(self.converter)
    print &quot;ist &quot;, repr(outstr)
    print &quot;soll&quot;, repr(stripped_code)
    # pprint(outstr)
    assert stripped_code == outstr

def test_malindented_code_line(self):
    &quot;&quot;&quot;raise error if code line is less indented than code-indent&quot;&quot;&quot;
    data1 = [&quot;..    #!/usr/bin/env python\n&quot;, # indent == 4 * &quot; &quot;
            &quot;\n&quot;,
            &quot;  print 'hello world'&quot;]          # indent == 2 * &quot; &quot;
    data2 = [&quot;..\t#!/usr/bin/env python\n&quot;,   # indent == 8 * &quot; &quot;
            &quot;\n&quot;,
            &quot;  print 'hello world'&quot;]          # indent == 2 * &quot; &quot;
    for data in (data1, data2):
        try:
            blocks = Text2Code(data)()
            assert False, &quot;wrong indent did not raise ValueError&quot;
        except ValueError:
            pass

def test_str_different_comment_string(self):
    &quot;&quot;&quot;Convert only comments with the specified comment string to text
    &quot;&quot;&quot;
    data = [&quot;..  #!/usr/bin/env python\n&quot;,
            '\n',
            '::\n',  # leading code block as header
            '\n',
            &quot;  block1 = 'first block'\n&quot;,
            '  \n',
            'more text']
    soll = &quot;\n&quot;.join([&quot;#!/usr/bin/env python&quot;,
                      &quot;&quot;,
                      &quot;##::&quot;,
                      &quot;&quot;,
                      &quot;block1 = 'first block'&quot;,
                      &quot;&quot;,
                      &quot;##more text&quot;]
                    )
    outstr = str(Text2Code(data, comment_string=&quot;##&quot;))
    print &quot;soll:&quot;, repr(soll)
    print &quot;ist: &quot;, repr(outstr)
    assert outstr == soll

# Filters: test pre- and postprocessing of data

def test_get_filter_preprocessor(self):
    &quot;&quot;&quot;should return filter from filter_set for language&quot;&quot;&quot;
    preprocessor = self.converter.get_filter(&quot;preprocessors&quot;, &quot;rl&quot;)
    print preprocessor
    assert preprocessor == l2r_filter

def test_get_filter_postprocessor(self):
    &quot;&quot;&quot;should return filter from filter_set for language&quot;&quot;&quot;
    postprocessor = self.converter.get_filter(&quot;postprocessors&quot;, &quot;x&quot;)
    print postprocessor
    assert postprocessor == u2x_filter

def test_get_css_postprocessor(self):
    &quot;&quot;&quot;should return filter from filter_set for language&quot;&quot;&quot;
    postprocessor = self.converter.get_filter(&quot;postprocessors&quot;, &quot;css&quot;)
    print postprocessor
    assert postprocessor == dumb_c_postprocessor

def test_get_filter_nonexisting_language_filter(self):
    &quot;&quot;&quot;should return identity_filter if language has no filter in set&quot;&quot;&quot;
    preprocessor = self.converter.get_filter(&quot;preprocessors&quot;, &quot;foo&quot;)
    print preprocessor
    assert preprocessor == identity_filter

def test_get_filter_nonexisting_filter_set(self):
    &quot;&quot;&quot;should return identity_filter if filter_set does not exist&quot;&quot;&quot;
    processor = self.converter.get_filter(&quot;foo_filters&quot;, &quot;foo&quot;)
    print processor
    assert processor == identity_filter

def test_preprocessor(self):
    &quot;&quot;&quot;Preprocess data with registered preprocessor for language&quot;&quot;&quot;
    output = Text2Code(textdata, language=&quot;x&quot;, comment_string=&quot;# &quot;)()
    soll = [line for line in u2x_filter(codedata)]
    print &quot;soll: &quot;, repr(soll)
    print &quot;ist:  &quot;, repr(output)
    assert output == soll

def test_postprocessor(self):
    &quot;&quot;&quot;Preprocess data with registered postprocessor for language&quot;&quot;&quot;
    output = Text2Code(textdata, language=&quot;x&quot;, comment_string=&quot;# &quot;)()
    soll = [line for line in u2x_filter(codedata)]
    print &quot;soll:&quot;, repr(soll)
    print &quot;ist: &quot;, repr(output)
    assert output == soll
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id9" id="special-cases" name="special-cases">Special Cases</a></h3>
<div class="section">
<h4><a class="toc-backref" href="#id10" id="code-follows-text-block-without-blank-line" name="code-follows-text-block-without-blank-line">Code follows text block without blank line</a></h4>
<p>End of text block detected ('::') but no paragraph separator (blank line)
follows</p>
<p>It is an reStructuredText syntax error, if a &quot;literal block
marker&quot; is not followed by a blank line.</p>
<p>Assuming that no double colon at end of line occures accidentially,
pylit could fix this and issue a warning:</p>
<pre class="literal-block">
# Do we need this feature? (Complicates code a lot)
# textsamples[&quot;ensure blank line after text&quot;] = (
# &quot;&quot;&quot;text followed by a literal block::
#   block1 = 'first block'
# &quot;&quot;&quot;,
# &quot;&quot;&quot;# text followed by a literal block::
#
# block1 = 'first block'
# &quot;&quot;&quot;)
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id11" id="text-follows-code-block-without-blank-line" name="text-follows-code-block-without-blank-line">Text follows code block without blank line</a></h4>
<p>End of code block detected (a line not more indented than the preceding text
block)</p>
<p>reStructuredText syntax demands a paragraph separator (blank line) before
it.</p>
<p>Assuming that the unindent is not accidential, pylit could fix this and
issues a warning:</p>
<pre class="literal-block">
# Do we need this feature? (Complicates code)
# textsamples[&quot;ensure blank line after code&quot;] = (
# &quot;&quot;&quot;::
#
#   block1 = 'first block'
# more text
# &quot;&quot;&quot;,
# &quot;&quot;&quot;# ::
#
# block1 = 'first block'
#
# more text
# &quot;&quot;&quot;)
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id12" id="a-double-colon-on-a-line-on-its-own" name="a-double-colon-on-a-line-on-its-own">A double colon on a line on its own</a></h4>
<p>As a double colon is added by the Code2Text conversion after a text block
(if not already present), it could be removed by the Text2Code conversion
to keep the source small and pretty.</p>
<p>However, this would put the text and code source line numbers out of sync,
which is bad for error reporting, failing doctests, and the JED editor
support with the <cite>pylit_buffer()</cite> function in
<a class="reference" href="http://jedmodes.sf.net/mode/pylit.sl">http://jedmodes.sf.net/mode/pylit.sl</a> .</p>
<p>Maybe this could be left to a post-processing filter:</p>
<pre class="literal-block">
# textsamples[&quot;remove single double colon&quot;] = (
#    [&quot;text followed by a literal block\n&quot;,
#     &quot;\n&quot;,
#     &quot;::\n&quot;,
#     &quot;\n&quot;,
#     &quot;  foo = 'first'\n&quot;]
#    [&quot;&quot;, # empty header
#     &quot;# text followed by a literal block\n\n&quot;,
#     &quot;foo = 'first'\n&quot;]
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id13" id="header-samples" name="header-samples">header samples</a></h4>
<p>Convert a leading reStructured text comment  (variant: only if there is
content on the first line) to a leading code block.  Return an empty list,
if there is no header.</p>
<pre class="literal-block">
textsamples[&quot;simple header&quot;] = (&quot;..  print 'hello world'&quot;,
                                &quot;print 'hello world'&quot;)

textsamples[&quot;no header (start with text)&quot;] = (
&quot;&quot;&quot;a classical example without header::

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;# a classical example without header::

print 'hello world'
&quot;&quot;&quot;)


textsamples[&quot;no header (start with blank line)&quot;] = (
&quot;&quot;&quot;
a classical example without header::

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;#
# a classical example without header::

print 'hello world'
&quot;&quot;&quot;)


textsamples[&quot;standard header, followed by text&quot;] = (
&quot;&quot;&quot;..  #!/usr/bin/env python
  # -*- coding: iso-8859-1 -*-

a classical example with header::

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

# a classical example with header::

print 'hello world'
&quot;&quot;&quot;)

textsamples[&quot;standard header, followed by code&quot;] = (
&quot;&quot;&quot;..  #!/usr/bin/env python

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;#!/usr/bin/env python

print 'hello world'
&quot;&quot;&quot;)

textsamples[&quot;null string&quot;] = (&quot;&quot;, &quot;&quot;, &quot;&quot;)
</pre>
</div>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id14" id="code2text" name="code2text">Code2Text</a></h2>
<pre class="literal-block">
class test_Code2Text(object):

    def setUp(self):
        self.converter = Code2Text(codedata)

## Code2Text.strip_literal_marker
##
## * strip `::`-line as well as preceding blank line if on a line on its own
## * strip `::` if it is preceded by whitespace.
## * convert `::` to a single colon if preceded by text
##
## ::
    def check_strip_code_block_marker(self, sample):
        &quot;&quot;&quot;test Code2Text.strip_code_block_marker&quot;&quot;&quot;
        ist = sample[0].splitlines(True)
        soll = sample[1].splitlines(True)
        print &quot;before&quot;, ist
        converter = Code2Text(codedata)
        converter.strip_code_block_marker(ist)
        print &quot;soll:&quot;, repr(soll)
        print &quot;ist: &quot;, repr(ist)
        assert ist == soll


    def test_strip_code_block_marker(self):
        samples = ((&quot;text\n\n::\n\n&quot;, &quot;text\n\n&quot;),
                   (&quot;text\n::\n\n&quot;, &quot;text\n\n&quot;),
                   (&quot;text ::\n\n&quot;, &quot;text\n\n&quot;),
                   (&quot;text::\n\n&quot;, &quot;text:\n\n&quot;),
                   (&quot;text:\n\n&quot;, &quot;text:\n\n&quot;),
                   (&quot;text\n\n&quot;, &quot;text\n\n&quot;),
                   (&quot;text\n&quot;, &quot;text\n&quot;)
                   )
        for sample in samples:
            yield (self.check_strip_code_block_marker, sample)
</pre>
<p>Code2Text.set_state</p>
<pre class="literal-block">
def test_set_state(self):
    samples = ((&quot;code_block&quot;, [&quot;code_block\n&quot;], &quot;code_block&quot;),
               (&quot;code_block&quot;, [&quot;#code_block\n&quot;], &quot;code_block&quot;),
               (&quot;code_block&quot;, [&quot;## code_block\n&quot;], &quot;code_block&quot;),
               (&quot;code_block&quot;, [&quot;# documentation\n&quot;], &quot;documentation&quot;),
               (&quot;code_block&quot;, [&quot;#  documentation\n&quot;], &quot;documentation&quot;),
               (&quot;code_block&quot;, [&quot;# \n&quot;], &quot;documentation&quot;),
               (&quot;code_block&quot;, [&quot;#\n&quot;], &quot;documentation&quot;),
               (&quot;code_block&quot;, [&quot;\n&quot;], &quot;documentation&quot;),
               (&quot;&quot;, [&quot;code_block\n&quot;], &quot;header&quot;),
               (&quot;&quot;, [&quot;# documentation\n&quot;], &quot;documentation&quot;),
               (&quot;documentation&quot;, [&quot;code_block\n&quot;], &quot;code_block&quot;),
               (&quot;documentation&quot;, [&quot;# documentation\n&quot;], &quot;documentation&quot;),
              )
    print &quot;comment string&quot;, repr(self.converter.comment_string)
    for (old_state, lines, soll) in samples:
        self.converter.state = old_state
        self.converter.set_state(lines)
        print repr(lines), &quot;old state&quot;, old_state
        print &quot;soll&quot;, repr(soll),
        print &quot;result&quot;, repr(self.converter.state)
        assert soll == self.converter.state
</pre>
<p>base tests on the &quot;long&quot; test strings</p>
<pre class="literal-block">
def test_call(self):
    output = self.converter()
    print repr(textdata)
    print repr(output)
    assert textdata == output

def test_call_strip(self):
    output = Code2Text(codedata, strip=True)()
    print repr(stripped_text.splitlines(True))
    print repr(output)
    assert stripped_text.splitlines(True) == output

def test_str(self):
    &quot;&quot;&quot;Test Code2Text class converting code-&gt;text&quot;&quot;&quot;
    outstr = str(self.converter)
    # print text
    print &quot;soll:&quot;, repr(text)
    print &quot;ist: &quot;, repr(outstr)
    assert text == outstr

def test_str_strip(self):
    &quot;&quot;&quot;Test Code2Text class converting code-&gt;rst with strip=True

    Should strip code blocks
    &quot;&quot;&quot;
    outstr = str(Code2Text(codedata, strip=True))
    print repr(stripped_text)
    print repr(outstr)
    assert stripped_text == outstr

def test_str_different_comment_string(self):
    &quot;&quot;&quot;Convert only comments with the specified comment string to text
    &quot;&quot;&quot;
    outstr = str(Code2Text(codedata, comment_string=&quot;##&quot;, strip=True))
    print outstr
    assert outstr == &quot;&quot;
    data = [&quot;# ::\n&quot;,
            &quot;\n&quot;,
            &quot;block1 = 'first block'\n&quot;,
            &quot;\n&quot;,
            &quot;## more text&quot;]
    soll = &quot;\n&quot;.join(['..  # ::',  # leading code block as header
                      '  ',
                      &quot;  block1 = 'first block'&quot;,
                      '  ',
                      ' more text']   # keep space (not part of comment string)
                    )
    outstr = str(Code2Text(data, comment_string=&quot;##&quot;))
    print &quot;soll:&quot;, repr(soll)
    print &quot;ist: &quot;, repr(outstr)
    assert outstr == soll

def test_call_different_code_block_marker(self):
    &quot;&quot;&quot;recognize specified code-block marker
    &quot;&quot;&quot;
    data = [&quot;# .. code-block:: python\n&quot;,
            &quot;\n&quot;,
            &quot;block1 = 'first block'\n&quot;,
            &quot;\n&quot;,
            &quot;#  more text\n&quot;]
    soll = ['.. code-block:: python\n',
            '\n',
            &quot;  block1 = 'first block'\n&quot;,
            '  \n',
            ' more text\n']   # keep space (not part of comment string)

    converter = Code2Text(data, code_block_marker='.. code-block::')
    output = converter()
    print &quot;soll:&quot;, repr(soll)
    print &quot;ist: &quot;, repr(output)
    assert output == soll

# Filters: test pre- and postprocessing of Code2Text data conversion

def test_get_filter_preprocessor(self):
    &quot;&quot;&quot;should return Code2Text preprocessor for language&quot;&quot;&quot;
    preprocessor = self.converter.get_filter(&quot;preprocessors&quot;, &quot;rl&quot;)
    print preprocessor
    assert preprocessor == r2l_filter

def test_get_css_preprocessor(self):
    &quot;&quot;&quot;should return filter from filter_set for language&quot;&quot;&quot;
    preprocessor = self.converter.get_filter(&quot;preprocessors&quot;, &quot;css&quot;)
    print preprocessor
    assert preprocessor == dumb_c_preprocessor

def test_get_filter_postprocessor(self):
    &quot;&quot;&quot;should return Code2Text postprocessor for language&quot;&quot;&quot;
    postprocessor = self.converter.get_filter(&quot;postprocessors&quot;, &quot;x&quot;)
    print postprocessor
    assert postprocessor == x2u_filter

def test_get_filter_nonexisting_language_filter(self):
    &quot;&quot;&quot;should return identity_filter if language has no filter in set&quot;&quot;&quot;
    preprocessor = self.converter.get_filter(&quot;preprocessors&quot;, &quot;foo&quot;)
    print preprocessor
    assert preprocessor == identity_filter

def test_get_filter_nonexisting_filter_set(self):
    &quot;&quot;&quot;should return identity_filter if filter_set does not exist&quot;&quot;&quot;
    processor = self.converter.get_filter(&quot;foo_filters&quot;, &quot;foo&quot;)
    print processor
    assert processor == identity_filter

def test_preprocessor(self):
    &quot;&quot;&quot;Preprocess data with registered preprocessor for language&quot;&quot;&quot;
    converter = Code2Text(codedata, language=&quot;rl&quot;, comment_string=&quot;# &quot;)
    print &quot;preprocessor&quot;, converter.preprocessor
    print &quot;postprocessor&quot;, converter.postprocessor
    output = converter()
    soll = [line.replace(&quot;r&quot;, &quot;l&quot;) for line in textdata]
    print &quot;ist: &quot;, repr(output)
    print &quot;soll:&quot;, repr(soll)
    assert output == soll

def test_postprocessor(self):
    &quot;&quot;&quot;Postprocess data with registered postprocessor for language&quot;&quot;&quot;
    output = Code2Text(codedata, language=&quot;x&quot;, comment_string=&quot;# &quot;)()
    soll = [line.replace(&quot;x&quot;, &quot;u&quot;) for line in textdata]
    print &quot;soll:&quot;, repr(soll)
    print &quot;ist: &quot;, repr(output)
    assert output == soll
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id15" id="id1" name="id1">Special cases</a></h3>
<div class="section">
<h4><a class="toc-backref" href="#id16" id="blank-comment-line" name="blank-comment-line">blank comment line</a></h4>
<p>Normally, whitespace in the comment string is significant, i.e. with
<tt class="docutils literal"><span class="pre">comment_string</span> <span class="pre">=</span> <span class="pre">&quot;#</span> <span class="pre">&quot;</span></tt>, a line <tt class="docutils literal"><span class="pre">&quot;#something\n&quot;</span></tt> will count as code.</p>
<p>However, if a comment line is blank, trailing whitespace in the comment
string should be ignored, i.e. <tt class="docutils literal"><span class="pre">#\n</span></tt> is recognized as a blank text line:</p>
<pre class="literal-block">
codesamples[&quot;ignore trailing whitespace in comment string for blank line&quot;] = (
&quot;&quot;&quot;# ::

block1 = 'first block'

#
# more text
&quot;&quot;&quot;,
&quot;&quot;&quot;::

  block1 = 'first block'


more text
&quot;&quot;&quot;)
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id17" id="no-blank-line-after-text" name="no-blank-line-after-text">No blank line after text</a></h4>
<p>If a matching comment precedes oder follows a code line (i.e. any line
without matching comment) without a blank line inbetween, it counts as code
line.</p>
<p>This will keep small inline comments close to the code they comment on. It
will also keep blocks together where one commented line does not match the
comment string (the whole block will be kept as commented code)</p>
<pre class="literal-block">
codesamples[&quot;comment before code (without blank line)&quot;] = (
&quot;&quot;&quot;# this is text::

# this is a comment
foo = 'first'
&quot;&quot;&quot;,
&quot;&quot;&quot;this is text::

  # this is a comment
  foo = 'first'
&quot;&quot;&quot;,
&quot;&quot;&quot;this is text:

&quot;&quot;&quot;)

codesamples[&quot;comment block before code (without blank line)&quot;] = (
&quot;&quot;&quot;# no text (watch the comment sign in the next line)::
#
# this is a comment
foo = 'first'
&quot;&quot;&quot;,
&quot;&quot;&quot;..  # no text (watch the comment sign in the next line)::
  #
  # this is a comment
  foo = 'first'
&quot;&quot;&quot;,
&quot;&quot;)

codesamples[&quot;comment after code (without blank line)&quot;] = (
&quot;&quot;&quot;# ::

block1 = 'first block'
# commented code

# text again
&quot;&quot;&quot;,
&quot;&quot;&quot;::

  block1 = 'first block'
  # commented code

text again
&quot;&quot;&quot;,
&quot;&quot;&quot;
text again
&quot;&quot;&quot;)

codesamples[&quot;comment block after code (without blank line)&quot;] = (
&quot;&quot;&quot;# ::

block1 = 'first block'
# commented code
#
# still comment
&quot;&quot;&quot;,
&quot;&quot;&quot;::

  block1 = 'first block'
  # commented code
  #
  # still comment
&quot;&quot;&quot;,
&quot;&quot;&quot;
&quot;&quot;&quot;)
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id18" id="missing-literal-block-marker" name="missing-literal-block-marker">missing literal block marker</a></h4>
<p>If text (with matching comment string) is followed by code (line(s) without
matching comment string), but there is no double colon at the end, back
conversion would not recognize the end of text!</p>
<p>Therefore, pylit adds a paragraph containing only <tt class="docutils literal"><span class="pre">::</span></tt> -- the literal
block marker in expanded form. (While it would in many cases be nicer to
add the double colon to the last text line, this is not always valid rst
syntax, e.g. after a section header or a list. Therefore the automatic
insertion will use the save form, feel free to correct this by hand.):</p>
<pre class="literal-block">
codesamples[&quot;insert missing double colon after text block&quot;] = (
&quot;&quot;&quot;# text followed by code without double colon

foo = 'first'
&quot;&quot;&quot;,
&quot;&quot;&quot;text followed by code without double colon

::

  foo = 'first'
&quot;&quot;&quot;,
&quot;&quot;&quot;text followed by code without double colon

&quot;&quot;&quot;)
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id19" id="id2" name="id2">header samples</a></h4>
<p>Convert a header (leading code block) to a reStructured text comment.</p>
<pre class="literal-block">
codesamples[&quot;no matching comment, just code&quot;] = (
&quot;&quot;&quot;print 'hello world'

print 'ende'
&quot;&quot;&quot;,
&quot;&quot;&quot;..  print 'hello world'

  print 'ende'
&quot;&quot;&quot;)

codesamples[&quot;empty header (start with matching comment)&quot;] = (
&quot;&quot;&quot;# a classical example without header::

print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;a classical example without header::

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;a classical example without header:

&quot;&quot;&quot;)

codesamples[&quot;standard header, followed by text&quot;] = (
&quot;&quot;&quot;#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

# a classical example with header::

print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;..  #!/usr/bin/env python
  # -*- coding: iso-8859-1 -*-

a classical example with header::

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;a classical example with header:

&quot;&quot;&quot;)

codesamples[&quot;standard header, followed by code&quot;] = (
&quot;&quot;&quot;#!/usr/bin/env python

print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;&quot;..  #!/usr/bin/env python

  print 'hello world'
&quot;&quot;&quot;,
&quot;&quot;)
</pre>
</div>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id20" id="filter-tests" name="filter-tests">Filter tests</a></h2>
<pre class="literal-block">
css_code = ['/* import the default docutils style sheet */\n',
            '/* --------------------------------------- */\n',
            '\n',
            '/* :: */\n',
            '\n',
            '/*comment*/\n',
            '&#64;import url(&quot;html4css1.css&quot;); /* style */\n']
</pre>
<pre class="literal-block">
css_filtered_code = ['// import the default docutils style sheet\n',
                     '// ---------------------------------------\n',
                     '\n',
                     '// ::\n',
                     '\n',
                     '/*comment*/\n',
                     '&#64;import url(&quot;html4css1.css&quot;); /* style */\n']
</pre>
<pre class="literal-block">
def test_dumb_c_preprocessor():
    &quot;&quot;&quot;convert `C` to `C++` comments&quot;&quot;&quot;
    output = [line for line in dumb_c_preprocessor(css_code)]
    print &quot;ist:  %r&quot;%output
    print &quot;soll: %r&quot;%css_filtered_code
    assert output == css_filtered_code
</pre>
<pre class="literal-block">
def test_dumb_c_postprocessor():
    &quot;&quot;&quot;convert `C++` to `C` comments&quot;&quot;&quot;
    output = [line for line in dumb_c_postprocessor(css_filtered_code)]
    print &quot;ist:  %r&quot;%output
    print &quot;soll: %r&quot;%css_code
    assert output == css_code
</pre>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;:
    nose.runmodule() # requires nose 0.9.1
    sys.exit()
</pre>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="pylit_test.py.txt">View document source</a>.
Generated on: 2007-06-21.

</div>
</body>
</html>
