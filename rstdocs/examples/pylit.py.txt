..  #!/usr/bin/env python
  # -*- coding: iso-8859-1 -*-
  
===============================================================
pylit.py: Literate programming with reStructuredText
===============================================================

:Date:      $Date$
:Version:   SVN-Revision $Revision$
:URL:       $URL$
:Copyright: 2005, 2007 Guenter Milde.
            Released under the terms of the GNU General Public License 
            (v. 2 or later)

.. sectnum::
.. contents::

Frontmatter
===========

Changelog
---------

:2005-06-29: Initial version
:2005-06-30: first literate version of the script
:2005-07-01: object orientated script using generators
:2005-07-10: Two state machine (later added 'header' state)
:2006-12-04: Start of work on version 0.2 (code restructuring)
:2007-01-23: 0.2   published at http://pylit.berlios.de
:2007-01-25: 0.2.1 Outsourced non-core documentation to the PyLit pages.
:2007-01-26: 0.2.2 new behaviour of `diff` function
:2007-01-29: 0.2.3 new `header` methods after suggestion by Riccardo Murri
:2007-01-31: 0.2.4 raise Error if code indent is too small
:2007-02-05: 0.2.5 new command line option --comment-string
:2007-02-09: 0.2.6 add section with open questions,
                   Code2Text: let only blank lines (no comment str)
                   separate text and code,
                   fix `Code2Text.header`
:2007-02-19: 0.2.7 simplify `Code2Text.header,`
                   new `iter_strip` method replacing a lot of ``if``-s
:2007-02-22: 0.2.8 set `mtime` of outfile to the one of infile
:2007-02-27: 0.3   new `Code2Text` converter after an idea by Riccardo Murri
                   explicite `option_defaults` dict for easier customization
:2007-03-02: 0.3.1 expand hard-tabs to prevent errors in indentation,
                   `Text2Code` now also works on blocks,
                   removed dependency on SimpleStates module
:2007-03-06: 0.3.2 bugfix: do not set `language` in `option_defaults`
                   renamed `code_languages` to `languages`
:2007-03-16: 0.3.3 new language css
                   option_defaults -> defaults = optparse.Values()
                   simpler PylitOptions: don't store parsed values,
                   don't parse at initialization.
                   OptionValues: return `None` for non-existing attributes
                   removed -infile and -outfile, use positional arguments
:2007-03-19: 0.3.4 documentation update
                   separate `execute` function
:2007-03-21:       code cleanup in `Text2Code.__iter__`
:2007-03-23: 0.3.5 removed "css" from languages after learning that 
                   there is no C++ style "// " comment in css2
::

  """pylit: Literate programming with Python and reStructuredText
     
     PyLit is a bidirectional converter between
     
     * a (reStructured) text source with embedded code blocks, and
     * a code source with embedded documentation (comment blocks)
  """
  
  __docformat__ = 'restructuredtext'
  
  _version = "0.3"
  

Requirements
------------

::

  import re
  import os
  import sys
  import optparse
  
Customisation
=============

defaults
--------

The `defaults` object provides a central repository for default values
and their customisation. 

* used for the initialization of data arguments in Converter_ and
  PylitOptions_
  
* used for completion of command line options in 
  `PylitOptions.complete_values`_. This way, using `pylit.py` as
  module one can customise the defaults and then call main_ e.g.:

  >>> import pylit
  >>> defaults.comment_string = "## "
  >>> defaults.codeindent = 4
  >>> main()
  
::

  defaults = optparse.Values()
  

By default, the language is set by `OptionValues.complete`_ from the code
file extension. The ``--language` command line option or setting 
``defaults.language`` in programmatic use will override this auto-setting
feature::

  defaults.languages  = {".py": "python", 
                         ".sl": "slang", 
                         ".c": "c++",
                         ".el":"elisp"}
  
If there is no matching extension, e.g. if pylit is used as filter, fall
back to the `fallback_language`::

  defaults.fallback_language = "python"
  

The `code extensions` are used in `OptionValues.complete`_ to auto-determine
the conversion direction from the input and output file names:: 

  defaults.code_extensions = defaults.languages.keys()
  

The `text_extensions` are used by `OptionValues._get_outfile` to
auto-determine the output filename::

  defaults.text_extensions = [".txt"]
  

`Comment strings` for the various known languages include a trailing space.
Used in Code2Text_ to recognise text blocks and in Text2Code_ to format text
blocks as comments::

  defaults.comment_strings = {"python": '# ',
                              "slang":  '% ', 
                              "c++":    '// ',
                              "elisp":  ';; '}  
  
Marker string for a header code block in the text source. (Should be a valid
rst directive that accepts code on the same line, e.g. ``'..
admonition::'``.) No trailing whitespace needed as indented code follows.
Default is a comment marker::
  
  defaults.header_string = '..'
  

Export to the output format stripping text or code blocks::

  defaults.strip = False
        
Number of spaces to indent code blocks in `Code2Text.code`_. [#]_ ::

  defaults.codeindent =  2
  
.. [#] In `Text2Code.code`_, the codeindent is determined by the
       first recognized code line (leading comment or first indented literal
       block of the text source).


What to do if the outfile already exists? (Irrelevant if `outfile` == '-'.)

Recognized values:

:'yes':    overwrite eventually existing `outfile`,
:'update': fail if the `outfile` is newer than `infile`,
:'no':     fail if `outfile` exists.
                      
::

  defaults.overwrite = 'update'
  

Converter Classes
=================

Converter
---------

The converters are implemented as classes derived from a `Converter`
parent class: `Text2Code`_ converts a text source to executable code, while
`Code2Text`_ does the opposite: converting commented code to a text source.

::

  class PyLitConverter(object):
      """parent class for `Text2Code` and `Code2Text`, the state machines
      converting between text source and code source of a literal program.
      """
  
The converter classes implement a simple state machine to separate and
transform documentation and code blocks. For this task, only a very limited
parsing is needed. PyLit's parser assumes:

* indented literal blocks in a text source are code blocks.

* comment lines that start with a matching comment string in a code source
  are documentation blocks.

  
Data attributes
~~~~~~~~~~~~~~~

Class default values are fetched from the `defaults`_ object and can be
overridden by matching keyword arguments during class instantiation. This
also works with keyword arguments to `get_converter`_ and `main`_, as these
functions pass on unused keyword args to the instantiation of a converter
class. ::

      language = defaults.fallback_language
      comment_strings = defaults.comment_strings
      comment_string = "" # set in __init__
      codeindent =  defaults.codeindent
      header_string = defaults.header_string
      strip = defaults.strip
  
Initial state (do not overwrite)::

      state = 'header' 
  
Converter.__init__
~~~~~~~~~~~~~~~~~~

Initializing sets up the `data` attribute, an iterable object yielding lines
of the source to convert. [1]_ Additional keyword arguments are stored as
data attributes, overwriting the class defaults. If not given as keyword
argument, `comment_string` is set to the language's default comment
string::

      def __init__(self, data, **keyw):
          """data   --  iterable data object 
                        (list, file, generator, string, ...)
             **keyw --  remaining keyword arguments are 
                        stored as data-attributes 
          """
          self.data = data
          self.__dict__.update(keyw)
          if not self.comment_string:
              self.comment_string = self.comment_strings[self.language]
              
.. [1] The most common choice of data is a `file` object with the text
       or code source.

       To convert a string into a suitable object, use its splitlines method
       with the optional `keepends` argument set to True.


Converter.__call__
~~~~~~~~~~~~~~~~~~

The special `__call__` method allows the use of class instances as callable
objects. It returns the converted data as list::

      def __call__(self):
          """Iterate over state-machine and return results as a list"""
          return [token for token in self]
  
TODO: return a list of lines?

  
Converter.__str__
~~~~~~~~~~~~~~~~~

Return converted data as string::

      def __str__(self):
          blocks = ["".join(block) for block in self()]
          return "".join(blocks)
  

Converter.get_indent
~~~~~~~~~~~~~~~~~~~~

Return the number of leading spaces in `line` after expanding tabs ::

      def get_indent(self, line):
          """Return the indentation of `string`.
          """
          # line = line.expandtabs() # now done in `collect_blocks`
          return len(line) - len(line.lstrip())
  
Converter.ensure_trailing_blank_line
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ensure there is a blank line as last element of the list `lines`.
(currently not used)::

      def ensure_trailing_blank_line(self, lines, next_line):
          if not lines:
              return
          if lines[-1].lstrip(): 
              sys.stderr.write("\nWarning: inserted blank line between\n %s %s"
                               %(lines[-1], next_line))
              lines.append("\n")
  

Converter.collect_blocks
~~~~~~~~~~~~~~~~~~~~~~~~

A generator function to aggregate "paragraphs" (blocks separated by blank
lines).::

      def collect_blocks(self): 
          """collect lines in a list 
          
          yield list for each block of lines (paragraph) seperated by a 
          blank line (whitespace only).
          
          Also expand hard-tabs as these will lead to errors in indentation.
          """
          block = []
          for line in self.data:
              block.append(line.expandtabs())
              if not line.rstrip():
                  yield block
                  block = []
          yield block
                  

Text2Code
---------

The `Text2Code` class separates code blocks (indented literal blocks) from
documentation. Code blocks are unindented, documentation is commented (or
filtered, if the ``strip`` option is True.

Only `indented literal blocks` are extracted. `quoted literal blocks` and
`pydoc blocks` are treated as text. This allows the easy inclusion of
examples: [#]_

   >>> 23 + 3
   26

.. [#] Mark that there is no double colon before the doctest block in
       the text source.

Using the full blown docutils_ rst parser would introduce a large overhead
and slow down the conversion.
::

  class Text2Code(PyLitConverter):
      """Convert a (reStructured) text source to code source
      """
  
Text2Code.__iter__
~~~~~~~~~~~~~~~~~~
 
::

      def __iter__(self):
          """Iterate over text source and yield converted blocks
          """
  
Initialize data arguments

`state`
  :"header": first block -> check for leading `header_string`
  :"text":   documentation part -> comment out
  :"code":   literal blocks containing source code -> unindent
`_codeindent`
  * stripped from all 'code' block lines. 
  * set in `Text2Code.code`_ to the indent of first non-blank code line
`_textindent`
  * set by `Text2Code.text`_ to the minimal indent of a text block
  * used in `Text2Code.set_state`_ to find the end of a code block

::
       
          self.state = "header"
          self._codeindent = None  
          self._textindent = 0
  
Iterate over blocks of lines. 

Data is collected into "blocks" separated by blank lines by
`Converter.collect_blocks`_. Determine the state of the block ("text" or
"code") and yield the block converted by the matching "handler" method::

          for block in self.collect_blocks():
              self.set_state(block)
              yield getattr(self, self.state)(block)
              

Text2Code.set_state
~~~~~~~~~~~~~~~~~~~~~

::

      def set_state(self, block):
          """Determine and set state of `block` ("text" or "code"). """
  
If the current state is "header" (first block), check for
the  `header_string`. Strip if present. ::
          
          if self.state == "header":
              if block[0].startswith(self.header_string):
                  block[0] = block[0].replace(self.header_string, "", 1)
                  self.state = "code"
              else:
                  self.state = "text"
  
A literal block ends with the first less indented, nonblank line.
`_textindent` is set by the text handler to the indent of the
preceding text block::

          elif self.state == "code":
              indents = [self.get_indent(line) for line in block]
              if min(indents) <= self._textindent:
                  self.state = 'text'
              else:
                  self.state = 'code'
  
TODO: insert blank line before the first line with too-small codeindent
using self.ensure_trailing_blank_line(lines, line) (would need split and
push-back of the text part)?

Text2Code.text
~~~~~~~~~~~~~~

The 'text' handler processes everything that is not an indented literal
comment. Text is quoted with `self.comment_string` or filtered (with
`--strip=True`). ::

      def text(self, lines):
          """Convert text blocks from rst to comment
          """
          
          lines = [self.comment_string + line for line in lines]
                  
Test for the end of the text block: does the second last line end with
`::` but is neither a comment nor a directive?
If end-of-text marker is detected, 

* set state to 'code'
* set `self._textindent` (needed by `Text2Code.set_state`_ to find the
  next "text" block)
* remove the comment from the last line again (it's a separator between text
  and code blocks).

TODO: allow different code marking directives (for syntax color etc)
::

          try:
              line = lines[-2]
          except IndexError:  # len(lines < 2), e.g. last line of document
              pass
          else:
              if (line.rstrip().endswith("::") 
                  and not line.lstrip().startswith("..")):
                  self.state = "code"
                  self._textindent = self.get_indent(line)
                  lines[-1] = lines[-1].replace(self.comment_string, "", 1)
  
          if self.strip:
              return []
          return lines
      
TODO: Ensure a trailing blank line? Would need to test all
text lines for end-of-text marker and add a line by calling the
`ensure_trailing_blank_line` method (which also issues a warning)


Text2Code.code
~~~~~~~~~~~~~~

The `code` handler is called with an indented literal block. It removes
leading whitespace up to the indentation of the first code line in the file
(this deviation from docutils behaviour allows indented blocks of Python
code). ::

      def code(self, block): 
          """Convert indented literal blocks to source code
          """
          
If still unset, determine the code indentation from first non-blank code
line::

          if self._codeindent is None:
              self._codeindent = self.get_indent(block[0])
  
Check if we can safely unindent the code block. There must not be lines less
indented then `_codeindent` otherwise something got wrong. ::

          for line in block:
              if line.lstrip() and self.get_indent(line) < self._codeindent:
                  raise ValueError, "code block contains line less indented " \
                                  "than %d spaces \n%r"%(self._codeindent, block)
  
return unindented block::

          return [line.replace(" "*self._codeindent, "", 1) for line in block]
  

Txt2Code.strip_literal_marker
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Remove literal marker (::) in "expanded form" i.e. in a paragraph on its own.

While cleaning up the code source, it leads to confusion for doctest and
searches (e.g. grep) as line-numbers between text and code source will
differ. 
The code is left here, as it can be used for conversion of
a literal marker to a different code-marker

.. parsed-literal::

      def strip_literal_marker(list):
          try:
              # print lines[-3:]
              if (lines[-3].strip() == self.comment_string.strip() 
                  and lines[-2].strip() == self.comment_string + '::'):
                  del(lines[-3:-1])
          except IndexError:
              pass
  

Code2Text
---------

The `Code2Text` class does the opposite of `Text2Code`_ -- it processes
valid source code, extracts comments, and puts non-commented code in literal
blocks. 

The class is derived from the PyLitConverter state machine and adds  an
`__iter__` method as well as handlers for "text", and "code" states. ::

  class Code2Text(PyLitConverter):
      """Convert code source to text source
      """
  
Code2Text.__iter__
~~~~~~~~~~~~~~~~~~

::

      def __iter__(self):
  
If the last text block doesnot end with a code marker (by default, the
literal-block marker ``::``), the `text` method will set `code marker` to
a paragraph that will start the next code block. It is yielded if non-empty
at a text-code transition. If there is no preceding text block, `code_marker`
contains the  `header_string`::

          if self.strip:
              self.code_marker = []
          else:
              self.code_marker = [self.header_string]
          
          for block in self.collect_blocks():
              
Test the state of the block with `Code2Text.block_is_text`_, return it
processed with the matching handler::

              if self.block_is_text(block):
                  self.state = "text"
              else:
                  if self.state != "code" and self.code_marker:
                      yield self.code_marker
                  self.state = "code"
              yield getattr(self, self.state)(block)
  
"header" state
~~~~~~~~~~~~~~~~

Sometimes code needs to remain on the first line(s) of the document to be
valid. The most common example is the "shebang" line that tells a POSIX
shell how to process an executable file::

  #!/usr/bin/env python
  
In Python, the ``# -*- coding: iso-8859-1 -*-`` line must occure before any
other comment or code.

If we want to keep the line numbers in sync for text and code source, the
reStructured Text markup for these header lines must start at the same line
as the first header line. Therfore, header lines could not be marked as
literal block (this would require the ``::`` and an empty line above the code).

OTOH, a comment may start at the same line as the comment marker and it
includes subsequent indented lines. Comments are visible in the reStructured
Text source but hidden in the pretty-printed output.

With a header converted to comment in the text source, everything before the
first text block (i.e. before the first paragraph using the matching comment
string) will be hidden away (in HTML or PDF output). 

This seems a good compromise, the advantages

* line numbers are kept
* the "normal" code conversion rules (indent/unindent by `codeindent` apply
* greater flexibility: you can hide a repeating header in a project
  consisting of many source files.

set off the disadvantages

- it may come as surprise if a part of the file is not "printed",
- one more syntax element to learn for rst newbees to start with pylit,
  (however, starting from the code source, this will be auto-generated)

In the case that there is no matching comment at all, the complete code
source will become a comment -- however, in this case it is not very likely
the source is a literate document anyway.

If needed for the documentation, it is possible to repeat the header in (or
after) the first text block, e.g. with a `line block` in a `block quote`:

  |  ``#!/usr/bin/env python``
  |  ``# -*- coding: iso-8859-1 -*-``

The current implementation represents the header state by the setting of
`code_marker` to ``[self.header_string]``. The first non-empty text block
will overwrite this setting.

Code2Text.text
~~~~~~~~~~~~~~

The *text state handler* converts a comment to a text block by stripping
the leading `comment string` from every line::

      def text(self, lines):
          """Uncomment text blocks in source code
          """
          
          lines = [line.replace(self.comment_string, "", 1) for line in lines]
  
          lines = [re.sub("^"+self.comment_string.rstrip(), "", line)
                   for line in lines]
  
If the code block is stripped, the literal marker would lead to an error
when the text is converted with docutils. Replace it with
`Code2Text.strip_literal_marker`_::
          
          if self.strip:
              self.strip_literal_marker(lines)
              self.code_marker = []
  
Check for code block marker (double colon) at the end of the text block
Update the `code_marker` argument. (The `code marker` is yielded by
`Code2Text.__iter__`_ at a text -> code transition if it is not empty)::

          elif len(lines)>1:
              if lines[-2].rstrip().endswith("::"):
                  self.code_marker = []
              else:
                  self.code_marker = ["::\n", "\n"]
  
Return the text block to the calling function::

          return lines
                       

Code2Text.code
~~~~~~~~~~~~~~

The `code` method is called on non-commented code. Code is returned as
indented literal block (or filtered, if ``self.strip == True``). The amount
of the code indentation is controled by `self.codeindent` (default 2). 
::

      def code(self, lines):
          """Indent lines or strip if `strip` == `True`
          """
          if self.strip == True:
              return []
  
          return [" "*self.codeindent + line for line in lines]
  
Code2Text.block_is_text
~~~~~~~~~~~~~~~~~~~~~~~

A paragraph is a text block, if every non-blank line starts with a matching
comment string  (test includes whitespace except for commented blank lines!)
::

      def block_is_text(self, block):
          for line in block:
              if (line.rstrip() 
                  and not line.startswith(self.comment_string)
                  and line.rstrip() != self.comment_string.rstrip()):
                  return False
          return True
    
Code2Text.strip_literal_marker
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Replace the literal marker with the equivalent of docutils replace rules

* strip `::`-line (and preceding blank line) if on a line on its own
* strip `::` if it is preceded by whitespace. 
* convert `::` to a single colon if preceded by text

`lines` should be list of text lines (with a trailing blank line). 
It is modified in-place::

      def strip_literal_marker(self, lines):
          try:
              line = lines[-2]
          except IndexError:  # len(lines < 2)
              return
          
          # split at rightmost '::'
          try:
              (head, tail) = line.rsplit('::', 1)
          except ValueError:  # only one part (no '::')
              return
          
          # '::' on an extra line
          if not head.strip():            
              del(lines[-2])
              # delete preceding line if it is blank
              if len(lines) >= 2 and not lines[-2].lstrip():
                  del(lines[-2])
          # '::' follows whitespace                
          elif head.rstrip() < head:      
              head = head.rstrip()
              lines[-2] = "".join((head, tail))
          # '::' follows text        
          else:
              lines[-2] = ":".join((head, tail))
  

Command line use
================

Using this script from the command line will convert a file according to its
extension. This default can be overridden by a couple of options.

Dual source handling
--------------------

How to determine which source is up-to-date?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- set modification date of `oufile` to the one of `infile` 

  Points out that the source files are 'synchronized'. 
  
  * Are there problems to expect from "backdating" a file? Which?

    Looking at http://www.unix.com/showthread.php?t=20526, it seems
    perfectly legal to set `mtime` (while leaving `ctime`) as `mtime` is a
    description of the "actuality" of the data in the file.

  * Should this become a default or an option?

- alternatively move input file to a backup copy (with option: `--replace`)
  
- check modification date before overwriting 
  (with option: `--overwrite=update`)
  
- check modification date before editing (implemented as `Jed editor`_
  function `pylit_check()` in `pylit.sl`_)

.. _Jed editor: http://www.jedsoft.org/jed/
.. _pylit.sl: http://jedmodes.sourceforge.net/mode/pylit/

Recognised Filename Extensions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of defining a new extension for "pylit" literate programms,
by default ``.txt`` will be appended for the text source and stripped by
the conversion to the code source. I.e. for a Python program foo:

* the code source is called ``foo.py``
* the text source is called ``foo.py.txt``
* the html rendering is called ``foo.py.html``


OptionValues
------------

The following class adds `as_dict` and `__getattr__` methods to
`optparse.Values`::

  class OptionValues(optparse.Values):
  
OptionValues.as_dict
~~~~~~~~~~~~~~~~~~~~

For use as keyword arguments, it is handy to have the options in a
dictionary. `as_dict` returns a copy of the instances object dictionary::
      
      def as_dict(self):
          """Return options as dictionary object"""
          return self.__dict__.copy()
  
OptionValues.complete
~~~~~~~~~~~~~~~~~~~~~

::

      def complete(self, **keyw):
          """
          Complete the option values with keyword arguments.
          
          Do not overwrite existing values. Only use arguments that do not
          have a corresponding attribute in `self`, 
          """
          for key in keyw:
              if not self.__dict__.has_key(key):
                  setattr(self, key, keyw[key])
  
OptionValues.__getattr__
~~~~~~~~~~~~~~~~~~~~~~~~

To replace calls using ``options.ensure_value("OPTION", None)`` with the
more concise ``options.OPTION``, we define `__getattr__` [#]_ ::
    
      def __getattr__(self, name): 
          """Return default value for non existing options"""
          return None
  

.. [#] The special method `__getattr__` is only called when an attribute
       lookup has not found the attribute in the usual places (i.e. it is
       not an instance attribute nor is it found in the class tree for
       self).


PylitOptions
------------

The `PylitOptions` class comprises an option parser and methods for parsing
and completion of command line options::
  
  class PylitOptions(object):
      """Storage and handling of command line options for pylit"""
  
Instantiation       
~~~~~~~~~~~~~

::

      def __init__(self):
          """Set up an `OptionParser` instance for pylit command line options
  
          """
          p = optparse.OptionParser(usage=main.__doc__, version=_version)
          # add the options
          p.add_option("-c", "--code2txt", dest="txt2code", action="store_false",
                       help="convert code source to text source")
          p.add_option("--comment-string", dest="comment_string",
                       help="text block marker (default '# ' (for python))" )
          p.add_option("-d", "--diff", action="store_true", 
                       help="test for differences to existing file")
          p.add_option("--doctest", action="store_true",
                       help="run doctest.testfile() on the text version")
          p.add_option("-e", "--execute", action="store_true",
                       help="execute code (Python only)")
          p.add_option("--language", action="store", 
                       choices = defaults.languages.values(),
                       help="use LANGUAGE native comment style")
          p.add_option("--overwrite", action="store", 
                       choices = ["yes", "update", "no"],
                       help="overwrite output file (default 'update')")
          p.add_option("--replace", action="store_true",
                       help="move infile to a backup copy (appending '~')")
          p.add_option("-s", "--strip", action="store_true",
                       help="export by stripping text or code")
          p.add_option("-t", "--txt2code", action="store_true",
                       help="convert text source to code source")
          self.parser = p
  

PylitOptions.parse_args
~~~~~~~~~~~~~~~~~~~~~~~

The `parse_args` method calls the `optparse.OptionParser` on command
line or provided args and returns the result as `PylitOptions.Values`
instance. Defaults can be provided as keyword arguments::

      def parse_args(self, args=sys.argv[1:], **keyw):
          """parse command line arguments using `optparse.OptionParser`
          
             parse_args(args, **keyw) -> OptionValues instance
          
              args --  list of command line arguments.
              keyw --  keyword arguments or dictionary of option defaults
          """
          # parse arguments
          (values, args) = self.parser.parse_args(args, OptionValues(keyw))
          # Convert FILE and OUTFILE positional args to option values
          # (other positional arguments are ignored)
          try:
              values.infile = args[0]
              values.outfile = args[1]
          except IndexError:
              pass
          
          return values
  
PylitOptions.complete_values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Complete an OptionValues instance `values`.  Use module-level defaults and
context information to set missing option values to sensible defaults (if
possible) ::

      def complete_values(self, values):
          """complete option values with module and context sensible defaults
          
          x.complete_values(values) -> values
          values -- OptionValues instance
          """
          
Complete with module-level defaults_::

          values.complete(**defaults.__dict__)
  
Ensure infile is a string::

          values.ensure_value("infile", "")
  
Guess conversion direction from `infile` filename::

          if values.txt2code is None:
              in_extension = os.path.splitext(values.infile)[1]
              if in_extension in values.text_extensions:
                  values.txt2code = True
              elif in_extension in values.code_extensions:
                  values.txt2code = False
  
Auto-determine the output file name::

          values.ensure_value("outfile", self._get_outfile_name(values))
          
Second try: Guess conversion direction from outfile filename::

          if values.txt2code is None:
              out_extension = os.path.splitext(values.outfile)[1]
              values.txt2code = not (out_extension in values.text_extensions)
          
Set the language of the code::

          if values.txt2code is True:
              code_extension = os.path.splitext(values.outfile)[1]
          elif values.txt2code is False:
              code_extension = os.path.splitext(values.infile)[1]
          values.ensure_value("language", 
                              values.languages.get(code_extension, 
                                                   values.fallback_language))
              
          return values
  
PylitOptions._get_outfile_name
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Construct a matching filename for the output file. The output filename is
constructed from `infile` by the following rules:

* '-' (stdin) results in '-' (stdout)
* strip the `txt_extension` (txt2code) or
* add a `txt_ extension` (code2txt)
* fallback: if no guess can be made, add ".out"
  
  .. TODO: use values.outfile_extension if it exists?
  
::

      def _get_outfile_name(self, values):
          """Return a matching output filename for `infile`
          """
          # if input is stdin, default output is stdout
          if values.infile == '-':
              return '-'
          
          # Derive from `infile` name: strip or add text extension
          (base, ext) = os.path.splitext(values.infile)
          if ext in values.text_extensions: 
              return base # strip
          if ext in values.code_extensions or values.txt2code == False:
              return values.infile + values.text_extensions[0] # add
          # give up
          return values.infile + ".out"
  
PylitOptions.__call__
~~~~~~~~~~~~~~~~~~~~~

The special `__call__` method allows to use PylitOptions instances as
*callables*: Calling an instance parses the argument list to extract option
values and completes them based on "context-sensitive defaults".  Keyword
arguments are passed to `PylitOptions.parse_args`_ as default values. ::

      def __call__(self, args=sys.argv[1:], **keyw):
          """parse and complete command line args return option values
          """
          values = self.parse_args(args, **keyw)
          return self.complete_values(values)
  


Helper functions
----------------

open_streams
~~~~~~~~~~~~

Return file objects for in- and output. If the input path is missing,
write usage and abort. (An alternative would be to use stdin as default.
However,  this leaves the uninitiated user with a non-responding application
if (s)he just tries the script without any arguments) ::

  def open_streams(infile = '-', outfile = '-', overwrite='update', **keyw):
      """Open and return the input and output stream
      
      open_streams(infile, outfile) -> (in_stream, out_stream)
      
      in_stream   --  file(infile) or sys.stdin
      out_stream  --  file(outfile) or sys.stdout
      overwrite   --  'yes': overwrite eventually existing `outfile`,
                      'update': fail if the `outfile` is newer than `infile`,
                      'no': fail if `outfile` exists.
                      
                      Irrelevant if `outfile` == '-'.
      """
      if not infile:
          strerror = "Missing input file name ('-' for stdin; -h for help)"
          raise IOError, (2, strerror, infile)
      if infile == '-':
          in_stream = sys.stdin
      else:
          in_stream = file(infile, 'r')
      if outfile == '-':
          out_stream = sys.stdout
      elif overwrite == 'no' and os.path.exists(outfile):
          raise IOError, (1, "Output file exists!", outfile)
      elif overwrite == 'update' and is_newer(outfile, infile):
          raise IOError, (1, "Output file is newer than input file!", outfile)
      else:
          out_stream = file(outfile, 'w')
      return (in_stream, out_stream)
  
is_newer
~~~~~~~~

::  

  def is_newer(path1, path2):
      """Check if `path1` is newer than `path2` (using mtime)
      
      Compare modification time of files at path1 and path2.
      
      Non-existing files are considered oldest: Return False if path1 doesnot
      exist and True if path2 doesnot exist.
      
      Return None for equal modification time. (This evaluates to False in a
      boolean context but allows a test for equality.)
      
      """
      try:
          mtime1 = os.path.getmtime(path1)
      except OSError:
          mtime1 = -1
      try:
          mtime2 = os.path.getmtime(path2)
      except OSError:
          mtime2 = -1
      # print "mtime1", mtime1, path1, "\n", "mtime2", mtime2, path2
      
      if mtime1 == mtime2:
          return None
      return mtime1 > mtime2
  

get_converter
~~~~~~~~~~~~~

Get an instance of the converter state machine::

  def get_converter(data, txt2code=True, **keyw):
      if txt2code:
          return Text2Code(data, **keyw)
      else:
          return Code2Text(data, **keyw)
  

Use cases
---------

run_doctest
~~~~~~~~~~~

::

  def run_doctest(infile="-", txt2code=True, 
                  globs={}, verbose=False, optionflags=0, **keyw):
      """run doctest on the text source
      """
      from doctest import DocTestParser, DocTestRunner
      (data, out_stream) = open_streams(infile, "-")
      
If source is code, convert to text, as tests in comments are not found by
doctest::
    
      if txt2code is False: 
          converter = Code2Text(data, **keyw)
          docstring = str(converter)
      else: 
          docstring = data.read()
          
Use the doctest Advanced API to do all doctests in a given string::
    
      test = DocTestParser().get_doctest(docstring, globs={}, name="", 
                                             filename=infile, lineno=0)
      runner = DocTestRunner(verbose=verbose, optionflags=optionflags)
      runner.run(test)
      runner.summarize
      if not runner.failures:
          print "%d failures in %d tests"%(runner.failures, runner.tries)
      return runner.failures, runner.tries
  

diff
~~~~

::

  def diff(infile='-', outfile='-', txt2code=True, **keyw):
      """Report differences between converted infile and existing outfile
      
      If outfile is '-', do a round-trip conversion and report differences
      """
      
      import difflib
      
      instream = file(infile)
      # for diffing, we need a copy of the data as list::
      data = instream.readlines()
      # convert
      converter = get_converter(data, txt2code, **keyw)
      new = str(converter).splitlines(True)
      
      if outfile != '-':
          outstream = file(outfile)
          old = outstream.readlines()
          oldname = outfile
          newname = "<conversion of %s>"%infile
      else:
          old = data
          oldname = infile
          # back-convert the output data
          converter = get_converter(new, not txt2code)
          new = str(converter).splitlines(True)
          newname = "<round-conversion of %s>"%infile
          
      # find and print the differences
      delta = list(difflib.unified_diff(old, new, 
                                        fromfile=oldname, tofile=newname))
      if delta:
          print "".join(delta)
      else:
          print oldname
          print newname
          print "no differences found"
      return bool(delta)
  

execute
~~~~~~~

Works only for python code.

Doesnot work with `eval`, as code is not just one expression. ::

  def execute(infile="-", txt2code=True, **keyw):
      """Execute the input file. Convert first, if it is a text source.
      """
      
      data = file(infile)
      if txt2code: 
          data = str(Text2Code(data, **keyw))
      # print "executing " + options.infile
      exec data
  

main
----

If this script is called from the command line, the `main` function will
convert the input (file or stdin) between text and code formats.

Option default values for the conversion can be given as keyword arguments
to `main`_.  The option defaults will be updated by command line options and
extended with "intelligent guesses" by `PylitOptions`_ and passed on to
helper functions and the converter instantiation.

This allows easy customization for programmatic use -- just call `main`
with the appropriate keyword options, e.g.:

>>> main(comment_string="## ")

::

  def main(args=sys.argv[1:], **defaults):
      """%prog [options] INFILE [OUTFILE]
      
      Convert between (reStructured) text source with embedded code,
      and code source with embedded documentation (comment blocks)
      
      The special filename '-' stands for standard in and output.
      """
  
Parse and complete the options::

      options = PylitOptions()(args, **defaults)
      # print "infile", repr(options.infile)
  
Special actions with early return::

      if options.doctest:
          return run_doctest(**options.as_dict())
  
      if options.diff:
          return diff(**options.as_dict())
  
      if options.execute:
          return execute(**options.as_dict())
  
Open in- and output streams::

      try:
          (data, out_stream) = open_streams(**options.as_dict())
      except IOError, ex:
          print "IOError: %s %s" % (ex.filename, ex.strerror)
          sys.exit(ex.errno)
      
Get a converter instance::

      converter = get_converter(data, **options.as_dict())
        
Convert and write to out_stream::

      out_stream.write(str(converter))
      
      if out_stream is not sys.stdout:
          print "extract written to", out_stream.name
          out_stream.close()
  
If input and output are from files, set the modification time (`mtime`) of
the output file to the one of the input file to indicate that the contained
information is equal. [#]_ ::

          try:
              os.utime(options.outfile, (os.path.getatime(options.outfile),
                                         os.path.getmtime(options.infile))
                      )
          except OSError:
              pass
  
      ## print "mtime", os.path.getmtime(options.infile),  options.infile 
      ## print "mtime", os.path.getmtime(options.outfile), options.outfile
  

.. [#] Make sure the corresponding file object (here `out_stream`) is
       closed, as otherwise the change will be overwritten when `close` is 
       called afterwards (either explicitely or at program exit).


Rename the infile to a backup copy if ``--replace`` is set::
 
      if options.replace:
          os.rename(options.infile, options.infile + "~")
          

Run main, if called from the command line::

  if __name__ == '__main__':
      main()
   

Open questions
==============

Open questions and ideas for further development

Clean code
----------

* can we gain from using "shutils" over "os.path" and "os"?
* use pylint or pyChecker to enfoce a consistent style? 

Options
-------

* Use templates for the "intelligent guesses" (with Python syntax for string
  replacement with dicts: ``"hello %(what)s" % {'what': 'world'}``)

* Is it sensible to offer the `header_string` option also as command line
  option?

* Configurable 
  
Parsing Problems
----------------------
    
* How can I include a literal block that should not be in the
  executable code (e.g. an example, an earlier version or variant)?

  Workarounds:
  
  - Use a `parsed-literal block`_ directive if there is no "accidential"
    markup in the literal code
    
  - Use a `line block`_ directive or the `line block syntax`_
    and mark all lines as `inline literals`_.

  - Python session examples and doctests can use `doctest block`_ syntax 
  
    No double colon! Start first line of block with ``>>>```.
              

  Not implemented yet:
  
  - use a special `code-block directive`_ or a special directive for
    ordinary literal blocks.
    
* Ignore "matching comments" in literal strings?

  Too complicated: Would need a specific detection algorithm for every
  language that supports multi-line literal strings (C++, PHP, Python)

* Warn if a comment in code will become text after round-trip?

code-block directive
--------------------

In a document where code examples are only one of several uses of literal
blocks, it would be more appropriate to single out the sourcecode with a
dedicated "code-block" directive.

Some highlight plug-ins require a special "sourcecode" or "code block"
directive instead of the ``::`` literal block marker. Actually,
syntax-highlight is possible without changes to docutils with the Pygments_
package using a "code-block" directive. See the `syntax highlight`_ section
in the features documentation.

TODO:

* provide a "code-block-marker" string option.

* correctly handle the case of ``code_block_marker == '::'`` and conversion
  of ``::`` to a different "code-block-marker" -- consider minimized forms.

doctstrings in code blocks
--------------------------

* How to handle docstrings in code blocks? (it would be nice to convert them
  to rst-text if ``__docformat__ == restructuredtext``)

TODO: Ask at docutils users|developers

.. References

.. _docutils: http://docutils.sourceforge.net/
.. _doctest block: 
    http://docutils.sf.net/docs/ref/rst/restructuredtext.html#doctest-blocks
.. _parsed-literal block: 
    http://docutils.sf.net/docs/ref/rst/directives.html#parsed-literal-block
.. _line block: 
    http://docutils.sourceforge.net/docs/ref/rst/directives.html#line-block
.. _line block syntax: 
    http://docutils.sf.net/docs/ref/rst/restructuredtext.html#line-blocks
.. _inline literals:
    http://docutils.sf.net/docs/ref/rst/restructuredtext.html#inline-literals
.. _pygments: http://pygments.org/
.. _syntax highlight: ../features/syntax-highlight.html
