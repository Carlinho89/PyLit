..  #!/usr/bin/env python
  # -*- coding: iso-8859-1 -*-
  
===============================================================
pylit.py: Literate programming with reStructuredText
===============================================================

:Date:      $Date$
:Version:   SVN-Revision $Revision$
:URL:       $URL$
:Copyright: 2005, 2007 Guenter Milde.
            Released under the terms of the GNU General Public License 
            (v. 2 or later)

.. sectnum::
.. contents::

Frontmatter
===========

Changelog
---------

:2005-06-29: Initial version.
:2005-06-30: First literate version.
:2005-07-01: Object orientated script using generators.
:2005-07-10: Two state machine (later added 'header' state).
:2006-12-04: Start of work on version 0.2 (code restructuring).
:2007-01-23: 0.2   Published at http://pylit.berlios.de.
:2007-01-25: 0.2.1 Outsourced non-core documentation to the PyLit pages.
:2007-01-26: 0.2.2 New behaviour of `diff` function.
:2007-01-29: 0.2.3 New `header` methods after suggestion by Riccardo Murri.
:2007-01-31: 0.2.4 Raise Error if code indent is too small.
:2007-02-05: 0.2.5 New command line option --comment-string.
:2007-02-09: 0.2.6 Add section with open questions,
                   Code2Text: let only blank lines (no comment str)
                   separate text and code,
                   fix `Code2Text.header`.
:2007-02-19: 0.2.7 Simplify `Code2Text.header`,
                   new `iter_strip` method replacing a lot of ``if``-s.
:2007-02-22: 0.2.8 Set `mtime` of outfile to the one of infile.
:2007-02-27: 0.3   New `Code2Text` converter after an idea by Riccardo Murri,
                   explicite `option_defaults` dict for easier customization.
:2007-03-02: 0.3.1 Expand hard-tabs to prevent errors in indentation,
                   `Text2Code` now also works on blocks,
                   removed dependency on SimpleStates module.
:2007-03-06: 0.3.2 Bugfix: do not set `language` in `option_defaults`
                   renamed `code_languages` to `languages`.
:2007-03-16: 0.3.3 New language css,
                   option_defaults -> defaults = optparse.Values(),
                   simpler PylitOptions: don't store parsed values,
                   don't parse at initialization,
                   OptionValues: return `None` for non-existing attributes,
                   removed -infile and -outfile, use positional arguments.
:2007-03-19: 0.3.4 Documentation update,
                   separate `execute` function.
:2007-03-21:       Code cleanup in `Text2Code.__iter__`.
:2007-03-23: 0.3.5 Removed "css" from languages after learning that 
                   there is no C++ style "// " comment in css2.
:2007-04-24: 0.3.6 Documentation update.
:2007-05-18: 0.4   Implement Converter.__iter__ as stack of iterator 
                   generators. Iterating over a converter instance now 
                   yields lines instead of blocks.
                   Provide "hooks" for pre- and postprocessing filters.
                   Rename states to avoid confusion with formats:
                   "text" -> "documentation", "code" -> "code_block".
:2007-05-22: 0.4.1 Converter.__iter__: cleanup and reorganization, 
                   rename Converter -> TextCodeConverter.
                   
             
::

  """pylit: bidirectional converter between a *text source* with embedded
  computer code and a *code source* with embedded documentation. 
  """
  
  __docformat__ = 'restructuredtext'
  
  _version = "0.3"
  

Introduction
------------

PyLit is a bidirectional converter between two formats of a computer
program source:

* a (reStructured) text document with program code embedded in 
  *code blocks*, and
* a compilable (or executable) code source with *documentation* embedded in
  comment blocks


Requirements
------------

::

  import re
  import os
  import sys
  import optparse
  
Customisation
=============

defaults
--------

The `defaults` object provides a central repository for default values
and their customisation. ::

  defaults = optparse.Values()
  
It is used for

* the initialization of data arguments in TextCodeConverter_ and
  PylitOptions_
  
* completion of command line options in `PylitOptions.complete_values`_.

This allows the easy creation of custom back-ends that customise the
defaults and then call main_ e.g.:

  >>> import pylit
  >>> defaults.comment_string = "## "
  >>> defaults.codeindent = 4
  >>> main()

The following default values are defined in pylit.py:

defaults.languages
~~~~~~~~~~~~~~~~~~

Mapping of code file extension to code language::

  defaults.languages  = {".py": "python", 
                         ".sl": "slang", 
                         ".c": "c++"}
  
Used by `OptionValues.complete`_ to set the `defaults.language`. The
 ``--language`` command line option or setting ``defaults.language`` in
 programmatic use overrides this auto-setting feature.

defaults.fallback_language
~~~~~~~~~~~~~~~~~~~~~~~~~~

Language to use, if there is no matching extension (e.g. if pylit is used as
filter) and no `language` is specified::

  defaults.fallback_language = "python"
  
defaults.code_extensions
~~~~~~~~~~~~~~~~~~~~~~~~

List of known extensions for source code files::

  defaults.code_extensions = defaults.languages.keys()
  
Used in `OptionValues.complete`_ to auto-determine the conversion direction
from the input and output file names.
  
defaults.text_extensions
~~~~~~~~~~~~~~~~~~~~~~~~

List of known extensions of (reStructured) text files::
 
  defaults.text_extensions = [".txt"]
  
Used by `OptionValues._get_outfile` to auto-determine the output filename.
  
defaults.comment_strings
~~~~~~~~~~~~~~~~~~~~~~~~

Dictionary of comment strings for known languages. Comment strings include
trailing whitespace. ::

  defaults.comment_strings = {"python": '# ',
                              "slang":  '% ', 
                              "c++":    '// '}  
  
Used in Code2Text_ to recognise text blocks and in Text2Code_ to format
text blocks as comments.

defaults.header_string
~~~~~~~~~~~~~~~~~~~~~~

Marker string for a header code block in the text source. No trailing
whitespace needed as indented code follows. Default is a comment marker::
  
  defaults.header_string = '..'
  
Must be a valid rst directive that accepts code on the same line, e.g.
``'..admonition::'``.
 
defaults.strip
~~~~~~~~~~~~~~

Export to the output format stripping documentation or code blocks::

  defaults.strip = False
  
defaults.preprocessors
~~~~~~~~~~~~~~~~~~~~~~

Preprocess the data with language-specific filters_::

  defaults.preprocessors = {}
  
defaults.postprocessors
~~~~~~~~~~~~~~~~~~~~~~~

Postprocess the data with language-specific filters_::

  defaults.postprocessors = {}
  
defaults.codeindent
~~~~~~~~~~~~~~~~~~~

Number of spaces to indent code blocks in `Code2Text.code_block_handler`_::

  defaults.codeindent =  2
  
In `Text2Code.code_block_handler`_, the codeindent is determined by the
first recognized code line (leading comment or first indented literal block
of the text source).
 
defaults.overwrite
~~~~~~~~~~~~~~~~~~

What to do if the outfile already exists? (ignored if `outfile` == '-')::

  defaults.overwrite = 'update'
  
Recognized values:

 :'yes':    overwrite eventually existing `outfile`,
 :'update': fail if the `outfile` is newer than `infile`,
 :'no':     fail if `outfile` exists.


Converter Classes
=================

The converter classes implement a simple state machine to separate and
transform documentation and code blocks. For this task, only a very limited
parsing is needed. PyLit's parser assumes:

* indented literal blocks in a text source are code blocks.

* comment lines that start with a matching comment string in a code source
  are documentation blocks.

TextCodeConverter
-----------------
::

  class TextCodeConverter(object):
      """Parent class for the converters `Text2Code` and `Code2Text`.
      """
  
The parent class defines data attributes and functions used in both

`Text2Code`_ 
 converting a text source to executable code source, and
`Code2Text`_ 
 converting commented code to a text source.
  
Data attributes
~~~~~~~~~~~~~~~

Class default values are fetched from the `defaults`_ object and can be
overridden by matching keyword arguments during class instantiation. This
also works with keyword arguments to `get_converter`_ and `main`_, as these
functions pass on unused keyword args to the instantiation of a converter
class. ::

      language = defaults.fallback_language
      comment_strings = defaults.comment_strings
      comment_string = "" # set in __init__
      codeindent =  defaults.codeindent
      header_string = defaults.header_string
      strip = defaults.strip
  
TextCodeConverter.__init__
~~~~~~~~~~~~~~~~~~~~~~~~~~

Initializing sets up the `data` attribute, an iterable object yielding lines
of the source to convert. [1]_ Additional keyword arguments are stored as
data attributes, overwriting the class defaults. If not given as keyword
argument, `comment_string` is set to the language's default comment
string::

      def __init__(self, data, **keyw):
          """data   --  iterable data object 
                        (list, file, generator, string, ...)
             **keyw --  remaining keyword arguments are 
                        stored as data-attributes 
          """
          self.data = data
          self.__dict__.update(keyw)
          if not self.comment_string:
              self.comment_string = self.comment_strings[self.language]
          self.preprocessor = self.get_filter("preprocessors", self.language)
          self.postprocessor = self.get_filter("postprocessors", self.language)
              
.. [1] The most common choice of data is a `file` object with the text
       or code source.

       To convert a string into a suitable object, use its splitlines method
       with the optional `keepends` argument set to True.
 

TextCodeConverter.__iter__
~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Return an iterator for `self`. Iteration yields lines of converted data.

The iterator is a chain of iterators acting on `self.data` that does

* preprocess
* text<->code format conversion
* postprocess

::

      def __iter__(self):
          """Iterate over input data source and yield converted lines
          """
          return self.postprocessor(self.convert(self.preprocessor(self.data)))
  

TextCodeConverter.__call__
~~~~~~~~~~~~~~~~~~~~~~~~~~
The special `__call__` method allows the use of class instances as callable
objects. It returns the converted data as list of lines::

      def __call__(self):
          """Iterate over state-machine and return results as list of lines"""
          return [line for line in self]
  

TextCodeConverter.__str__
~~~~~~~~~~~~~~~~~~~~~~~~~
Return converted data as string::

      def __str__(self):
          return "".join(self())
  

TextCodeConverter.get_filter
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Filter the  data by wrapping it in a language-specific pre- or
post-processing iterator. The filter must accept an iterable as first
argument and yield the processed input data linewise::

      def get_filter(self, filter_set, language):
          """Return language specific filter"""
          if self.__class__ == Text2Code:
              key = "text2"+language
          elif self.__class__ == Code2Text:
              key = language+"2text"
          else:
              key = ""
          try:
              return getattr(defaults, filter_set)[key]
          except (AttributeError, KeyError):
              # print "there is no %r filter in %r"%(key, filter_set)
              pass
          return identity_filter
  

TextCodeConverter.get_indent
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Return the number of leading spaces in `line` after expanding tabs ::

      def get_indent(self, line):
          """Return the indentation of `string`.
          """
          # line = line.expandtabs() # now done in `collect_blocks`
          return len(line) - len(line.lstrip())
  

TextCodeConverter.collect_blocks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A generator function to aggregate "paragraphs" (blocks separated by blank
lines)::

      def collect_blocks(self, lines):
          """collect lines in a list 
          
          yield list for each paragraph, i.e. block of lines seperated by a
          blank line (whitespace only).
          
          Also expand hard-tabs as these will lead to errors in indentation
          (see `str.expandtabs`).
          """
          block = []
          for line in lines:
              block.append(line.expandtabs())
              if not line.rstrip():
                  yield block
                  block = []
          yield block
  

Text2Code
---------

The `Text2Code` class separates code blocks (indented literal blocks) from
documentation. Code blocks are unindented, documentation is commented
(or filtered, if the ``strip`` option is True.

Only `indented literal blocks` are extracted. `quoted literal blocks` and
`pydoc blocks` are treated as text. This allows the easy inclusion of
examples: [#]_

   >>> 23 + 3
   26

.. [#] Mark that there is no double colon before the doctest block in
       the text source.

Using the full blown docutils_ rst parser would introduce a large overhead
and slow down the conversion.
::

  class Text2Code(TextCodeConverter):
      """Convert a (reStructured) text source to code source
      """
  
Text2Code.convert
~~~~~~~~~~~~~~~~~
This is the core state machine of the converter class::

      def convert(self, lines):
          """Iterate over lists of text lines and convert them to code format
          """
  # Initialize data arguments
  # 
  # Done here, so that every new iteration re-initializes them.
  # 
  # `state` is one of
  #   :"header": first block -> check for leading `header_string`
  #   :"documentation":   documentation part: comment out
  #   :"code_block":   literal blocks containing source code: unindent
  # 
  # ::
         
          self.state = ""
  
`codeindent`
  * stripped from all 'code_block' lines. 
  * set in `Text2Code.code_block_handler`_ to the indent of first non-blank 
    code_block line

::

          self._codeindent = None  
  
`_textindent`
  * set by `Text2Code.documentation_handler`_ to the minimal indent of a
    documentation block
  * used in `Text2Code.set_state`_ to find the end of a code block

::

          self._textindent = 0
  
Determine the state of the block and convert with the matching "handler"::

          for block in self.collect_blocks(lines):
              self.set_state(block)
              for line in getattr(self, self.state+"_handler")(block):
                  yield line
  

Text2Code.set_state
~~~~~~~~~~~~~~~~~~~~~
::

      def set_state(self, block):
          """Determine state of `block`. Set `self.state`
          """
      
          if not block:
              raise StopIteration
  
The new state depends on the active state (from the last block) and
features of the current block. It is either "header", "documentation", or
"code_block".

If the current state is "" (first block), check for
the  `header_string` indicating a leading code block::
          
          if self.state == "":
              # print "set state for %r"%block
              if block[0].startswith(self.header_string):
                  self.state = "header"
              else:
                  self.state = "documentation"
  
If the current state is "documentation", the next block is also
documentation. The end of a documentation part is detected in the
`Text2Code.documentation_handler`::

          # elif self.state == "documentation":
          #    self.state = "documentation"
  
A "code_block" ends with the first less indented, nonblank line.
`_textindent` is set by the documentation handler to the indent of the
preceding documentation block::

          elif self.state in ["code_block", "header"]:
              indents = [self.get_indent(line) for line in block]
              if indents and min(indents) <= self._textindent:
                  self.state = 'documentation'
              else:
                  self.state = 'code_block'
  
TODO: (or not to do?) insert blank line before the first line with too-small
codeindent using self.ensure_trailing_blank_line(lines, line) (would need
split and push-back of the documentation part)?

Text2Code.header_handler
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

      def header_handler(self, lines):
          """Format leading code block"""
          # strip header string from first line
          lines[0] = lines[0].replace(self.header_string, "", 1)
          # yield remaining lines formatted as code-block
          for line in self.code_block_handler(lines):
              yield line
  

Text2Code.documentation_handler
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The 'documentation' handler processes everything that is not an indented
literal comment. Documentation is quoted with `self.comment_string` or
filtered (with `--strip=True`). ::

      def documentation_handler(self, lines):
          """Convert documentation blocks from text to code format
          """
  
          lines = [self.comment_string + line for line in lines]
  
Test for the end of the documentation block: does the second last line end with
`::` but is neither a comment nor a directive?
If end-of-documentation marker is detected, 

* set state to 'code_block'
* set `self._textindent` (needed by `Text2Code.set_state`_ to find the
  next "documentation" block)
* remove the comment from the last line again (it's a separator between documentation
  and code blocks).

TODO: allow different code marking directives (for syntax color etc)
::

          try:
              line = lines[-2]
          except IndexError:  # len(lines < 2), e.g. last line of document
              pass
          else:
              if (line.rstrip().endswith("::") 
                  and not line.lstrip().startswith("..")):
                  self.state = "code_block"
                  self._textindent = self.get_indent(line)
                  lines[-1] = lines[-1].replace(self.comment_string, "", 1)
  
          if self.strip:
              return
          
          for line in lines:
              yield line
      
TODO: Ensure a trailing blank line? Would need to test all
documentation lines for end-of-documentation marker and add a line by calling the
`ensure_trailing_blank_line` method (which also issues a warning)


Text2Code.code_block_handler
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The "code_block" handler is called with an indented literal block. It
removes leading whitespace up to the indentation of the first code line in
the file (this deviation from docutils behaviour allows indented blocks of
Python code). ::

      def code_block_handler(self, block): 
          """Convert indented literal blocks to source code format
          """
          
If still unset, determine the indentation of code blocks from first non-blank
code line::

          if self._codeindent is None:
              self._codeindent = self.get_indent(block[0])
  
Yield unindented lines::

          for line in block:
  
Check if we can safely unindent. If the line is less indented then
`_codeindent`, something got wrong. ::

              if line.lstrip() and self.get_indent(line) < self._codeindent:
                  raise ValueError, "code block contains line less indented " \
                        "than %d spaces \n%r"%(self._codeindent, block)
              yield line.replace(" "*self._codeindent, "", 1)
  

Code2Text
---------

The `Code2Text` class does the opposite of `Text2Code`_ -- it processes
valid source code, extracts documentation from comment blocks, and puts
program code in literal blocks. 

The class is derived from the TextCodeConverter state machine and adds  an
`__iter__` method as well as handlers for "documentation", and "code_block"
states. ::

  class Code2Text(TextCodeConverter):
      """Convert code source to text source
      """
  
Code2Text.convert
~~~~~~~~~~~~~~~~~
::

      def convert(self, lines):
  
(re) set initial state. The leading block can be either "documentation" or
"header". This will be set by `Code2Text.set_state`_.

::

          self.state = ""
  
If the last paragraph of a documentation block does not end with a
"code_block_marker" (by default, the literal-block marker ``::``), it
must be added (otherwise, the back-conversion fails.).
`code_block_marker_missing` is set by `Code2Text.documentation_handler`_
and evaluated by `Code2Text.code_block_handler`_. ::

          self.code_block_marker_missing = False
          
Determine the state of the block return it processed with the matching
handler::

          for block in self.collect_blocks(lines):
              self.set_state(block)
              for line in getattr(self, self.state+"_handler")(block):
                  yield line
  

Code2Text.set_state
~~~~~~~~~~~~~~~~~~~

Check if block is "header", "documentation", or "code_block":  

A paragraph is "documentation", if every non-blank line starts with a matching
comment string (including whitespace except for commented blank lines) ::

      def set_state(self, block):
          """Determine state of `block`."""
          for line in block:
              # skip documentation lines (commented or blank)
              if line.startswith(self.comment_string):
                  continue
              if not line.rstrip():  # blank line
                  continue
              if line.rstrip() == self.comment_string.rstrip(): # blank comment
                  continue
              # non-documentation line found: the block is "header" or "code_block"
              if self.state == "":
                  self.state = "header"
              else:
                  self.state = "code_block"
              break
          else:
              self.state = "documentation"
  

Code2Text.header_handler
~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes code needs to remain on the first line(s) of the document to be
valid. The most common example is the "shebang" line that tells a POSIX
shell how to process an executable file::

  #!/usr/bin/env python
  
In Python, the ``# -*- coding: iso-8859-1 -*-`` line must occure before any
other comment or code.

If we want to keep the line numbers in sync for text and code source, the
reStructured Text markup for these header lines must start at the same line
as the first header line. Therfore, header lines could not be marked as
literal block (this would require the ``::`` and an empty line above the code_block).

OTOH, a comment may start at the same line as the comment marker and it
includes subsequent indented lines. Comments are visible in the reStructured
Text source but hidden in the pretty-printed output.

With a header converted to comment in the text source, everything before the
first documentation block (i.e. before the first paragraph using the matching comment
string) will be hidden away (in HTML or PDF output). 

This seems a good compromise, the advantages

* line numbers are kept
* the "normal" code_block conversion rules (indent/unindent by `codeindent` apply
* greater flexibility: you can hide a repeating header in a project
  consisting of many source files.

set off the disadvantages

- it may come as surprise if a part of the file is not "printed",
- one more syntax element to learn for rst newbees to start with pylit,
  (however, starting from the code source, this will be auto-generated)

In the case that there is no matching comment at all, the complete code
source will become a comment -- however, in this case it is not very likely
the source is a literate document anyway.

If needed for the documentation, it is possible to quote the header in (or
after) the first documentation block, e.g. as `parsed literal`.

::

      def header_handler(self, lines):
          """Format leading code block"""
          if self.strip == True:
              return
          # get iterator over the lines that formats them as code-block
          lines = iter(self.code_block_handler(lines)) 
          # prepend header string to first line
          yield self.header_string + lines.next()
          # yield remaining lines
          for line in lines:
              yield line
  
Code2Text.documentation_handler
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The *documentation state* handler converts a comment to a documentation block by
stripping the leading `comment string` from every line::

      def documentation_handler(self, lines):
          """Uncomment documentation blocks in source code
          """
  
If the code block is stripped, the literal marker would lead to
an error when the text is converted with docutils. Strip it as well.
Otherwise, check for the code block marker (``::``) at the end of
the documentation block::
          
          if self.strip:
              self.strip_literal_marker(lines)
          else:
              try:
                  self.code_block_marker_missing = not(lines[-2].rstrip().endswith("::"))
              except IndexError:  # len(lines < 2), e.g. last line of document
                  self.code_block_marker_missing = True
  
Strip comment strings and yield lines. Consider the case that a blank line
has a comment string without trailing whitespace::
        
          stripped_comment_string = self.comment_string.rstrip()
          
          for line in lines:
              line = line.replace(self.comment_string, "", 1)
              if line.rstrip() == stripped_comment_string:
                  line = line.replace(stripped_comment_string, "", 1)
              yield line
  

Code2Text.code_block_handler
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The `code_block` handler returns the code block as indented literal
block (or filters it, if ``self.strip == True``). The amount of the code
indentation is controled by `self.codeindent` (default 2).  ::

      def code_block_handler(self, lines):
          """Covert code blocks to text format (indent or strip)
          """
          if self.strip == True:
              return
          # eventually insert transition marker
          if self.code_block_marker_missing:
              self.state = "documentation"
              yield "::\n"
              yield "\n"
              self.state = "code_block"
          for line in lines:
              yield " "*self.codeindent + line
  


Code2Text.strip_literal_marker
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Replace the literal marker with the equivalent of docutils replace rules

* strip `::`-line (and preceding blank line) if on a line on its own
* strip `::` if it is preceded by whitespace. 
* convert `::` to a single colon if preceded by text

`lines` should be a list of documentation lines (with a trailing blank line). 
It is modified in-place::

      def strip_literal_marker(self, lines):
          try:
              line = lines[-2]
          except IndexError:  # len(lines < 2)
              return
          
          # split at rightmost '::'
          try:
              (head, tail) = line.rsplit('::', 1)
          except ValueError:  # only one part (no '::')
              return
          
          # '::' on an extra line
          if not head.strip():            
              del(lines[-2])
              # delete preceding line if it is blank
              if len(lines) >= 2 and not lines[-2].lstrip():
                  del(lines[-2])
          # '::' follows whitespace                
          elif head.rstrip() < head:      
              head = head.rstrip()
              lines[-2] = "".join((head, tail))
          # '::' follows text        
          else:
              lines[-2] = ":".join((head, tail))
  
Filters
=======

Filters allow pre- and post-processing of the data to bring it in a format
suitable for the "normal" text<->code conversion. An example is conversion
of `C` ``/*`` ``*/`` comments into C++ ``//`` comments (and back).

Filters are generator functions that return an iterator that acts on a
`data` iterable and returns processed `data` items (lines).

The most basic filter is the identity filter, that returns its argument as
iterator::

  def identity_filter(data):
      return iter(data)
  
Command line use
================

Using this script from the command line will convert a file according to its
extension. This default can be overridden by a couple of options.

Dual source handling
--------------------

How to determine which source is up-to-date?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- set modification date of `oufile` to the one of `infile` 

  Points out that the source files are 'synchronized'. 
  
  * Are there problems to expect from "backdating" a file? Which?

    Looking at http://www.unix.com/showthread.php?t=20526, it seems
    perfectly legal to set `mtime` (while leaving `ctime`) as `mtime` is a
    description of the "actuality" of the data in the file.

  * Should this become a default or an option?

- alternatively move input file to a backup copy (with option: `--replace`)
  
- check modification date before overwriting 
  (with option: `--overwrite=update`)
  
- check modification date before editing (implemented as `Jed editor`_
  function `pylit_check()` in `pylit.sl`_)

.. _Jed editor: http://www.jedsoft.org/jed/
.. _pylit.sl: http://jedmodes.sourceforge.net/mode/pylit/

Recognised Filename Extensions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of defining a new extension for "pylit" literate programms,
by default ``.txt`` will be appended for the text source and stripped by
the conversion to the code source. I.e. for a Python program foo:

* the code source is called ``foo.py``
* the text source is called ``foo.py.txt``
* the html rendering is called ``foo.py.html``


OptionValues
------------

The following class adds `as_dict` and `__getattr__` methods to
`optparse.Values`::

  class OptionValues(optparse.Values):
  
OptionValues.as_dict
~~~~~~~~~~~~~~~~~~~~

For use as keyword arguments, it is handy to have the options in a
dictionary. `as_dict` returns a copy of the instances object dictionary::
      
      def as_dict(self):
          """Return options as dictionary object"""
          return self.__dict__.copy()
  
OptionValues.complete
~~~~~~~~~~~~~~~~~~~~~

::

      def complete(self, **keyw):
          """
          Complete the option values with keyword arguments.
          
          Do not overwrite existing values. Only use arguments that do not
          have a corresponding attribute in `self`, 
          """
          for key in keyw:
              if not self.__dict__.has_key(key):
                  setattr(self, key, keyw[key])
  
OptionValues.__getattr__
~~~~~~~~~~~~~~~~~~~~~~~~

To replace calls using ``options.ensure_value("OPTION", None)`` with the
more concise ``options.OPTION``, we define `__getattr__` [#]_ ::
    
      def __getattr__(self, name): 
          """Return default value for non existing options"""
          return None
  

.. [#] The special method `__getattr__` is only called when an attribute
       lookup has not found the attribute in the usual places (i.e. it is
       not an instance attribute nor is it found in the class tree for
       self).


PylitOptions
------------

The `PylitOptions` class comprises an option parser and methods for parsing
and completion of command line options::
  
  class PylitOptions(object):
      """Storage and handling of command line options for pylit"""
  
Instantiation       
~~~~~~~~~~~~~

::

      def __init__(self):
          """Set up an `OptionParser` instance for pylit command line options
  
          """
          p = optparse.OptionParser(usage=main.__doc__, version=_version)
          # add the options
          p.add_option("-c", "--code2txt", dest="txt2code", action="store_false",
                       help="convert code source to text source")
          p.add_option("--comment-string", dest="comment_string",
                       help="documentation block marker (default '# ' (for python))" )
          p.add_option("-d", "--diff", action="store_true", 
                       help="test for differences to existing file")
          p.add_option("--doctest", action="store_true",
                       help="run doctest.testfile() on the text version")
          p.add_option("-e", "--execute", action="store_true",
                       help="execute code (Python only)")
          p.add_option("--language", action="store", 
                       choices = defaults.languages.values(),
                       help="use LANGUAGE native comment style")
          p.add_option("--overwrite", action="store", 
                       choices = ["yes", "update", "no"],
                       help="overwrite output file (default 'update')")
          p.add_option("--replace", action="store_true",
                       help="move infile to a backup copy (appending '~')")
          p.add_option("-s", "--strip", action="store_true",
                       help="export by stripping documentation or code")
          p.add_option("-t", "--txt2code", action="store_true",
                       help="convert text source to code source")
          self.parser = p
  

PylitOptions.parse_args
~~~~~~~~~~~~~~~~~~~~~~~

The `parse_args` method calls the `optparse.OptionParser` on command
line or provided args and returns the result as `PylitOptions.Values`
instance. Defaults can be provided as keyword arguments::

      def parse_args(self, args=sys.argv[1:], **keyw):
          """parse command line arguments using `optparse.OptionParser`
          
             parse_args(args, **keyw) -> OptionValues instance
          
              args --  list of command line arguments.
              keyw --  keyword arguments or dictionary of option defaults
          """
          # parse arguments
          (values, args) = self.parser.parse_args(args, OptionValues(keyw))
          # Convert FILE and OUTFILE positional args to option values
          # (other positional arguments are ignored)
          try:
              values.infile = args[0]
              values.outfile = args[1]
          except IndexError:
              pass
          
          return values
  
PylitOptions.complete_values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Complete an OptionValues instance `values`.  Use module-level defaults and
context information to set missing option values to sensible defaults (if
possible) ::

      def complete_values(self, values):
          """complete option values with module and context sensible defaults
          
          x.complete_values(values) -> values
          values -- OptionValues instance
          """
          
Complete with module-level defaults_::

          values.complete(**defaults.__dict__)
  
Ensure infile is a string::

          values.ensure_value("infile", "")
  
Guess conversion direction from `infile` filename::

          if values.txt2code is None:
              in_extension = os.path.splitext(values.infile)[1]
              if in_extension in values.text_extensions:
                  values.txt2code = True
              elif in_extension in values.code_extensions:
                  values.txt2code = False
  
Auto-determine the output file name::

          values.ensure_value("outfile", self._get_outfile_name(values))
          
Second try: Guess conversion direction from outfile filename::

          if values.txt2code is None:
              out_extension = os.path.splitext(values.outfile)[1]
              values.txt2code = not (out_extension in values.text_extensions)
          
Set the language of the code::

          if values.txt2code is True:
              code_extension = os.path.splitext(values.outfile)[1]
          elif values.txt2code is False:
              code_extension = os.path.splitext(values.infile)[1]
          values.ensure_value("language", 
                              values.languages.get(code_extension, 
                                                   values.fallback_language))
              
          return values
  
PylitOptions._get_outfile_name
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Construct a matching filename for the output file. The output filename is
constructed from `infile` by the following rules:

* '-' (stdin) results in '-' (stdout)
* strip the `txt_extension` (txt2code) or
* add a `txt_ extension` (code2txt)
* fallback: if no guess can be made, add ".out"
  
  .. TODO: use values.outfile_extension if it exists?
  
::

      def _get_outfile_name(self, values):
          """Return a matching output filename for `infile`
          """
          # if input is stdin, default output is stdout
          if values.infile == '-':
              return '-'
          
          # Derive from `infile` name: strip or add text extension
          (base, ext) = os.path.splitext(values.infile)
          if ext in values.text_extensions: 
              return base # strip
          if ext in values.code_extensions or values.txt2code == False:
              return values.infile + values.text_extensions[0] # add
          # give up
          return values.infile + ".out"
  
PylitOptions.__call__
~~~~~~~~~~~~~~~~~~~~~

The special `__call__` method allows to use PylitOptions instances as
*callables*: Calling an instance parses the argument list to extract option
values and completes them based on "context-sensitive defaults".  Keyword
arguments are passed to `PylitOptions.parse_args`_ as default values. ::

      def __call__(self, args=sys.argv[1:], **keyw):
          """parse and complete command line args return option values
          """
          values = self.parse_args(args, **keyw)
          return self.complete_values(values)
  


Helper functions
----------------

open_streams
~~~~~~~~~~~~

Return file objects for in- and output. If the input path is missing,
write usage and abort. (An alternative would be to use stdin as default.
However,  this leaves the uninitiated user with a non-responding application
if (s)he just tries the script without any arguments) ::

  def open_streams(infile = '-', outfile = '-', overwrite='update', **keyw):
      """Open and return the input and output stream
      
      open_streams(infile, outfile) -> (in_stream, out_stream)
      
      in_stream   --  file(infile) or sys.stdin
      out_stream  --  file(outfile) or sys.stdout
      overwrite   --  'yes': overwrite eventually existing `outfile`,
                      'update': fail if the `outfile` is newer than `infile`,
                      'no': fail if `outfile` exists.
                      
                      Irrelevant if `outfile` == '-'.
      """
      if not infile:
          strerror = "Missing input file name ('-' for stdin; -h for help)"
          raise IOError, (2, strerror, infile)
      if infile == '-':
          in_stream = sys.stdin
      else:
          in_stream = file(infile, 'r')
      if outfile == '-':
          out_stream = sys.stdout
      elif overwrite == 'no' and os.path.exists(outfile):
          raise IOError, (1, "Output file exists!", outfile)
      elif overwrite == 'update' and is_newer(outfile, infile):
          raise IOError, (1, "Output file is newer than input file!", outfile)
      else:
          out_stream = file(outfile, 'w')
      return (in_stream, out_stream)
  
is_newer
~~~~~~~~

::  

  def is_newer(path1, path2):
      """Check if `path1` is newer than `path2` (using mtime)
      
      Compare modification time of files at path1 and path2.
      
      Non-existing files are considered oldest: Return False if path1 doesnot
      exist and True if path2 doesnot exist.
      
      Return None for equal modification time. (This evaluates to False in a
      boolean context but allows a test for equality.)
      
      """
      try:
          mtime1 = os.path.getmtime(path1)
      except OSError:
          mtime1 = -1
      try:
          mtime2 = os.path.getmtime(path2)
      except OSError:
          mtime2 = -1
      # print "mtime1", mtime1, path1, "\n", "mtime2", mtime2, path2
      
      if mtime1 == mtime2:
          return None
      return mtime1 > mtime2
  

get_converter
~~~~~~~~~~~~~

Get an instance of the converter state machine::

  def get_converter(data, txt2code=True, **keyw):
      if txt2code:
          return Text2Code(data, **keyw)
      else:
          return Code2Text(data, **keyw)
  

Use cases
---------

run_doctest
~~~~~~~~~~~

::

  def run_doctest(infile="-", txt2code=True, 
                  globs={}, verbose=False, optionflags=0, **keyw):
      """run doctest on the text source
      """
      from doctest import DocTestParser, DocTestRunner
      (data, out_stream) = open_streams(infile, "-")
      
If source is code, convert to text, as tests in comments are not found by
doctest::
    
      if txt2code is False: 
          converter = Code2Text(data, **keyw)
          docstring = str(converter)
      else: 
          docstring = data.read()
          
Use the doctest Advanced API to do all doctests in a given string::
    
      test = DocTestParser().get_doctest(docstring, globs={}, name="", 
                                             filename=infile, lineno=0)
      runner = DocTestRunner(verbose=verbose, optionflags=optionflags)
      runner.run(test)
      runner.summarize
      if not runner.failures:
          print "%d failures in %d tests"%(runner.failures, runner.tries)
      return runner.failures, runner.tries
  

diff
~~~~

::

  def diff(infile='-', outfile='-', txt2code=True, **keyw):
      """Report differences between converted infile and existing outfile
      
      If outfile is '-', do a round-trip conversion and report differences
      """
      
      import difflib
      
      instream = file(infile)
      # for diffing, we need a copy of the data as list::
      data = instream.readlines()
      # convert
      converter = get_converter(data, txt2code, **keyw)
      new = converter()
      
      if outfile != '-':
          outstream = file(outfile)
          old = outstream.readlines()
          oldname = outfile
          newname = "<conversion of %s>"%infile
      else:
          old = data
          oldname = infile
          # back-convert the output data
          converter = get_converter(new, not txt2code)
          new = converter()
          newname = "<round-conversion of %s>"%infile
          
      # find and print the differences
      is_different = False
      # print type(old), old
      # print type(new), new
      delta = difflib.unified_diff(old, new,
      # delta = difflib.unified_diff(["heute\n", "schon\n"], ["heute\n", "noch\n"],
                                        fromfile=oldname, tofile=newname)
      for line in delta:
          is_different = True
          print line,
      if not is_different:
          print oldname
          print newname
          print "no differences found"
      return is_different
  

execute
~~~~~~~

Works only for python code.

Doesnot work with `eval`, as code is not just one expression. ::

  def execute(infile="-", txt2code=True, **keyw):
      """Execute the input file. Convert first, if it is a text source.
      """
      
      data = file(infile)
      if txt2code: 
          data = str(Text2Code(data, **keyw))
      # print "executing " + options.infile
      exec data
  

main
----

If this script is called from the command line, the `main` function will
convert the input (file or stdin) between text and code formats.

Option default values for the conversion can be given as keyword arguments
to `main`_.  The option defaults will be updated by command line options and
extended with "intelligent guesses" by `PylitOptions`_ and passed on to
helper functions and the converter instantiation.

This allows easy customization for programmatic use -- just call `main`
with the appropriate keyword options, e.g.:

>>> main(comment_string="## ")

::

  def main(args=sys.argv[1:], **defaults):
      """%prog [options] INFILE [OUTFILE]
      
      Convert between (reStructured) text source with embedded code,
      and code source with embedded documentation (comment blocks)
      
      The special filename '-' stands for standard in and output.
      """
  
Parse and complete the options::

      options = PylitOptions()(args, **defaults)
      # print "infile", repr(options.infile)
  
Special actions with early return::

      if options.doctest:
          return run_doctest(**options.as_dict())
  
      if options.diff:
          return diff(**options.as_dict())
  
      if options.execute:
          return execute(**options.as_dict())
  
Open in- and output streams::

      try:
          (data, out_stream) = open_streams(**options.as_dict())
      except IOError, ex:
          print "IOError: %s %s" % (ex.filename, ex.strerror)
          sys.exit(ex.errno)
      
Get a converter instance::

      converter = get_converter(data, **options.as_dict())
        
Convert and write to out_stream::

      out_stream.write(str(converter))
      
      if out_stream is not sys.stdout:
          print "extract written to", out_stream.name
          out_stream.close()
  
If input and output are from files, set the modification time (`mtime`) of
the output file to the one of the input file to indicate that the contained
information is equal. [#]_ ::

          try:
              os.utime(options.outfile, (os.path.getatime(options.outfile),
                                         os.path.getmtime(options.infile))
                      )
          except OSError:
              pass
  
      ## print "mtime", os.path.getmtime(options.infile),  options.infile 
      ## print "mtime", os.path.getmtime(options.outfile), options.outfile
  

.. [#] Make sure the corresponding file object (here `out_stream`) is
       closed, as otherwise the change will be overwritten when `close` is 
       called afterwards (either explicitely or at program exit).


Rename the infile to a backup copy if ``--replace`` is set::
 
      if options.replace:
          os.rename(options.infile, options.infile + "~")
          

Run main, if called from the command line::

  if __name__ == '__main__':
      main()
   

Open questions
==============

Open questions and ideas for further development

Clean code
----------

* can we gain from using "shutils" over "os.path" and "os"?
* use pylint or pyChecker to enfoce a consistent style? 

Options
-------

* Use templates for the "intelligent guesses" (with Python syntax for string
  replacement with dicts: ``"hello %(what)s" % {'what': 'world'}``)

* Is it sensible to offer the `header_string` option also as command line
  option?

* Configurable 
  
Parsing Problems
----------------------
    
* How can I include a literal block that should not be in the
  executable code (e.g. an example, an earlier version or variant)?

  Workarounds:
  
  - Use a `parsed-literal block`_ directive if there is no "accidential"
    markup in the literal code
    
  - Use a `line block`_ directive or the `line block syntax`_
    and mark all lines as `inline literals`_.

  - Python session examples and doctests can use `doctest block`_ syntax 
  
    No double colon! Start first line of block with ``>>>``.
              

  Not implemented yet:
  
  - use a dedicated `code-block directive`_ or a distinct directive for
    ordinary literal blocks.
    
* Ignore "matching comments" in literal strings?

  Too complicated: Would need a specific detection algorithm for every
  language that supports multi-line literal strings (C++, PHP, Python)

* Warn if a comment in code will become documentation after round-trip?

code-block directive
--------------------

In a document where code examples are only one of several uses of literal
blocks, it would be more appropriate to single out the sourcecode with a
dedicated "code-block" directive.

Some highlight plug-ins require a special "sourcecode" or "code-block"
directive instead of the ``::`` literal block marker. Actually,
syntax-highlight is possible without changes to docutils with the Pygments_
package using a "code-block" directive. See the `syntax highlight`_ section
in the features documentation.

TODO:

* provide a "code-block-marker" string option.

* correctly handle the case of ``code_block_marker == '::'`` and conversion
  of ``::`` to a different "code_block_marker" -- consider minimized forms.

doctstrings in code blocks
--------------------------

* How to handle docstrings in code blocks? (it would be nice to convert them
  to rst-text if ``__docformat__ == restructuredtext``)

TODO: Ask at docutils users|developers

.. References

.. _docutils: http://docutils.sourceforge.net/
.. _doctest block: 
    http://docutils.sf.net/docs/ref/rst/restructuredtext.html#doctest-blocks
.. _parsed-literal block: 
    http://docutils.sf.net/docs/ref/rst/directives.html#parsed-literal-block
.. _line block: 
    http://docutils.sourceforge.net/docs/ref/rst/directives.html#line-block
.. _line block syntax: 
    http://docutils.sf.net/docs/ref/rst/restructuredtext.html#line-blocks
.. _inline literals:
    http://docutils.sf.net/docs/ref/rst/restructuredtext.html#inline-literals
.. _pygments: http://pygments.org/
.. _syntax highlight: ../features/syntax-highlight.html
