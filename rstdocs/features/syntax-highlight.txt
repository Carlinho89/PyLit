.. -*- rst-mode -*-
.. 
  restindex
      crumb: Highlights
      page-title: Pylit - Features - Syntax Highlight
      file: rst2html-pygments
      file: rst2latex-pygments
      file: for-else-test.py.txt
      file: for-else-test.py.tex
      file: for-else-test.py.pdf
      file: for-else-test.py.html
      file: pygments-default.css
      file: pygments-default.sty
  /restindex

Syntax Highlight
----------------

.. contents::
.. sectnum::

Syntax highlighting significantly enhances the readability of code.
So it is almost a must for pretty-printing a literate program.

PyLit uses docutils_ as pretty-printing back end. However, in the current
version, docutils does not highlight literal blocks. This may change in the
future, as in a mail on
`Questions about writing programming manuals and scientific documents`__,
docutils main developer David Goodger wrote:

   I'd be happy to include Python source colouring support, and other
   languages would be welcome too. A multi-language solution would be
   useful, of course. My issue is providing support for all output formats
   -- HTML and LaTeX and XML and anything in the future -- simultaneously.
   Just HTML isn't good enough. Until there is a generic-output solution,
   this will be something users will have to put together themselves.

__ http://sourceforge.net/mailarchive/message.php?msg_id=12921194


Existing highlighting additions to docutils
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are already such add-ons providing syntax colouring, e.g:

* SilverCity_ is a C++ library and Python extension that can provide lexical
  analysis for over 20 different programming languages. There is a recipe__
  for a "code-block" directive with syntax highlight by SilverCity.
  
__ http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252170

* The `listings`_ LaTeX package provides highly customisable and advanced
  syntax highlight, though only for the LaTeX (and LaTeX derived PS|PDF). 
  A patch__ mailed by Gael Varoquaux uses the listings LaTeX package for a
  "code-block" directive with Python syntax highlight.
  
__ http://article.gmane.org/gmane.text.docutils.devel/3914

* Trac_ has `reStructuredText support`__ and offers syntax highlighting with
  a "code-block" directive using GNU Enscript_, SilverCity_, or Pygments_.
  
__ http://trac.edgewall.org/wiki/WikiRestructuredText

* The rest2web_ site builder provides the `colorize`__ macro (using the
  `Moin-Moin Python colorizer`_) 

__ http://www.voidspace.org.uk/python/rest2web/macros.html#colorize

* `Pygments`_ a generic syntax highlighter for general use. 

  * Written completely in Python, usable as a command-line tool and as a
    Python package.
  * A wide range of common `languages and markup formats`_ is supported.
  * The layout is configurable by style sheets.
  * Several built-in styles and an option for line-numbering.
  * Built-in output formats include HTML, LaTeX, rtf
    (OpenOffice is supported by the odtwriter_).
  * Support for new languages, formats, and styles is added easily (modular
    structure, Python code, existing documentation).
  * Well documented and actively maintained.
  * The web site provides a recipe for `using Pygments in ReST documents`_.
    It is used in the `Pygments enhanced docutils front-ends`_ below.

  The experimental Odtwriter_ for Docutils OpenOffice export supports syntax
  colours using Pygments.

Pygments_ seems to be the most promising docutils highlighter. For printed
output, the listings_ package has its advantages too.


Pygments enhanced docutils front-ends
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The example code in "`Using Pygments in ReST documents`_" defines a new
"sourcedode" directive. The directive takes one argument `language` and uses
the `Pygments`_ source highlighter to parse and render its content as a
colourful source code block. 

Combining the pygments_ example code with the standard docutils_ front-ends,
results in front-end scripts generating output documents with syntax colour.
For consistency with the majority of existing add-ons, the directive is
renamed to "code-block".

`rst2html-pygments`_ 
  enhances the standard docutils ``rst2html`` front-end to
  generate a HTML rendering with syntax highlight. 
  
`rst2latex-pygments`_ 
  enhances docutils' ``rst2latex`` to generate LaTeX with syntax highlight.


Example code block::

  .. code-block:: python
     
     def hello():
         print "hello world"

Advantages:
  + Easy implementation with no changes to the stock docutils_. 
  + Separation of code blocks and ordinary literal blocks.

Disadvantages:
  - more "invasive" markup distracting from content
  - no "minimal" code block marker -- three additional lines per code block
  - documents are incompatible with the standard docutils because of the
    locally defined directive.

The disadvantages become a real issue in literate programming where a code
block is expected to be the most used block markup.

Example Python script:
  :text source: `for-else-test.py.txt`_
  :HTML:   `for-else-test.py.html`_
  :LaTeX:  `for-else-test.py.tex`_
  :PDF:    `for-else-test.py.pdf`_

Stylesheets:
  :CSS stylesheet:  `pygments-default.css`_
  :LaTeX style:     `pygments-default.sty`_


To support this way of syntax highlight, the PyLit converter would need a
configurable "code block marker" instead of the hard coded double colon
(``::``) presently in use. (See also the `code-block directive`__ section in
pylit.py.)

__ ../examples/pylit.py.html#code-block-directive


The listings LaTeX package
~~~~~~~~~~~~~~~~~~~~~~~~~~

Using the listings_ LaTeX package for syntax highlight is not possible with
the current latex writer output.

First idea: use a stylesheet to redefine the ``verbatim`` environment::

  % use listings for literate blocks (verbatim environment)
  % -------------------------------------------------------
  
  \usepackage{listings}
  \lstset{language=Python}
  % redefine verbatim as lstlisting:
  % \renewenvironment{verbatim}{\begin{lstlisting}}{\end{lstlisting}}

This fails, as ``verbatim`` is a very special environment looking for a
literal occurrence of ``end{verbatim}``.

One can use the `fancyvrb` package and re-define "verbatim" do to
some nice stuff and customisation, e.g.::

  \usepackage{fancyvrb}
  \DefineVerbatimEnvironment{verbatim}{Verbatim}{frame=lines}

The ``listings.pdf`` documentation says one can use the listings package to
render a "Verbatim" environment with ::

  \lstset{language=Python, fancyvrb}

. However this did not work in my test. [#]_

The current workaround is to use a post-processing filter to replace all
occurences of {verbatim} with {lstlisting}. (More details can be found
searching the docutils-users mail archive for "listings").

.. [#] with ``listings 2004/10/17 1.3b`` and ``fancyvrb
       1998/07/17``

Odtwriter
~~~~~~~~~

Dave Kuhlmans odtwriter_ extension can add Python syntax highlighting
to ordinary literal blocks.

The ``--add-syntax-highlighting`` command line flag activates syntax
highlighting in literal blocks. By default, the "python" lexer is used.

You can change this within your reST document with the `sourcecode`
directive::
  
  .. sourcecode:: off
  
  ordinary literal block::
  
     content set in teletype

  .. sourcecode:: on
  .. sourcecode:: python
     
  colourful Python code::
     
     def hello():
         print "hello world"


The "sourcecode" directive defined by the odtwriter is principally
different from the "sourcecode" directive of ``rst2html-pygments``:
  
* The odtwriter directive does not have content. It is a switch.

* The syntax highlighting state and language/lexer set by this directive
  remain in effect until the next sourcecode directive is encountered in the
  reST document.
  
  ``.. sourcecode:: <newstate>`` 
       make highlighting active or inactive. 
       <newstate> is either ``on`` or ``off``.
  
  ``.. sourcecode:: <lexer>`` 
       change the lexer parsing literal code blocks.
       <lexer> should be one of aliases listed at pygment's `languages and
       markup formats`_.

   
The advantage of this approach is the clean and simple syntax for code
blocks -- preserving the space saving feature of the "minimised" literal
block marker (``::`` at the end of a text paragraph). This is especially
handy in literate programs with many sourcecode blocks!

     
Configurable literal block directive
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The *role* of inline `interpreted text` can be customised with the
"default-role" directive. This allows the use of the concise "backtick"
syntax for the most often used role, e.g. in a chemical paper, one could
use::

  .. default-role:: subscript
  
  The triple point of H`2`O is at 0°C.

This customisation is currently not possible for block markup.

Proposal 1: make the default "literal block" role configurable.
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

* Define a new "literal" directive for an ordinary literal block
  (doctree element "literal-block" with no parsing)

* Define a "literal-block" setting that controls which directive is called
  on a block following ``::``. Default would be the "literal" directive.
  
  Alternatively, define a new "default-literal-block" directive instead of
  a settings key.

Motivation
''''''''''

Analogue to customising the default role of "interpreted text" with the
"default-role" directive, the concise ``::`` literal-block markup could be
used for e.g.

* the "line-block" directive for poems or addresses

* the "parsed-literal" directive

* a "code-block" or "sourcecode" directive for colourful code 
  (analog to the one in the `pygments enhanced docutils front-ends`_)

* a "listing" directive for the `listings`_ environment in LaTeX

* a "verbatim" directive explicitly calling the verbatim environment in
  LaTeX.

Example::

  ordinary literal block::
  
     some text typeset in monospace

  .. settings::
     :literal-block:  code-block python
     
  colourful Python code::
     
     def hello():
         print "hello world"

  
In the same line, a "default-block-quote" setting or directive could be
considered to configure the role of a block quote.


Proposal 2: literal block with configurable classes 
"""""""""""""""""""""""""""""""""""""""""""""""""""

* Enhance writers to support syntax highlight for "literal-block" doctree
  elements with ``classes="code-block LANGUAGE"``.

  The standard html and latex writers could use `pygments`_ as a plug-in: if
  the "pygments" module is found, code-blocks will get syntax highlight, if
  not, the standard "literal-block" rendering is used.
  
  Alternatively, separate writers and back-end scripts for
  syntax-highlighting conversion could be added.
  
  The LaTeX writer should also support the "lstlistings" environment as an
  alternative.
  
* Add a "literal-block-classes" setting that controls which classes are
  attributed to a literal block following "``::``".
  
  Alternatively, define a new "literal-block-classes" directive instead of
  (or in addition to) a settings key.

Motivation
''''''''''

Classes are used in `docutils document tree`_ to carry non-vital
information from reader to writer.

Using the "literal-block" doctree element together with class information
for source code blocks could be *the right thing*:

* If a writer supports "code-block" and the specified language, it can parse
  the literal block's content and render it accordingly.

* The fall-back is to render the block in a monospaced font with whitespace
  preserved (as currently done by all writers)
  
This solves the problem of compatibility with "non-enhanced" writers that do
not provide syntax highlight. 

The "class" directive can already be used to specify classes of an object::
 
  colourful Python code

  .. class:: code-block python
     
  ::
  
     def hello():
         print "hello world"

I. e. a highlight-enhanced writer that works with backwards compatible
documents is already possible!

However, an extra "class" directive for every code block is a rather bulky
syntax for literate programming or documenting code. A
"literal-block-classes" setting, could allow the setting of the code-block
language in 

* a config file for a software project
* in the document "preamble" once for all literal blocks
* during export using a command line argument

.. Revised odtwriter syntax
   ~~~~~~~~~~~~~~~~~~~~~~~~
   
   As a "light" option in case the `configurable literal block directive`_
   proposal is not accepted by the docutils developers, here are some
   ideas for a revised highlighting syntax based on the one in the
   odtwriter:
   
   * A *command line option* ``--syntax-highlight=LEXER`` 
     tells the writer to apply syntax highlight to literal blocks.
   
   * Turn of syntax highlight with ``--syntax-highlight=off`` or
     ``--no-syntax-highlight``.
     
   * The corresponding *directive* should also be named "syntax-highlight"
     (instead of "sourcecode") because:
     
     * it makes the relationship of command line option and directive more
       transparent,
       
     * The name "sourcecode" leads me to assume that the directive
       contains source code that should be treated specially. It's a
       surprise to realise that the odtwriter's "sourcecode" directive
       is a switch without content.
       
     * it disambiguates from the name proposed in `Using Pygments in ReST
       documents`_.
     
     * with Pygments you can highlight not only source code but also
       config files and markup languages,
       
     Example::
     
       .. syntax-highlight:: off
       
       ordinary literal block::
       
          typeset in monospace
     
       .. syntax-highlight:: python
          
       colourful Python code::
          
          def hello():
              print "hello world"
       
   
     Instead of a dedicated "syntax-highlight" directive, a settings
     key could be employed together with the upcoming "settings" directive.
   
     Example::
   
       .. settings::
          :syntax-highlight: bash
        
   
   * The syntax highlighting state and language/lexer set by this
     directive remain in effect until the next "syntax-highlight" directive
     is encountered in the reST document.
     
   * In contrast to the current odtwriter, there is no "on" argument:
     
     ``.. syntax-highlight:: LEXER`` 
          makes highlighting active and sets the Pygments lexer to use.
     
     ``.. syntax-highlight:: off`` 
          turns off highlighting of literal blocks
   
     In order to turn syntax highlighting on and set the
     lexer, you will need to use this directive only once.

.. External links
.. _docutils: http://docutils.sourceforge.net/ 
.. _rest2web: http://www.voidspace.org.uk/python/rest2web/
.. _Enscript: http://www.gnu.org/software/enscript/enscript.html
.. _SilverCity: http://silvercity.sourceforge.net/ 
.. _Trac: http://trac.edgewall.org/ 
.. _Moin-Moin Python colorizer:
    http://www.standards-schmandards.com/2005/fangs-093/ 
.. _odtwriter: http://www.rexx.com/~dkuhlman/odtwriter.html 
.. _pygments: http://pygments.org/ 
.. _listings: http://tug.ctan.org/tex-archive/macros/latex/contrib/listings/ 
.. _languages and markup formats: http://pygments.org/languages 
.. _Using Pygments in ReST documents: http://pygments.org/docs/rstdirective/
.. _`Docutils Document Tree`: 
       http://docutils.sf.net/docs/ref/doctree.html#classes

.. Internal links
.. _rst2html-pygments: rst2html-pygments
.. _rst2latex-pygments: rst2latex-pygments
.. _for-else-test:
.. _for-else-test.py.html: for-else-test.py.html
.. _for-else-test.py.txt: for-else-test.py.txt
.. _for-else-test.py.tex: for-else-test.py.tex
.. _for-else-test.py.pdf: for-else-test.py.pdf
.. _pygments-default.css: pygments-default.css
.. _pygments-default.css.txt: pygments-default.css.txt
.. _pygments-default.css.html: pygments-default.css.html
.. _pygments-default.sty: pygments-default.sty
