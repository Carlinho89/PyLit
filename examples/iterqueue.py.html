<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title>Extending Iterators for use as Queue</title>
<meta name="date" content="2007-01-15" />
<meta name="copyright" content="2005, 2007 Guenter Milde. Released under the terms of the GNU General Public License (v. 2 or later)" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="extending-iterators-for-use-as-queue">
<h1 class="title">Extending Iterators for use as Queue</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Version:</th>
<td>0.2</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2007-01-15</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>2005, 2007 Guenter Milde.
Released under the terms of the GNU General Public License
(v. 2 or later)</td></tr>
<tr class="field"><th class="docinfo-name">Changelog:</th><td class="field-body">2005-06-29 Initial version
2007-01-07 literate version, more examples</td>
</tr>
</tbody>
</table>
<div class="abstract topic">
<p class="topic-title first">Abstract</p>
<p>There are many variants of &quot;rich iterators&quot; with varying
efficiency, conventions, naming, and behaviour. This survey will
compare them and provide a case for the inclusion of a &quot;rich
iterator wrapper&quot; to the Python Standard Library</p>
</div>
<!-- #!/usr/bin/env python
# -*- coding: iso-8859-1 -*- -->
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#iterables-and-iterators" id="id7" name="id7">1&nbsp;&nbsp;&nbsp;Iterables and Iterators</a></li>
<li><a class="reference" href="#limitations-of-iterator-objects" id="id8" name="id8">2&nbsp;&nbsp;&nbsp;Limitations of iterator objects</a></li>
<li><a class="reference" href="#pushing-the-limits" id="id9" name="id9">3&nbsp;&nbsp;&nbsp;Pushing the limits</a><ul class="auto-toc">
<li><a class="reference" href="#recode-to-work-with-iterators-as-they-are" id="id10" name="id10">3.1&nbsp;&nbsp;&nbsp;Recode to work with iterators as they are</a></li>
<li><a class="reference" href="#use-a-container-object" id="id11" name="id11">3.2&nbsp;&nbsp;&nbsp;Use a container object</a></li>
<li><a class="reference" href="#use-a-rich-iterator" id="id12" name="id12">3.3&nbsp;&nbsp;&nbsp;Use a rich iterator</a><ul class="auto-toc">
<li><a class="reference" href="#state-reporting-iterator" id="id13" name="id13">3.3.1&nbsp;&nbsp;&nbsp;State Reporting Iterator</a></li>
<li><a class="reference" href="#peekable-iterator" id="id14" name="id14">3.3.2&nbsp;&nbsp;&nbsp;Peekable Iterator</a></li>
<li><a class="reference" href="#push-iterator" id="id15" name="id15">3.3.3&nbsp;&nbsp;&nbsp;Push Iterator</a></li>
<li><a class="reference" href="#iterator-queue" id="id16" name="id16">3.3.4&nbsp;&nbsp;&nbsp;Iterator Queue</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#rich-iterator-examples" id="id17" name="id17">4&nbsp;&nbsp;&nbsp;Rich iterator examples</a><ul class="auto-toc">
<li><a class="reference" href="#xiterwrapper" id="id18" name="id18">4.1&nbsp;&nbsp;&nbsp;Xiterwrapper</a><ul class="auto-toc">
<li><a class="reference" href="#usage" id="id19" name="id19">4.1.1&nbsp;&nbsp;&nbsp;Usage</a></li>
</ul>
</li>
<li><a class="reference" href="#iteratorwrapper-bfl" id="id20" name="id20">4.2&nbsp;&nbsp;&nbsp;IteratorWrapper BFL</a></li>
<li><a class="reference" href="#iteratorwrapper-dd" id="id21" name="id21">4.3&nbsp;&nbsp;&nbsp;IteratorWrapper DD</a></li>
<li><a class="reference" href="#pushiterator" id="id22" name="id22">4.4&nbsp;&nbsp;&nbsp;PushIterator</a><ul class="auto-toc">
<li><a class="reference" href="#id4" id="id23" name="id23">4.4.1&nbsp;&nbsp;&nbsp;Usage</a></li>
</ul>
</li>
<li><a class="reference" href="#pushit" id="id24" name="id24">4.5&nbsp;&nbsp;&nbsp;PushIt</a></li>
<li><a class="reference" href="#iterqueue" id="id25" name="id25">4.6&nbsp;&nbsp;&nbsp;IterQueue</a><ul class="auto-toc">
<li><a class="reference" href="#id5" id="id26" name="id26">4.6.1&nbsp;&nbsp;&nbsp;Usage</a></li>
<li><a class="reference" href="#problems" id="id27" name="id27">4.6.2&nbsp;&nbsp;&nbsp;Problems</a></li>
</ul>
</li>
<li><a class="reference" href="#iqueue" id="id28" name="id28">4.7&nbsp;&nbsp;&nbsp;IQueue</a></li>
<li><a class="reference" href="#xiter" id="id29" name="id29">4.8&nbsp;&nbsp;&nbsp;XIter</a></li>
</ul>
</li>
</ul>
</div>
<pre class="literal-block">
&quot;&quot;&quot;iterqueue: mutable iterators

Classes for &quot;extended iterators&quot; with methods to let iterators be used as
queue

   `push` or
   `appendleft`     -- push back values
   `peek`           -- get a value without &quot;using it up&quot;
   `__nonzero__`    -- test for empty iterator

&quot;&quot;&quot;
</pre>
<p>Imports</p>
<p>The <cite>itertools</cite> module provides a set of building blocks for the work with
iterators (but misses a class for &quot;mutable&quot; iterators).</p>
<pre class="literal-block">
import itertools
</pre>
<p>The <cite>collections</cite> module with the efficient double-sided queue was
introduced in Python 2.4. The following construct provides a minimal
compatibility definition if it is not available:</p>
<pre class="literal-block">
try:
    from collections import deque
except ImportError:
    class deque(list):
        def appendleft(self, value):
            self.insert(0, value)
</pre>
<div class="section">
<h1><a class="toc-backref" href="#id7" id="iterables-and-iterators" name="iterables-and-iterators">1&nbsp;&nbsp;&nbsp;Iterables and Iterators</a></h1>
<p>Iterables and iterators are defined by the iterator protocol as laid out in
the section on <a class="reference" href="http://www.python.org/doc/lib/typeiter.html">Iterator Types</a> in the Python Library Reference`:</p>
<dl class="docutils">
<dt>Iterables:</dt>
<dd><p class="first">One method needs to be defined for container objects to provide iteration
support:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">__iter__():</th><td class="field-body">Return an iterator object. [...] If a container supports
different types of iteration, additional methods can be
provided to specifically request iterators for those
iteration types. [...]</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<pre class="literal-block">
def is_iterable(object):
    &quot;&quot;&quot;Check if the argument is iterable&quot;&quot;&quot;
    return hasattr(object, &quot;__iter__&quot;) and is_iterator(iter(object))
</pre>
<dl class="docutils">
<dt>Iterators:</dt>
<dd><p class="first">The <em>iterator objects</em> themselves are required to support the following
two methods, which together form the <em>iterator protocol</em>:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">__iter__():</th><td class="field-body"><p class="first">Return the iterator object itself. This is required to allow
both containers and iterators to be used with the <cite>for</cite> and
<cite>in</cite> statements...</p>
</td>
</tr>
<tr class="field"><th class="field-name">next():</th><td class="field-body"><p class="first">Return the next item from the container. If there are no further
items, raise the <cite>StopIteration</cite> exception.</p>
<p class="last">[...] once an iterator's next() method raises <cite>StopIteration</cite>,
it will continue to do so on subsequent calls. Implementations
that do not obey this property are deemed broken.</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>Check if an object is an iterator:</p>
<pre class="literal-block">
def is_iterator(object):
    &quot;&quot;&quot;check if the argument is an iterator&quot;&quot;&quot;
    if not hasattr(object, &quot;__iter__&quot;):
        return False
    return (object.__iter__() is object) and hasattr(object, &quot;next&quot;)
</pre>
<p>Try it:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import iterqueue
&gt;&gt;&gt; iterqueue.is_iterator(23)
False
&gt;&gt;&gt; iterqueue.is_iterator(iter(range(3)))
True
</pre>
</blockquote>
<p>The iterator protocol was primarily designed to be the <em>minimum</em> necessary
to work in <cite>for statements</cite>, translating (behind the scene):</p>
<pre class="literal-block">
|  for item in iterable:
|      &lt;statements&gt;
</pre>
<p>into the equivalent of:</p>
<pre class="literal-block">
|  iterator = iter(iterable)
|  while 1:
|    try:
|          item = iterator.next()
|    except StopIteration: break
|          &lt;statements&gt;
</pre>
<p>To add iterator behavior to your classes, define an <cite>__iter__</cite> method which
returns an object with a <cite>next</cite> method.  If the class defines <cite>next</cite>, then
<cite>__iter__</cite> can just return <cite>self</cite>.  (<a class="reference" href="http://www.python.org/doc/tut/node11.html#SECTION0011900000000000000000">tutorial chapter on iterators</a>)</p>
<p>Python's <em>generators</em> provide a convenient way to implement the iterator
protocol. Generator objects are returned by <em>generator functions</em> (functions
with the <tt class="docutils literal"><span class="pre">yield</span></tt> keyword, new in 2.3) and <em>generator expressions</em> (new in
2.4).</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id8" id="limitations-of-iterator-objects" name="limitations-of-iterator-objects">2&nbsp;&nbsp;&nbsp;Limitations of iterator objects</a></h1>
<p>Most built-in Python iterator objects (including generator objects) are
non-mutable (except the call to the <cite>next</cite> method). They &quot;produce the data
just in time&quot;, which is fast and memory efficient.</p>
<p>However:</p>
<ol class="arabic">
<li><p class="first">In some occasions, it is important to</p>
<ul class="simple">
<li>find out whether an iterator is empty or</li>
<li>to &quot;peek&quot; at a data value</li>
</ul>
<p>without advancing the iterator.</p>
</li>
<li><p class="first">In a state machine, an iterator holding the input values can be passed
around to the state handling functions. If a state handler realizes that
a value should be processed by another state handler, it needs to
&quot;push it back&quot;.</p>
</li>
<li><p class="first">One might want modify the object iterated over in a <cite>for</cite> statement.</p>
<p>Generally, the object in a <cite>for</cite> statement can not be changed inside the
loop.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; it = deque(range(3))
&gt;&gt;&gt; for v in it:
...     print v,
...     if v == 1:
...        it.appendleft(&quot;eins&quot;)
...
Traceback (most recent call last):
  File &quot;doctest.py&quot;, line 1248, in __run
    compileflags, 1) in test.globs
  File &quot;&lt;doctest iterqueue.py.txt[8]&gt;&quot;, line 1, in ?
    for v in it:
RuntimeError: deque mutated during iteration
</pre>
</blockquote>
</li>
</ol>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id9" id="pushing-the-limits" name="pushing-the-limits">3&nbsp;&nbsp;&nbsp;Pushing the limits</a></h1>
<p>There are many ways to live with the limits of iterators. Most often it
helps to get a true understanding of their nature and try to count for it in
the code.  However, the &quot;neverending&quot; discussion and varying reciepes for
enhanced iterators show the ongoing public demand. This is why I argue for
the inclusion of a 'rich iterator' wrapper class into the standard library
based on the <span class="target" id="standardization-argument">standardization argument</span> in the <a class="reference" href="http:www.python.org/doc/lib/module-itertools.html">itertools module</a></p>
<blockquote>
Standardization helps avoid the readability and reliability problems which
arise when many different individuals create their own slightly varying
implementations, each with their own quirks and naming conventions.</blockquote>
<div class="section">
<h2><a class="toc-backref" href="#id10" id="recode-to-work-with-iterators-as-they-are" name="recode-to-work-with-iterators-as-they-are">3.1&nbsp;&nbsp;&nbsp;Recode to work with iterators as they are</a></h2>
<p>The most straightforward way is to translate code like</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def print_first(l):
...     if not l:
...         print &quot;list empty&quot;
...     else:
...         print l[0]
...
&gt;&gt;&gt; print_first([1, 2])
1
&gt;&gt;&gt; print_first([])
list empty
</pre>
</blockquote>
<p>into something in the line of</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def print_next(it):
...     try:
...         value = it.next()
...     except StopIteration:
...         print &quot;list empty&quot;
...     else:
...         print value
...
&gt;&gt;&gt; print_next(iter([1, 2]))
1
&gt;&gt;&gt; print_next(iter([]))
list empty
</pre>
</blockquote>
<p>In a <cite>for</cite> statement, the <cite>else</cite> keyword can be utilized to call an
expression (or a block) if the end of the iterator is reached:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def find_five(iterable):
...     for i in iterable:
...         if i == 5:
...             print &quot;5 found&quot;
...             break
...     else:
...         print &quot;5 not found&quot;
</pre>
</blockquote>
<p>If the loop is aborted, the else clause is skipped</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; find_five(range(7))
5 found
</pre>
</blockquote>
<p>Otherwise it prints its message:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; find_five(range(3))
5 not found
</pre>
</blockquote>
<p>However, there might be cases where this is not applicable and a test for
the emptieness or a peek at the first value without advancing the iterator
would enable much cleaner code.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id11" id="use-a-container-object" name="use-a-container-object">3.2&nbsp;&nbsp;&nbsp;Use a container object</a></h2>
<p>One could wrap e.g. a generator into a <cite>list</cite> or <cite>collections.deque</cite> to add
random access as well as extensibility.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; que = deque(xrange(3))
&gt;&gt;&gt; que.appendleft(&quot;foo&quot;)
&gt;&gt;&gt; print que
deque(['foo', 0, 1, 2])
</pre>
</blockquote>
<p>However, it will put all iterator values into memory which becomes a problem
for large iterators (and is non-feasible for unlimited iterators).</p>
<p>Also, iterating in a <cite>for</cite> statement will loose the rich behaviour. Instead
a construct with a <cite>while</cite> statement is needed, e.g:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; que = deque(range(3))
&gt;&gt;&gt; while que:
...     v = que.popleft()
...     print v,
...     if v == 1:
...        que.appendleft(&quot;eins&quot;)
...
0 1 eins 2
</pre>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id12" id="use-a-rich-iterator" name="use-a-rich-iterator">3.3&nbsp;&nbsp;&nbsp;Use a rich iterator</a></h2>
<p>If the argument of a <cite>for</cite> statement is an iterator (whose <cite>__iter__</cite>
method returns <cite>self</cite>), it is available unchanged inside the loop. A <em>rich
iterator</em> provides additional methods besides the ones required for the
iterator protocoll.</p>
<div class="section">
<h3><a class="toc-backref" href="#id13" id="state-reporting-iterator" name="state-reporting-iterator">3.3.1&nbsp;&nbsp;&nbsp;State Reporting Iterator</a></h3>
<p>An iterator that returns an indicator &quot;full or empty&quot; (values waiting or
not) when converted to boolean will be called <em>state reporting iterator</em>:</p>
<pre class="literal-block">
def is_state_reporting(object):
    return hasattr(object, &quot;__nonzero__&quot;) or hasattr(object, &quot;__len__&quot;)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id14" id="peekable-iterator" name="peekable-iterator">3.3.2&nbsp;&nbsp;&nbsp;Peekable Iterator</a></h3>
<p>An iterator that provides a <cite>peek</cite> method will be called a
<em>peekable iterator</em>:</p>
<pre class="literal-block">
def is_peekable(object):
    return hasattr(object, &quot;peek&quot;)
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id15" id="push-iterator" name="push-iterator">3.3.3&nbsp;&nbsp;&nbsp;Push Iterator</a></h3>
<p>An iterator that provides for pushback will be called <em>push-iterator</em>:</p>
<pre class="literal-block">
def is_pushable(object):
    return hasattr(object, &quot;appendleft&quot;) or hasattr(object, &quot;push&quot;)
</pre>
<p>Push iterators can be easily extended with <cite>peek</cite> and test of emptieness
(see <a class="reference" href="#pushiterator">PushIterator</a>).</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id16" id="iterator-queue" name="iterator-queue">3.3.4&nbsp;&nbsp;&nbsp;Iterator Queue</a></h3>
<p>An iterator that also provides methods for appending and extending will be
called <em>iterator_queue</em>.</p>
<p>Methods that need access from the &quot;right&quot; side or knowledge of the lenth of
the iterator are not included in the iterator_queue specification as they
clash with the &quot;just in time&quot; aquisation of the values that give iterators
time and memory advantage over sequences.</p>
<pre class="literal-block">
def is_iterator_queue(object):
    return (is_state_reporting(object)
            and hasattr(object, &quot;append&quot;)
            and hasattr(object, &quot;appendleft&quot;)
            and hasattr(object, &quot;extend&quot;)
            and hasattr(object, &quot;extendleft&quot;)
            and hasattr(object, &quot;clear&quot;)
            and hasattr(object, &quot;rotate&quot;)
           )
</pre>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id17" id="rich-iterator-examples" name="rich-iterator-examples">4&nbsp;&nbsp;&nbsp;Rich iterator examples</a></h1>
<p>The following examples are the result of a net survey and own ideas.
The will be compared and profiled in this paper.</p>
<p>All of them are iterator-wrappers:</p>
<pre class="literal-block">
def is_iterator_wrapper(obj):
    &quot;&quot;&quot;Try if obj can wrap an iterator&quot;&quot;&quot;
    try:
        it = obj(xrange(1))
    except:
        return False
    try:
        return is_iterator(it)
    except:
        return False
</pre>
<div class="section">
<h2><a class="toc-backref" href="#id18" id="xiterwrapper" name="xiterwrapper">4.1&nbsp;&nbsp;&nbsp;Xiterwrapper</a></h2>
<p>Tom Andersson suggested in the Python list an <a class="reference" href="http://mail.python.org/pipermail/python-list/2006-January/360162.html">xiterable protocoll</a> for
extended iterables and a wrapper to convert a &quot;traditional&quot; iterator to an
extended version</p>
<pre class="literal-block">
def xiter(iterable):
    if (hasattr(iterable, &quot;__xiter__&quot;)):
        return iterable.__xiter__()
    else:
        return xiterwrapper(iter(iterable))

class xiterwrapper(object):
    def __init__(self, it):
        self.it = it
        self.advance()
    def hasNext(self):
        return hasattr(self, &quot;_next&quot;)
    def next(self):
        try:
            cur = self._next
            self.advance()
            return cur
        except AttributeError:
            raise StopIteration
    def peek(self):
        try:
            return self._next
        except AttributeError:
            raise StopIteration
    def advance(self):
        try:
            self._next = self.it.next()
        except StopIteration:
            if (hasattr(self, &quot;_next&quot;)):
                del self._next
    def __xiter__(self):
        return self
    def __iter__(self):
        return self
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id19" id="usage" name="usage">4.1.1&nbsp;&nbsp;&nbsp;Usage</a></h3>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import iterqueue
&gt;&gt;&gt; it = iterqueue.xiter(xrange(3))
&gt;&gt;&gt; iterqueue.is_iterator(it)
True
&gt;&gt;&gt; iterqueue.is_peekable(it)
True
&gt;&gt;&gt; iterqueue.is_pushable(it)
False
</pre>
</blockquote>
<p>We add the __nonzero__ methos for a non-destructive test of waiting values
to add the state reporting feature:</p>
<pre class="literal-block">
__nonzero__ = hasNext
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; iterqueue.is_state_reporting(it)
True
</pre>
<p>Adding a <cite>push</cite> method is not possible without major changes to the code.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id20" id="iteratorwrapper-bfl" name="iteratorwrapper-bfl">4.2&nbsp;&nbsp;&nbsp;IteratorWrapper BFL</a></h2>
<p>In a <a class="reference" href="http://mail.python.org/pipermail/python-3000/2006-March/000058.html">post on python-3000</a> Guido van Rossum argued against inclusion of an
&quot;emptiness&quot; test in the iterator protocoll, as  &quot;that's just not something
that generators can be expected to support&quot; and hence would exclude
generators from the definition of an iterator.</p>
<blockquote>
<p>... you can always write a helper class that takes an iterator and
returns an object that represents the same iterator, but sometimes
buffers one element. But the buffering violates the coroutine-ish
properties of generators, so it should not be the only (or even the
default) way to access generators.
...</p>
<p>Here's a sample wrapper (untested)</p>
</blockquote>
<pre class="literal-block">
class IteratorWrapperBFL(object):
    def __init__(self, it):
        self.it = iter(it)
        self.buffer = None
        self.buffered = False
        self.exhausted = False
    def __iter__(self):
        return self
    def next(self):
        if self.buffered:
            value = self.buffer
            self.buffered = False
            self.buffer = None
            return value
        if self.exhausted:
            raise StopIteration()
        try:
            return self.it.next()
        except StopIteration:
            self.exhausted = True
            raise
    def __nonzero__(self):
        if self.buffered:
            return True
        if self.exhausted:
            return False
        try:
            self.buffer = self.it.next()
        except StopIteration:
            self.exhausted = True
            return False
        self.buffered = True
        return True
</pre>
<p>This example provides an &quot;emptiness&quot; test but no peek or pushback:</p>
<pre class="doctest-block">
&gt;&gt;&gt; it = iterqueue.IteratorWrapperBFL(xrange(3))
&gt;&gt;&gt; iterqueue.is_state_reporting(it)
True
</pre>
<p>Peeking could be easily added, though:</p>
<pre class="literal-block">
def peek(self):
    self.buffer = self.next()
    self.buffered = True
    return self.buffer
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; iterqueue.is_peekable(it)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id21" id="iteratorwrapper-dd" name="iteratorwrapper-dd">4.3&nbsp;&nbsp;&nbsp;IteratorWrapper DD</a></h2>
<p>Daniel Dittmar wrote on Di 22 Jul. 2003 on comp.lang.python</p>
<p>It shouldn't be too difficult to write an iterator wrapper class that does
exactly what you want (not tested):</p>
<pre class="literal-block">
class IteratorWrapperDD:
    def __init__ (self, iterArg):
        iterArg = iter (iterArg)
        try:
            self.firstElement = iterArg.next ()
            self.isEmpty = false
            self.next = self.returnFirstElement
            self.baseIter = iterArg
        except StopIteration:
            self.isEmpty = true
            self.next = self.throwStopIteration

    def returnFirstElement(self):
        self.next = self.baseIter.next
        return self.firstElement

    def throwStopIteration(self):
        raise StopIteration
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id22" id="pushiterator" name="pushiterator">4.4&nbsp;&nbsp;&nbsp;PushIterator</a></h2>
<p>In the slides to the <a class="reference" href="http://www.interlink.com.au/anthony/tech/talks/OSCON2005/effective_r27.pdf">Effective Python Programming</a> OSCON 2005 tutorial by
Anthony&nbsp;Baxter, I found a genially simple example for an iterator with a
<cite>push</cite> method.</p>
<pre class="literal-block">
class PushIterator:
    def __init__(self, iterable):
        &quot;&quot;&quot;Store iterator as data argument and set up cache&quot;&quot;&quot;
        self.it = iter(iterable)
        self.cache = []

    def __iter__(self):
        return self

    def next(self):
        &quot;&quot;&quot;Return next value (from cache or iterator)&quot;&quot;&quot;
        if self.cache:
            return self.cache.pop()
        return self.it.next()

    def push(self, value):
        &quot;&quot;&quot;Push back one value (will become the `next` value)&quot;&quot;&quot;
        self.cache.append(value)
</pre>
<p>Once <cite>push</cite> is defined, it is easy to add <cite>peek</cite> and <cite>__nonzero__</cite>.</p>
<p>The question arises, what should be returned by <cite>peek()</cite> if the iterator is
empty. The easiest option is to raise <cite>StopIteration</cite>, but this might come
unhandy in some cases. My proposal is to add an optional <cite>default</cite> argument,
which is returned in case the iterator is empty. (As there is no sensible
default value for the <cite>default</cite> argument, it cannot be implemented as
keyword arg, instead an argument list is used):</p>
<pre class="literal-block">
def peek(self, *defaults):
    &quot;&quot;&quot;Return next value but do not advance the iterator&quot;&quot;&quot;
    try:
        value = self.next()
    except StopIteration:
        if defaults:
            return defaults[0]
        raise
    self.push(value)
    return value

def __nonzero__(self):
    &quot;&quot;&quot;Test whether the iterator is empty&quot;&quot;&quot;
    try:
        self.peek()
    except StopIteration:
        return False
    return True
</pre>
<p>An alias makes the class more compatible with <cite>collections.deque</cite></p>
<pre class="literal-block">
appendleft = push
</pre>
<p>Optimization of <cite>peek</cite> and <cite>__nonzero__</cite> is is left out in favour of
improved clarity.</p>
<div class="section">
<h3><a class="toc-backref" href="#id23" id="id4" name="id4">4.4.1&nbsp;&nbsp;&nbsp;Usage</a></h3>
<p>Create an instance from an iterable object:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; it = iterqueue.PushIterator(range(4))
</pre>
</blockquote>
<p>Test for values:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; bool(it)
True
</pre>
</blockquote>
<p>Have a peek ...</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; it.peek(None)
0
</pre>
</blockquote>
<p>the value is still there:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; it.next()
0
</pre>
</blockquote>
<p>See what is left</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; [i for i in it]
[1, 2, 3]
</pre>
</blockquote>
<p>It should be empty now:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; bool(it)
False
</pre>
</blockquote>
<p>So a peek will return the default:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print it.peek(None)
None
</pre>
</blockquote>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id24" id="pushit" name="pushit">4.5&nbsp;&nbsp;&nbsp;PushIt</a></h2>
<p>The wrapping of an iterator in a class leads to performance loss, as every
call to <cite>next()</cite> is a relatively costly function call.</p>
<p>Remapping of self.next leads to a more more efficient implementation
of the PushIterator for the case that <cite>peek</cite> or <cite>push</cite> is called far
less frequently than <cite>next</cite> ('normal' iterating with occasional peek or
backtrack).</p>
<pre class="literal-block">
class PushIt(PushIterator):
    def __init__(self, iterable):
        self.it = iter(iterable)
        self.cache = []
        self.next = self.it.next

    def _next(self):
        &quot;&quot;&quot;Return next element. Try cache first.&quot;&quot;&quot;
        if self.cache:
            return self.cache.pop()
        self.next = self.it.next
        return self.next()

    def push(self, value):
        &quot;&quot;&quot;Push back one value to the iterator&quot;&quot;&quot;
        self.cache.append(value)
        self.next = self._next

    def peek(self):
        &quot;&quot;&quot;Return next value but do not advance the iterator&quot;&quot;&quot;
        if self.cache:
            return self.cache[-1]
        value = self.it.next()
        self.push(value)
        return value
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id25" id="iterqueue" name="iterqueue">4.6&nbsp;&nbsp;&nbsp;IterQueue</a></h2>
<p>The <cite>IterQueue</cite> class adds iterator behaviour to a double-ended queue:</p>
<pre class="literal-block">
class IterQueue(deque):
    &quot;&quot;&quot;Iterator object that is also a queue&quot;&quot;&quot;
    def __iter__(self):
        return self
    def next(self):
        try:
            return self.popleft()
        except IndexError:
            raise StopIteration
    #
    def peek(self):
        &quot;&quot;&quot;Return next value but do not advance the iterator&quot;&quot;&quot;
        value = self.next()
        self.appendleft(value)
        return value
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id26" id="id5" name="id5">4.6.1&nbsp;&nbsp;&nbsp;Usage</a></h3>
<p>Creating an instance wraps an iterable in an iterator queue</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; it = iterqueue.IterQueue(xrange(3))
</pre>
</blockquote>
<p>which is an iterator according to the iterator protocoll with &quot;queue&quot;
methods</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; iterqueue.is_iterator_queue(it)
True
</pre>
</blockquote>
<p>We can test whether there is data in the iterator or get the length of it:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; bool(it)
True
&gt;&gt;&gt; len(it)
3
</pre>
</blockquote>
<p>It is possible to modify this iterator in the middle of a <cite>for</cite> statement:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for v in it:
...     print v,
...     if v == 1:
...        it.appendleft(&quot;eins&quot;)
...
0 1 eins 2
</pre>
</blockquote>
<p>As iteration is done on the object itself and not on a copy, it is exhausted
now:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print it
deque([])
</pre>
</blockquote>
<p>(the iterator advertises itself as <cite>deque</cite>, as we did not override the
<cite>__repr__</cite> method)</p>
<p>We can make up for this</p>
<pre class="literal-block">
def __repr__(self):
    return &quot;&lt;IterQueue instance&gt;&quot;
</pre>
<p>but there might be other problems left...</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id27" id="problems" name="problems">4.6.2&nbsp;&nbsp;&nbsp;Problems</a></h3>
<p>Converting an iterable to a <cite>collections.deque</cite> object creates a list of all
values in the memory, loosing the memory saving advantages of generator
objects with &quot;just in time&quot; production of the data.</p>
<p>Printing (and probabely other uses as well) &quot;use up&quot; the iterator</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; it = iterqueue.IterQueue(range(3))
&gt;&gt;&gt; print it
deque([0, 1, 2])
&gt;&gt;&gt; print it
deque([])
</pre>
</blockquote>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id28" id="iqueue" name="iqueue">4.7&nbsp;&nbsp;&nbsp;IQueue</a></h2>
<p>The following class implements an iterator queue that is</p>
<ul class="simple">
<li>memory efficient, as generators are kept as generators</li>
<li>mostly compatible to <cite>collections.deque</cite> (offering all methods of a
<cite>deque</cite> for appends)</li>
</ul>
<p>It does not offer</p>
<ul class="simple">
<li>random access to the values, nor</li>
<li>pop from the right end,</li>
</ul>
<p>as this would require to convert the iterator to a sequence loosing the
memory-saving advantage.</p>
<p>Iterating over instances is less fast, as the next() method is redefined
(a function call is needed for every step). Implementing in C would help
to improve speed.</p>
<p>But,</p>
<blockquote>
<p>itertools.queue() was rejected because it didn't fit naturally into
applications -- you had to completely twist your logic around just to
accommodate it.  Besides, it is already simple to iterate over a list
while appending items to it as needed.</p>
<p class="attribution">&mdash;Raymond Hettinger 03-13-05 <a class="reference" href="http://www.codecomments.com/message423138.html">http://www.codecomments.com/message423138.html</a></p>
</blockquote>
<p>However, both, the speed increase as well as the <a class="reference" href="#standardization-argument">standardization argument</a>
given for the <cite>itertools</cite> hold also in this case
Maybe IQueue should become a collections candidate?</p>
<pre class="literal-block">
class IQueue:
    &quot;&quot;&quot;Iterator with &quot;online extensibility&quot;

    An iterator with methods to append or extend it from left or right
    (even while the iterator is in use).

    Can be conceived as a mixture of `itertools.chain` and
    `collections.deque`.

    As `next` is redefined, there is a performance loss when iterating
    over large iterators.
    &quot;&quot;&quot;

    def __init__(self, *iterables):
        &quot;&quot;&quot;Convert `iterables` to a queue object&quot;&quot;&quot;
        self.iterators = deque(iterables)
    #
    def __iter__(self):
        return self

    def next(self):
        while True:
            try:
                return self.iterators[0].next()
            except AttributeError:      # convert iterable to iterator
                self.iterators[0] = iter(self.iterators[0])
            except StopIteration:       # switch to next iterator
                del(self.iterators[0])
            except IndexError:          # all iterators exhausted
                raise StopIteration
    #
    def append(self, value):
        &quot;&quot;&quot;append `value` to self

        The value is wrapped in an iterable and
        appended to the queue of iterables
        &quot;&quot;&quot;
        self.iterators.append(iter((value,)))
    #
    def appendleft(self, value):
        &quot;&quot;&quot;Prepend one (skalar) value to the iterator.

        The value is wrapped in an iterable and
        inserted at the first position in the list of iterables
        &quot;&quot;&quot;
        self.iterators.appendleft(iter((value,)))
    #
    def clear(self):
        &quot;&quot;&quot;Remove all elements from the iterator.
        &quot;&quot;&quot;
        self.iterators.clear()
    #
    def extend(self, iterable):
        &quot;&quot;&quot;append `iterable` to self&quot;&quot;&quot;
        self.iterators.append(iter(iterable))
    #
    def extendleft(self, iterable):
        &quot;&quot;&quot;prepend `iterable` to self&quot;&quot;&quot;
        self.iterators.appendleft(iter(iterable))
    #
    def peek(self):
        &quot;&quot;&quot;Return the next value without advancing the iterator

        Yield next value but push back a copy of the result.
        This way you may &quot;peak&quot; at an iterator without loss.

        Raises `StopIteration` if the iterator is empty.
        &quot;&quot;&quot;
        value = self.next()
        self.iterators.appendleft(iter((value,)))
        return value
    #
    def rotate(self, n=1):
        &quot;&quot;&quot;append the next `n` values to the end of the iterator

        Similar to `container.deque.rotate`, but
         * negative `n` leads to error
         * a list of the `n` rotated values is returned
        &quot;&quot;&quot;
        result = list(itertools.islice(self, n))
        self.iterators.append(result)
        return result

    #
    def __repr__(self):
        &quot;&quot;&quot;Return a string representation&quot;&quot;&quot;
        return &quot;IQueue(%s)&quot; % repr(self.iterators)
    #
    def  __nonzero__(self):
        &quot;&quot;&quot;Test for a non-zero length of the iterator&quot;&quot;&quot;
        if len(self.iterators) &gt; 1:
            return True
        try:
            self.peek()
        except StopIteration:
            return False
        return True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id29" id="xiter" name="xiter">4.8&nbsp;&nbsp;&nbsp;XIter</a></h2>
<p>The <cite>XIter</cite> class is an optimized version of the <cite>IQueue</cite> for the
case when appending of a value is a done less frequently than calling <cite>next</cite>.
It does so by aliasing next to the underlying iterators <cite>next</cite> method in
case there is only one iterator in the <cite>iterables</cite> chain.</p>
<pre class="literal-block">
class XIter:
    &quot;&quot;&quot;'Mutable iterator' class&quot;&quot;&quot;
    def __init__(self, *iterables):
        self.iterators = deque(iter(i) for i in iterables)
        if len(self.iterators) is 1:
            self.next = self.iterators[0].next
        else:
            self.next = self._next     # iterate over argument
    #
    def __iter__(self): return self        # &quot;I am an iterator!&quot;
    #
    def _next(self):
        &quot;&quot;&quot;get next in turn if there are more than one iterators&quot;&quot;&quot;
        try:
            return self.iterators[0].next()
        except StopIteration:
            del(self.iterators[0])             # switch to next iterator
            assert len(self.iterators) &gt;= 1
            if len(self.iterators) is 1:
                self.next = self.iterators[0].next
            return self.next()
    #
    def append(self, element):
        &quot;&quot;&quot;append `element` to self&quot;&quot;&quot;
        self.iterators.append(iter((element,)))
        self.next = self._next        # iterate over cache
    #
    def appendleft(self, element):
        &quot;&quot;&quot;prepend `element` to self&quot;&quot;&quot;
        self.iterators.appendleft(iter((element,)))
        self.next = self._next        # iterate over cache
    #
    def extend(self, iterable):
        &quot;&quot;&quot;append `iterable` to self&quot;&quot;&quot;
        self.iterators.append(iter(iterable))
        self.next = self._next        # iterate over cache
    #
    def extendleft(self, iterable):
        &quot;&quot;&quot;prepend `iterable` to self&quot;&quot;&quot;
        self.iterators.appendleft(iter(iterable))
        self.next = self._next        # iterate over cache

    #
    def peek(self):
        &quot;&quot;&quot;Return the next value without advancing the iterator

        Yield next value but push back a copy of the result.
        This way you may &quot;peak&quot; at an iterator without loss.

        Raises `StopIteration` if the iterator is empty.
        &quot;&quot;&quot;
        value = self.next()
        self.appendleft(value)
        return value
    #
    def rotate(self, n=1):
        &quot;&quot;&quot;append the next `n` values to the end of the iterator

        Similar to `container.deque.rotate`, but
         * negative `n` leads to error
         * a list of the `n` rotated values is returned
        &quot;&quot;&quot;
        result = list(itertools.islice(self, n))
        self.iterators.append(result)
        return result

    #
    def __repr__(self):
        return &quot;XIter(%s)&quot; % repr(self.iterators)
    #
    def  __nonzero__(self):
        &quot;&quot;&quot;Test for a non-zero length of the iterator&quot;&quot;&quot;
        if len(self.iterators) &gt; 1:
            return True
        try:
            self.peek()
        except StopIteration:
            return False
        return True
</pre>
<p>Some optimization could be done adapting a <a class="reference" href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=756253&amp;group_id=5470&amp;atid=305470">roundrobin example</a> posted by
R. Hettinger on 2004-04-30 15:58 in comp.lang.python</p>
<pre class="literal-block">
##
# For the record, here a simple and efficient roundrobin task
# server based on collections.deque:
#
# def roundrobin(*iterables):
#     pending = deque(iter(i).next for i in iterables)
#     gettask, scheduletask = pending.popleft, pending.append
#     while pending:
#         task = gettask()
#         try:
#             yield task()
#         except StopIteration:
#             continue
#         scheduletask(task)
#
# for value in roundrobin('abc', 'd', 'efgh'):
#     print value
</pre>
<p>Do a doctest if the module is run in nosetests:</p>
<pre class="literal-block">
def test():
    import doctest
    doctest.testmod()
</pre>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2007-02-21.

</div>
</body>
</html>
