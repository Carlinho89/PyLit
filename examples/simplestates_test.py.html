<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">
<!-- #!/usr/bin/env python -->
<!-- # -*- coding: iso-8859-1 -*- -->
<!-- simplestates.py:  generic state machine class using iterators
restindex
   crumb: test simplestates.py
/restindex -->
<div class="section">
<h1><a class="toc-backref" href="#id10" id="test-the-simplestates-py-generic-state-machine" name="test-the-simplestates-py-generic-state-machine">1&nbsp;&nbsp;&nbsp;Test the simplestates.py generic state machine</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Status:</th><td class="field-body">draft</td>
</tr>
<tr class="field"><th class="field-name">Date:</th><td class="field-body">2006-12-01</td>
</tr>
<tr class="field"><th class="field-name">Copyright:</th><td class="field-body">2006 Guenter Milde.
Released under the terms of the GNU General Public License
(v. 2 or later)</td>
</tr>
</tbody>
</table>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#test-the-simplestates-py-generic-state-machine" id="id10" name="id10">1&nbsp;&nbsp;&nbsp;Test the simplestates.py generic state machine</a></li>
<li><a class="reference" href="#abstract-state-machine-class" id="id11" name="id11">2&nbsp;&nbsp;&nbsp;Abstract State Machine Class</a><ul class="auto-toc">
<li><a class="reference" href="#example-1-a-two-state-machine-sorting-numbers" id="id12" name="id12">2.1&nbsp;&nbsp;&nbsp;Example 1: A two-state machine sorting numbers</a></li>
</ul>
</li>
<li><a class="reference" href="#varied-state-machine-class-template" id="id13" name="id13">3&nbsp;&nbsp;&nbsp;Varied State Machine Class Template</a><ul class="auto-toc">
<li><a class="reference" href="#example-2-another-two-state-machine-sorting-numbers" id="id14" name="id14">3.1&nbsp;&nbsp;&nbsp;Example 2: Another two-state machine sorting numbers</a></li>
</ul>
</li>
<li><a class="reference" href="#state-machine-class-using-state-handler-generators" id="id15" name="id15">4&nbsp;&nbsp;&nbsp;State Machine class using state_handler generators</a><ul class="auto-toc">
<li><a class="reference" href="#example-3-a-two-state-machine-with-state-handler-generators" id="id16" name="id16">4.1&nbsp;&nbsp;&nbsp;Example 3: A two-state machine with state handler generators</a></li>
</ul>
</li>
<li><a class="reference" href="#backtracking" id="id17" name="id17">5&nbsp;&nbsp;&nbsp;Backtracking</a><ul class="auto-toc">
<li><a class="reference" href="#example-4-a-two-state-machine-with-generators-and-backtracking" id="id18" name="id18">5.1&nbsp;&nbsp;&nbsp;Example 4: A two-state machine with generators and backtracking</a></li>
</ul>
</li>
<li><a class="reference" href="#converting-all-state-method-generators-with-a-generic-function" id="id19" name="id19">6&nbsp;&nbsp;&nbsp;Converting all state method generators with a generic function</a><ul class="auto-toc">
<li><a class="reference" href="#example-5" id="id20" name="id20">6.1&nbsp;&nbsp;&nbsp;Example 5</a></li>
</ul>
</li>
<li><a class="reference" href="#putting-it-together" id="id21" name="id21">7&nbsp;&nbsp;&nbsp;Putting it together</a><ul class="auto-toc">
<li><a class="reference" href="#example-6" id="id22" name="id22">7.1&nbsp;&nbsp;&nbsp;Example 6</a></li>
</ul>
</li>
<li><a class="reference" href="#index" id="id23" name="id23">8&nbsp;&nbsp;&nbsp;Index</a></li>
<li><a class="reference" href="#command-line-usage" id="id24" name="id24">9&nbsp;&nbsp;&nbsp;Command line usage</a></li>
</ul>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id11" id="abstract-state-machine-class" name="abstract-state-machine-class">2&nbsp;&nbsp;&nbsp;Abstract State Machine Class</a></h1>
<p>First version of an abstract state machine</p>
<pre class="literal-block">
class SimpleStates1:
    &quot;&quot;&quot;generic state machine acting on iterable data

    Class attributes
    init_state -- name of the first state_handler method
    &quot;&quot;&quot;
    init_state = 'start'
</pre>
<p>Initialisation</p>
<ul class="simple">
<li>sets the data object to the <tt class="docutils literal"><span class="pre">data</span></tt> argument.</li>
<li>remaining keyword arguments are stored as class attributes (or methods, if
they are function objects) overwriting class defaults (a neat little trick
I found somewhere on the net)</li>
<li>the <tt class="docutils literal"><span class="pre">state_handler</span></tt> attribute is set to the method named in <tt class="docutils literal"><span class="pre">init_state</span></tt></li>
</ul>
<pre class="literal-block">
def __init__(self, data, **keyw):
    &quot;&quot;&quot;data   --  iterable data object
                  (list, file, generator, string, ...)
       **keyw --  all remaining keyword arguments are
                  stored as class attributes
    &quot;&quot;&quot;
    self.data = data
    self.__dict__.update(keyw)
</pre>
<p>The special <tt class="docutils literal"><span class="pre">__iter__</span></tt> method returns an <a class="reference" href="#iterator">iterator</a>. This allows to use
a  class instance directly in an iteration loop.  We define it as is a
<a class="reference" href="#generator">generator</a> method that sets the initial state and then iterates over the
data calling the state methods:</p>
<pre class="literal-block">
def __iter__(self):
    self.state_handler = getattr(self, self.init_state)
    for token in self.data:
        yield self.state_handler(token)
</pre>
<p>To use class instances as callable objects, we add a <tt class="docutils literal"><span class="pre">__call__</span></tt> method:</p>
<pre class="literal-block">
def __call__(self):
    &quot;&quot;&quot;Run state-machine and return tokens as a list&quot;&quot;&quot;
    return [token for token in self]
</pre>
<div class="section">
<h2><a class="toc-backref" href="#id12" id="example-1-a-two-state-machine-sorting-numbers" name="example-1-a-two-state-machine-sorting-numbers">2.1&nbsp;&nbsp;&nbsp;Example 1: A two-state machine sorting numbers</a></h2>
<p>Our small example state machine subclasses the <tt class="docutils literal"><span class="pre">SimpleStates1</span></tt> class:</p>
<pre class="literal-block">
class Example1(SimpleStates1):
    &quot;&quot;&quot;A silly example two-state machine sorting numbers
    in the categories &quot;low&quot; (&lt; 3) and &quot;high&quot; (&gt;= 3).
    &quot;&quot;&quot;
</pre>
<p>It will be completed by two state methods and a <tt class="docutils literal"><span class="pre">__str__</span></tt> method.</p>
<div class="section">
<h3><a id="state-methods" name="state-methods">2.1.1&nbsp;&nbsp;&nbsp;State Methods</a></h3>
<p>State methods are functions that are called to iterate over the data. They
will typically</p>
<ul class="simple">
<li>test the data token for a change of state indicator</li>
<li>return the data token after some processing</li>
</ul>
<p>In our example, the <tt class="docutils literal"><span class="pre">low</span></tt> method switches to <tt class="docutils literal"><span class="pre">high</span></tt> (and calls it with the
data token), if token is bigger than 3. If not, it returns &quot;l(token)&quot;:</p>
<pre class="literal-block">
def low(self, token):
    # print &quot;low(&quot;, token, &quot;)&quot;,
    if token &gt; 3:
        self.state_handler = self.high
        # backtracking
        return self.state_handler(token)
    return &quot;l(%d)&quot;%token
</pre>
<p>The <tt class="docutils literal"><span class="pre">high</span></tt> method switches to <tt class="docutils literal"><span class="pre">low</span></tt>, if token is bigger than 3. If not, it
returns &quot;h(token)&quot;:</p>
<pre class="literal-block">
def high(self, token):
    # print &quot;high(&quot;, token, &quot;)&quot;,
    if token &lt;= 3:
        self.state_handler = self.low
        # backtracking
        return self.state_handler(token)
    return &quot;h(%d)&quot;%token
</pre>
<p>Conversion of the class instance to a string is done by joining the list
that is returned by a call to the instance with spaces:</p>
<pre class="literal-block">
def __str__(self):
    return &quot; &quot;.join(self())
</pre>
</div>
<div class="section">
<h3><a id="test" name="test">2.1.2&nbsp;&nbsp;&nbsp;Test</a></h3>
<p>Testing is done with the <a class="reference" href="http://somethingaboutorange.com/mrl/projects/nose/">nose</a> test framework. This will collect and
execute all test functions and methods (basically everything that starts or
ends with &quot;[Tt]est&quot;). This is similar to the more known &quot;py.test&quot;.</p>
<p>We set up some test data:</p>
<pre class="literal-block">
testdata = [1, 2, 3, 4, 5, 4, 3, 2, 1]
</pre>
<p>and define a test function:</p>
<pre class="literal-block">
def test_Example1():
    statemachine = Example1(testdata, init_state='low')
    for result in statemachine:
        print result,
    print

    # Calling an instance should return a list of results
    print statemachine()
    assert statemachine() == ['l(1)','l(2)','l(3)',  # low numbers
                             'h(4)','h(5)','h(4)',  # high numbers
                             'l(3)','l(2)','l(1)']  # low again

    # Converting to a string should call the __str__ method::
    print str(statemachine)
    assert str(statemachine) == &quot;l(1) l(2) l(3) h(4) h(5) h(4) l(3) l(2) l(1)&quot;
</pre>
</div>
<div class="section">
<h3><a id="discussion" name="discussion">2.1.3&nbsp;&nbsp;&nbsp;Discussion</a></h3>
<p>The sorting works as expected. However, as the state handlers get the data
token by token, acting on subsequent tokens or tests that combine the
knowledge of several tokens are hard to achieve.</p>
<p>An example would be a state handler that sums up the data tokens and
returns the result if it exceeds a threshold.</p>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id13" id="varied-state-machine-class-template" name="varied-state-machine-class-template">3&nbsp;&nbsp;&nbsp;Varied State Machine Class Template</a></h1>
<p>The second version of an abstract state machine converts the test data to an
iterator which is shared by the state methods.</p>
<p>There is no need to pass this on via arguments, as class methods share the
class instances attributes (class variables).</p>
<p>We subclass our first version and modify to our needs:</p>
<pre class="literal-block">
class SimpleStates2(SimpleStates1):
    &quot;&quot;&quot;second version of the abstract state machine class
    &quot;&quot;&quot;
</pre>
<p>We add the initialization of the data to the <tt class="docutils literal"><span class="pre">__iter__</span></tt> method. The data is
transformed inta an <a class="reference" href="#iterator">iterator</a> first.</p>
<pre class="literal-block">
def __iter__(self):
    self.data_iterator = iter(self.data)
    self.state_handler = getattr(self, self.init_state)
    # do not pass data tokens as argument
    # (state methods should call self.data_iterator.next() instead)
    while True:
        yield self.state_handler()
</pre>
<p>Iterators &quot;use up&quot; the data, so the state methods will always get a &quot;new&quot;
token until the data is fully &quot;used up&quot; and <tt class="docutils literal"><span class="pre">StopIteration</span></tt> is raised
aborting the iteration.</p>
<p>Doing the conversion from iterable to iterator in <tt class="docutils literal"><span class="pre">__iter__</span></tt> and not in
<tt class="docutils literal"><span class="pre">__init__</span></tt> allows repeated iteration over the class instance (if the data is
a list or a file and not already a generator) as the &quot;used up&quot; generator is
replaced by a new one.</p>
<div class="section">
<h2><a class="toc-backref" href="#id14" id="example-2-another-two-state-machine-sorting-numbers" name="example-2-another-two-state-machine-sorting-numbers">3.1&nbsp;&nbsp;&nbsp;Example 2: Another two-state machine sorting numbers</a></h2>
<p>Our small example state machine subclasses the <tt class="docutils literal"><span class="pre">SimpleStates2</span></tt> class
and adds 2 methods as state handlers.</p>
<pre class="literal-block">
class Example2(SimpleStates2):
    &quot;&quot;&quot;An example two-state machine sorting numbers
    in the categories &quot;low&quot; (&lt; 3) and &quot;high&quot; (&gt;= 3).
    &quot;&quot;&quot;
</pre>
<div class="section">
<h3><a id="id1" name="id1">3.1.1&nbsp;&nbsp;&nbsp;State methods</a></h3>
<p>This time, the state methods will get the data tokens not as argument but
take them from the <tt class="docutils literal"><span class="pre">data_iterator</span></tt>. Note that <em>backtracking</em> is impossible
with a standard iterator. See below for the problem this causes for our
sorting algorithm.</p>
<pre class="literal-block">
def low(self):
    # print &quot;low(&quot;, token, &quot;)&quot;,
    token = self.data_iterator.next()
    if token &gt; 3:
        self.state_handler = self.high
    return &quot;l(%d)&quot;%token
def high(self):
    # print &quot;high(&quot;, token, &quot;)&quot;,
    token = self.data_iterator.next()
    if token &lt;= 3:
        self.state_handler = self.low
    return &quot;h(%d)&quot;%token
</pre>
</div>
<div class="section">
<h3><a id="id2" name="id2">3.1.2&nbsp;&nbsp;&nbsp;Test</a></h3>
<p>Define a second test function:</p>
<pre class="literal-block">
def test_Example2():
    statemachine = Example2(testdata, init_state='low')
</pre>
<p>Calling an instance should return a list of results. However, as
we cannot backtrack on a normal iterator, the result is not as we expected:
There is a &quot;hysteresis&quot; the &quot;switch triggering&quot; token is always processed by
the &quot;old&quot; state:</p>
<pre class="literal-block">
print statemachine()
assert statemachine() == ['l(1)', 'l(2)', 'l(3)', # low numbers
                         'l(4)', 'h(5)', 'h(4)', # high numbers
                         'h(3)', 'l(2)', 'l(1)'] # low numbers
</pre>
</div>
<div class="section">
<h3><a id="id3" name="id3">3.1.3&nbsp;&nbsp;&nbsp;Discussion</a></h3>
<p>Missing backtracks break our number sorting machine. The remedy
is the use of an iterator with an appendleft() method (known from the
dqueue() standard class). We will come to this in <a class="reference" href="#example-4-a-two-state-machine-with-generators-and-backtracking">Example 4</a></p>
<p>OTOH, as the state methods do the fetching of data tokens themself, a state
handler that sums up the data tokens and returns the result if it exceeds a
threshold would be easy to implement. We will do this in our next example
using state handler generators.</p>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id15" id="state-machine-class-using-state-handler-generators" name="state-machine-class-using-state-handler-generators">4&nbsp;&nbsp;&nbsp;State Machine class using state_handler generators</a></h1>
<p>The variations in <tt class="docutils literal"><span class="pre">StateMachine2</span></tt> complicate the StateMachine design. They
makes sense, however, if we use generated iterators to handle the states.
No changes are needed to the abstract base class, so that Example 3 can
build on <tt class="docutils literal"><span class="pre">StateMachine2</span></tt>:</p>
<pre class="literal-block">
class Example3(SimpleStates2):
</pre>
<div class="section">
<h2><a class="toc-backref" href="#id16" id="example-3-a-two-state-machine-with-state-handler-generators" name="example-3-a-two-state-machine-with-state-handler-generators">4.1&nbsp;&nbsp;&nbsp;Example 3: A two-state machine with state handler generators</a></h2>
<div class="section">
<h3><a id="state-generators" name="state-generators">4.1.1&nbsp;&nbsp;&nbsp;State Generators</a></h3>
<p>State Generators generate and return an iterator that will handle the next
data token(s) if its .next() method is called. This is easily achieved with a
for loop over self.data and the <tt class="docutils literal"><span class="pre">yield</span></tt> keyword.</p>
<pre class="literal-block">
def high_handler_generator(self):
    &quot;&quot;&quot;Return an iterator, whose next() method
    returns &quot;h(token)&quot; and switches to `low`, if token &gt; 3
    &quot;&quot;&quot;
    for token in self.data_iterator:
        if token &lt;= 3:
            self.state_handler = self.low
        yield &quot;h(%d)&quot;%token
#
def low_handler_generator(self):
    &quot;&quot;&quot;Return an iterator, whose next() method sums up data tokens.
    If the sum exceeds 8, it is returned and the state
    switches to `high`.
    &quot;&quot;&quot;
    sum = 0
    for token in self.data_iterator:
        sum += token
        if sum &gt; 8:
            self.state_handler = self.high
            yield &quot;s=%d&quot;%sum
            sum = 0 # next iteration continues here
    # no more tokens but sum not reached
    yield &quot;p=%d&quot;%sum # partial sum
</pre>
<p>The iterator must instanciate the state-iterators before starting the
iteration loop:</p>
<pre class="literal-block">
def __iter__(self):
    &quot;&quot;&quot;Generate and return an iterator

    * convert `data` to an iterator
    * convert the state generators into iterators
    * (re) set the state_handler attribute to the init-state
    * pass control to the active states state_handler
      which should call and process self.data_iterator.next()
    &quot;&quot;&quot;
    self.data_iterator = iter(self.data)
    self.high = self.high_handler_generator().next
    self.low = self.low_handler_generator().next
    # init state
    self.state_handler = getattr(self, self.init_state)
    # now start the iteration, aborts if data is empty
    while True:
        yield self.state_handler()
</pre>
</div>
<div class="section">
<h3><a id="id5" name="id5">4.1.2&nbsp;&nbsp;&nbsp;Test</a></h3>
<p>Again define a test function that gets an instance of the Example3 class</p>
<pre class="literal-block">
def test_Example3():
    statemachine = Example3(testdata, init_state='low')
</pre>
<p>Calling statemachine() should iterate over the test data and return the
processed values as list:</p>
<pre class="literal-block">
print statemachine()
assert statemachine() == ['s=10','h(5)','h(4)','h(3)', 'p=3']
</pre>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id17" id="backtracking" name="backtracking">5&nbsp;&nbsp;&nbsp;Backtracking</a></h1>
<p>the iterqueue module provides an &quot;extendable&quot; iterator with, e.g.,
an <tt class="docutils literal"><span class="pre">appendleft</span></tt> method to push back values:</p>
<pre class="literal-block">
from iterqueue import XIter
</pre>
<p>Thus we can prepend a non-processed data item
to the data iterator for use by the next state handler</p>
<div class="section">
<h2><a class="toc-backref" href="#id18" id="example-4-a-two-state-machine-with-generators-and-backtracking" name="example-4-a-two-state-machine-with-generators-and-backtracking">5.1&nbsp;&nbsp;&nbsp;Example 4: A two-state machine with generators and backtracking</a></h2>
<p>Again we start from the <tt class="docutils literal"><span class="pre">SimpleStates2</span></tt> base class:</p>
<pre class="literal-block">
class Example4(SimpleStates2):
    &quot;&quot;&quot;two-state machine with generators and backtracking
    &quot;&quot;&quot;
</pre>
<p>Let the iterator wrap the data in an XIter instance with <tt class="docutils literal"><span class="pre">appendleft</span></tt>
method:</p>
<pre class="literal-block">
def __iter__(self):
    &quot;&quot;&quot;Generate and return an iterator

    * convert `data` to an iterator queue
    * convert the state generators into iterators
    * (re) set the state_handler attribute to the init-state
    * pass control to the active states state_handler
      which should call and process self.data_iterator.next()
    &quot;&quot;&quot;
    self.data_iterator = XIter(self.data) # queue with `appendleft` method
    self.high = self.high_handler_generator().next
    self.low = self.low_handler_generator().next
    self.state_handler = getattr(self, self.init_state)
    # now start the iteration
    while True:
        yield self.state_handler()
</pre>
<p>Add state method generators that use the &quot;backtracking&quot; feature:</p>
<pre class="literal-block">
def high_handler_generator(self):
    &quot;&quot;&quot;Return an iterator, whose next() method
    returns &quot;h(token)&quot; and switches to `low`, if token &gt; 3
    &quot;&quot;&quot;
    for token in self.data_iterator:
        # print &quot;high got&quot;, token
        if token &lt;= 3:
            # push back data token
            self.data_iterator.appendleft(token)
            # set the new state
            self.state_handler = self.low
            # return non-value indicating the state switch
            yield None
        else:
            yield &quot;h(%d)&quot;%token
#
def low_handler_generator(self):
    &quot;&quot;&quot;Return an iterator, whose next() method
    returns &quot;l(token)&quot; and switches to `high`, if token &lt;=3
    &quot;&quot;&quot;
    for token in self.data_iterator:
        # print &quot;low got&quot;, token
        if token &gt; 3:
            self.data_iterator.appendleft(token) # push back
            # set and run the new state
            self.state_handler = self.high
            # alternatively, return the token processed by the new
            # state handler
            yield self.state_handler()
        else:
            yield &quot;l(%d)&quot;%token
</pre>
<p>The <tt class="docutils literal"><span class="pre">__str__</span></tt> converter should ignore the switch-indicator:</p>
<pre class="literal-block">
def __str__(self):
    tokens = [token for token in self() if token != None]
    return &quot; &quot;.join(tokens)
</pre>
<div class="section">
<h3><a id="id6" name="id6">5.1.1&nbsp;&nbsp;&nbsp;Test</a></h3>
<p>Again define a test function. This time with an instance of the Example4
class</p>
<pre class="literal-block">
def test_Example4():
    statemachine = Example4(testdata, init_state='low')
</pre>
<p>Calling statemachine() should iterate over the test data and return the
processed values as list. If the state of the machine changes, the special
&quot;non-value&quot; <tt class="docutils literal"><span class="pre">None</span></tt> is returned.</p>
<pre class="literal-block">
print statemachine() # only printed if something goes wrong
assert statemachine() == ['l(1)', 'l(2)', 'l(3)',
                         'h(4)', 'h(5)', 'h(4)', None, # switch indicator
                         'l(3)', 'l(2)', 'l(1)']
</pre>
<p>Converting to a string should skip the <tt class="docutils literal"><span class="pre">None</span></tt> values:</p>
<pre class="literal-block">
print statemachine
assert str(statemachine) == &quot;l(1) l(2) l(3) h(4) h(5) h(4) l(3) l(2) l(1)&quot;
</pre>
</div>
<div class="section">
<h3><a id="id7" name="id7">5.1.2&nbsp;&nbsp;&nbsp;Discussion</a></h3>
<p>The <tt class="docutils literal"><span class="pre">XIter</span></tt> class allows backtracking also in a state machine with state
handlers acting on a common iterator object. The &quot;high&quot; and &quot;low&quot; handlers
demonstrate two possible actions for the state-transition with backtrack:
Either call the new state handler from the current one
(like the <tt class="docutils literal"><span class="pre">low_handler_generator</span></tt>) or return a &quot;non-value&quot; that signifies
that processing the data token did not produce any output data.</p>
<p>Using generators made the state handlers shorter and (once the concept of a
generator is clear) easier. Further advantages of the generator concept are</p>
<ul class="simple">
<li>internal variables are easily saved over subsequent invocations</li>
<li>no function-call overhead (not relevant in this example but maybe for a
state machine that has to process long data lists.</li>
</ul>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id19" id="converting-all-state-method-generators-with-a-generic-function" name="converting-all-state-method-generators-with-a-generic-function">6&nbsp;&nbsp;&nbsp;Converting all state method generators with a generic function</a></h1>
<p>In <tt class="docutils literal"><span class="pre">Example4</span></tt>, we had to redefine the <tt class="docutils literal"><span class="pre">__iter__</span></tt> method to convert the
methode state generators into iterators. It would be nice if this could be
done in the base class.</p>
<p><tt class="docutils literal"><span class="pre">SimpleStates3</span></tt> adds a generic function for this task that relies on a
simple naming convention: functions whose name matches
<tt class="docutils literal"><span class="pre">&lt;state&gt;_handler_generator</span></tt> should be converted to iterators and their
<tt class="docutils literal"><span class="pre">.next()</span></tt> method stored as <tt class="docutils literal"><span class="pre">&lt;state&gt;</span></tt>.</p>
<pre class="literal-block">
class SimpleStates5(SimpleStates2):
    &quot;&quot;&quot;generic state machine acting on iterable data
    &quot;&quot;&quot;
    def _initialize_state_generators(self):
        &quot;&quot;&quot;Generic function to initialize state handlers from generators

        functions whose name matches `[^_]&lt;state&gt;_handler_generator` should
        be converted to iterators and their `.next()` method stored as
        `&lt;state&gt;`.
        &quot;&quot;&quot;
        suffix = &quot;_handler_generator&quot;
        shg_names = [name for name in dir(self)
                      if name.endswith(suffix)
                      and not name.startswith(&quot;_&quot;)]
        for name in shg_names:
            shg = getattr(self, name)
            print shg
            setattr(self, name[:-len(suffix)], shg().next)


    def __iter__(self):
        &quot;&quot;&quot;Generate and return an iterator

        * convert `data` to an iterator queue
        * convert the state generators into iterators
        * (re) set the state_handler attribute to the init-state
        * pass control to the active states state_handler
          which should call and process self.data_iterator.next()
        &quot;&quot;&quot;
        self.data_iterator = XIter(self.data) # queue with `appendleft` method
        self._initialize_state_generators()
        self.state_handler = getattr(self, self.init_state)
        # now start the iteration
        while True:
            yield self.state_handler()
</pre>
<div class="section">
<h2><a class="toc-backref" href="#id20" id="example-5" name="example-5">6.1&nbsp;&nbsp;&nbsp;Example 5</a></h2>
<p>The next example combines the state handlers from Example 4 and the new
class.:</p>
<pre class="literal-block">
class Example5(Example4, SimpleStates5):
    &quot;&quot;&quot;one more example&quot;&quot;&quot;
    pass
</pre>
<div class="section">
<h3><a id="id8" name="id8">6.1.1&nbsp;&nbsp;&nbsp;Test</a></h3>
<p>A function that has the generator-suffix but is prefixed with an underscore,
should be skipped by the <tt class="docutils literal"><span class="pre">_initialize_state_generators</span></tt> method:</p>
<pre class="literal-block">
class Test_SimpleStates5:
    E5 = Example5(testdata)
    E5._bogus_handler_generator = &quot;low&quot;
    def test_initialize_state_generators(self):
        self.E5._initialize_state_generators()
</pre>
<p>A test function. This time with an instance of the Example5 class</p>
<pre class="literal-block">
def test_Example5():
    statemachine = Example5(testdata, init_state='low')
    print statemachine.__dict__
</pre>
<p>Calling statemachine() should iterate over the test data and return the
processed values as list. If the state of the machine changes, the special
&quot;non-value&quot; <tt class="docutils literal"><span class="pre">None</span></tt> is returned.</p>
<pre class="literal-block">
print statemachine() # only printed if something goes wrong
assert statemachine() == ['l(1)', 'l(2)', 'l(3)',
                         'h(4)', 'h(5)', 'h(4)', None, # switch indicator
                         'l(3)', 'l(2)', 'l(1)']
</pre>
<p>Converting to a string should skip the <tt class="docutils literal"><span class="pre">None</span></tt> values:</p>
<pre class="literal-block">
print statemachine
assert str(statemachine) == &quot;l(1) l(2) l(3) h(4) h(5) h(4) l(3) l(2) l(1)&quot;
</pre>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id21" id="putting-it-together" name="putting-it-together">7&nbsp;&nbsp;&nbsp;Putting it together</a></h1>
<p>The file <tt class="docutils literal"><span class="pre">simplestates.py</span></tt> contains the full definition of the <tt class="docutils literal"><span class="pre">SimpleStates5</span></tt>
class in a self-contained version.</p>
<div class="section">
<h2><a class="toc-backref" href="#id22" id="example-6" name="example-6">7.1&nbsp;&nbsp;&nbsp;Example 6</a></h2>
<p>The final Example is used to test whether we have put it together well. It
subclasses SimpleStates and adds state method generators for &quot;high&quot; and
&quot;low&quot;:</p>
<pre class="literal-block">
import simplestates
class Example6(simplestates.SimpleStates):
    &quot;&quot;&quot;two-state machine with generators and backtracking
    &quot;&quot;&quot;
    def high_handler_generator(self):
        &quot;&quot;&quot;Return an iterator, whose next() method
        returns &quot;h(token)&quot; and switches to `low`, if token &gt; 3
        &quot;&quot;&quot;
        for token in self.data_iterator:
            # print &quot;high got&quot;, token
            if token &lt;= 3:
                # push back data token
                self.data_iterator.appendleft(token)
                # set the new state
                self.state_handler = self.low
                # return the token processed by the new state handler
                yield self.state_handler()
            else:
                yield &quot;h(%d)&quot;%token
    #
    def low_handler_generator(self):
        &quot;&quot;&quot;Return an iterator, whose next() method
        returns &quot;l(token)&quot; and switches to `high`, if token &lt;=3
        &quot;&quot;&quot;
        for token in self.data_iterator:
            # print &quot;low got&quot;, token
            if token &gt; 3:
                self.data_iterator.appendleft(token) # push back
                # set and run the new state
                self.state_handler = self.high
                # return the token processed by the new state handler
                yield self.state_handler()
            else:
                yield &quot;l(%d)&quot;%token
</pre>
<div class="section">
<h3><a id="id9" name="id9">7.1.1&nbsp;&nbsp;&nbsp;Test</a></h3>
<p>In order not to make it dependent on the iterqueue module, the final
<tt class="docutils literal"><span class="pre">SimpleStates</span></tt> doesnot wrap the data in an XIter instance. This step should
be done at the instanciation of a state machine.</p>
<pre class="literal-block">
def test_Example5():
    statemachine = Example5(XIter(testdata), init_state='low')
    print statemachine.__dict__
</pre>
<p>Calling statemachine() should iterate over the test data and return the
processed values as list:</p>
<pre class="literal-block">
print statemachine() # only printed if something goes wrong
# reset the data iterator as it is &quot;used up&quot; now
statemachine.data = XIter(testdata)
assert statemachine() == ['l(1)', 'l(2)', 'l(3)',
                         'h(4)', 'h(5)', 'h(4)', None,
                         'l(3)', 'l(2)', 'l(1)']
</pre>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id23" id="index" name="index">8&nbsp;&nbsp;&nbsp;Index</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><span class="target" id="generator">generator</span>:</th><td class="field-body">A function with a <tt class="docutils literal"><span class="pre">yield</span></tt> keyword. Calling this function will
return an <a class="reference" href="#iterator">iterator</a></td>
</tr>
<tr class="field"><th class="field-name"><span class="target" id="iterator">iterator</span>:</th><td class="field-body">An object with a <tt class="docutils literal"><span class="pre">next()</span></tt> method. Calling <tt class="docutils literal"><span class="pre">&lt;iterator&gt;.next()</span></tt>
will (typically) return one data token (list element, line in
a file, ...). If there is no more data the <tt class="docutils literal"><span class="pre">StopIteration</span></tt>
exception is raised.</td>
</tr>
</tbody>
</table>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id24" id="command-line-usage" name="command-line-usage">9&nbsp;&nbsp;&nbsp;Command line usage</a></h1>
<p>running this script should explore it in the &quot;nose&quot; test framework:</p>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;:
    import nose, doctest
    # first run any doctests
    doctest.testmod()
    # then run nose on this module
    nose.runmodule() # requires nose 0.9.1
</pre>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2007-02-21.

</div>
</body>
</html>
